const CONTRACT_NAME="packmanager",UTILITY_TOKEN_SYMBOL="BEE",UTILITY_TOKEN_PRECISION=8,MAX_NAME_LENGTH=100,MAX_CARDS_PER_PACK=30,MAX_CARDS_AT_ONCE=60,MAX_PARTITIONS=100,MAX_ROLLS=10,MAX_NUM_NFTS_ISSUABLE=10;actions.createSSC=async()=>{if(!1===await api.db.tableExists("packs")){await api.db.createTable("packs",["account","symbol","nft"]),await api.db.createTable("types",["nft","edition","typeId"]),await api.db.createTable("foils",["nft","edition","index"]),await api.db.createTable("categories",["nft","edition","index"]),await api.db.createTable("rarities",["nft","edition","index"]),await api.db.createTable("teams",["nft","edition","index"]),await api.db.createTable("managedNfts",["nft"]),await api.db.createTable("params");const params={registerFee:"1000",typeAddFee:"1"};await api.db.insert("params",params)}};const doRandomRoll=partition=>{let result=0;const roll=Math.floor(api.random()*partition[partition.length-1])+1;for(let i=0;i<partition.length&&roll>partition[i];i+=1)result+=1;return result>=partition.length&&(result=partition.length-1),result},isValidPartition=partition=>{if(partition&&"object"==typeof partition&&Array.isArray(partition)&&partition.length>=1&&partition.length<=100){let prevNum=0;for(let i=0;i<partition.length;i+=1){const val=partition[i];if(!("number"==typeof val&&Number.isInteger(val)&&val>prevNum))return!1;prevNum=val}return!0}return!1},isTokenTransferVerified=(result,from,to,symbol,quantity,eventStr)=>!(void 0!==result.errors||!result.events||void 0===result.events.find(el=>"tokens"===el.contract&&el.event===eventStr&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol)),countNftIssuance=(result,from,to,symbol)=>{let count=0;if(void 0===result.errors&&result.events){count=result.events.filter(e=>"nft"===e.contract&&"issue"===e.event&&e.data.from===from&&e.data.to===to&&e.data.symbol===symbol).length}return count},calculateBalance=(balance,quantity,precision,add)=>add?api.BigNumber(balance).plus(quantity).toFixed(precision):api.BigNumber(balance).minus(quantity).toFixed(precision),countDecimals=value=>api.BigNumber(value).dp(),verifyTokenBalance=async(amount,symbol,account)=>{if(api.BigNumber(amount).lte(0))return!0;const tokenBalance=await api.db.findOneInTable("tokens","balances",{account:account,symbol:symbol});return!(!tokenBalance||!api.BigNumber(tokenBalance.balance).gte(amount))},transferFee=async(amount,dest,isSignedWithActiveKey)=>{const actionStr="packmanager"===dest?"transferToContract":"transfer";if(api.BigNumber(amount).gt(0)){const res=await api.executeSmartContract("tokens",actionStr,{to:dest,symbol:"BEE",quantity:amount,isSignedWithActiveKey:isSignedWithActiveKey});if(!isTokenTransferVerified(res,api.sender,dest,"BEE",amount,actionStr))return!1}return!0};actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{registerFee:registerFee,typeAddFee:typeAddFee}=payload,params=await api.db.findOne("params",{});registerFee&&"string"==typeof registerFee&&!api.BigNumber(registerFee).isNaN()&&api.BigNumber(registerFee).gte(0)&&(params.registerFee=registerFee),typeAddFee&&"string"==typeof typeAddFee&&!api.BigNumber(typeAddFee).isNaN()&&api.BigNumber(typeAddFee).gte(0)&&(params.typeAddFee=typeAddFee),await api.db.update("params",params)},actions.deposit=async payload=>{const{nftSymbol:nftSymbol,amount:amount,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(nftSymbol&&"string"==typeof nftSymbol&&amount&&"string"==typeof amount&&!api.BigNumber(amount).isNaN()&&api.BigNumber(amount).gt(0)&&countDecimals(amount)<=8,"invalid params")){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==underManagement,"NFT not under management")){const hasEnoughBalance=await verifyTokenBalance(amount,"BEE",api.sender);if(api.assert(hasEnoughBalance,"not enough tokens to deposit"))return!!await transferFee(amount,"packmanager",isSignedWithActiveKey)&&(underManagement.feePool=calculateBalance(underManagement.feePool,amount,8,!0),await api.db.update("managedNfts",underManagement),api.emit("deposit",{nft:nftSymbol,newFeePool:underManagement.feePool}),!0)}}return!1},actions.deleteType=async payload=>{const{nftSymbol:nftSymbol,edition:edition,typeId:typeId,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(nftSymbol&&"string"==typeof nftSymbol&&void 0!==typeId&&"number"==typeof typeId&&Number.isInteger(typeId)&&typeId>=0&&void 0!==edition&&"number"==typeof edition&&Number.isInteger(edition)&&edition>=0,"invalid params")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:nftSymbol});if(api.assert(null!==nft,"NFT symbol must exist")&&api.assert(nft.issuer===api.sender,"not authorized to delete types")&&api.assert(0===nft.circulatingSupply,"NFT instances must not be in circulation")){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==underManagement,"NFT not under management")){const theType=await api.db.findOne("types",{nft:nftSymbol,edition:edition,typeId:typeId});if(null!==theType)return await api.db.remove("types",theType),api.emit("deleteType",{nft:nftSymbol,edition:edition,typeId:typeId}),!0}}}return!1},actions.updateType=async payload=>{const{nftSymbol:nftSymbol,edition:edition,typeId:typeId,category:category,rarity:rarity,team:team,name:name,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(void 0===name&&void 0===category&&void 0===rarity&&void 0===team)return!1;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(void 0===name||name&&"string"==typeof name&&api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=100,"invalid type name: letters, numbers, whitespaces only, max length of 100")&&api.assert(nftSymbol&&"string"==typeof nftSymbol&&void 0!==typeId&&"number"==typeof typeId&&Number.isInteger(typeId)&&typeId>=0&&void 0!==edition&&"number"==typeof edition&&Number.isInteger(edition)&&edition>=0&&(void 0===category||"number"==typeof category&&Number.isInteger(category)&&category>=0)&&(void 0===rarity||"number"==typeof rarity&&Number.isInteger(rarity)&&rarity>=0)&&(void 0===team||"number"==typeof team&&Number.isInteger(team)&&team>=0),"invalid params")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:nftSymbol});if(api.assert(null!==nft,"NFT symbol must exist")&&api.assert(nft.issuer===api.sender,"not authorized to update types")){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==underManagement,"NFT not under management")&&api.assert(edition.toString()in underManagement.editionMapping,"edition not registered")){const editionMapping=underManagement.editionMapping[edition.toString()];if(api.assert(!(void 0!==category&&editionMapping.categoryRO||void 0!==rarity&&editionMapping.rarityRO||void 0!==team&&editionMapping.teamRO||void 0!==name&&editionMapping.nameRO),"cannot edit read-only properties")){const theType=await api.db.findOne("types",{nft:nftSymbol,edition:edition,typeId:typeId});if(api.assert(null!==theType,"type does not exist")){const update={nft:nftSymbol,edition:edition,typeId:typeId};return void 0!==name&&(update.oldName=theType.name,theType.name=name,update.newName=name),void 0!==category&&(update.oldCategory=theType.category,theType.category=category,update.newCategory=category),void 0!==rarity&&(update.oldRarity=theType.rarity,theType.rarity=rarity,update.newRarity=rarity),void 0!==team&&(update.oldTeam=theType.team,theType.team=team,update.newTeam=team),await api.db.update("types",theType),api.emit("updateType",update),!0}}}}}return!1},actions.addType=async payload=>{const{nftSymbol:nftSymbol,edition:edition,category:category,rarity:rarity,team:team,name:name,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(name&&"string"==typeof name&&api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=100,"invalid type name: letters, numbers, whitespaces only, max length of 100")&&api.assert(nftSymbol&&"string"==typeof nftSymbol&&void 0!==edition&&"number"==typeof edition&&Number.isInteger(edition)&&edition>=0&&void 0!==category&&"number"==typeof category&&Number.isInteger(category)&&category>=0&&void 0!==rarity&&"number"==typeof rarity&&Number.isInteger(rarity)&&rarity>=0&&void 0!==team&&"number"==typeof team&&Number.isInteger(team)&&team>=0,"invalid params")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:nftSymbol});if(api.assert(null!==nft,"NFT symbol must exist")&&api.assert(nft.issuer===api.sender,"not authorized to add a type")){const params=await api.db.findOne("params",{}),hasEnoughBalance=await verifyTokenBalance(params.typeAddFee,"BEE",api.sender);if(api.assert(hasEnoughBalance,"you must have enough tokens to cover the type add fee")){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==underManagement,"NFT not under management")&&api.assert(edition.toString()in underManagement.editionMapping,"edition not registered")){if(!await transferFee(params.typeAddFee,"null",isSignedWithActiveKey))return!1;const newTypeId=underManagement.editionMapping[edition.toString()].nextTypeId,newType={nft:nftSymbol,edition:edition,typeId:newTypeId,category:category,rarity:rarity,team:team,name:name},result=await api.db.insert("types",newType);return underManagement.editionMapping[edition.toString()].nextTypeId=newTypeId+1,await api.db.update("managedNfts",underManagement),api.emit("addType",{nft:nftSymbol,edition:edition,typeId:newTypeId,rowId:result._id}),!0}}}}return!1},actions.setTraitName=async payload=>{const{nftSymbol:nftSymbol,edition:edition,trait:trait,index:index,name:name,isSignedWithActiveKey:isSignedWithActiveKey}=payload,tableMapping={foil:"foils",category:"categories",rarity:"rarities",team:"teams"};if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(name&&"string"==typeof name&&api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=100,"invalid trait name: letters, numbers, whitespaces only, max length of 100")&&api.assert(nftSymbol&&"string"==typeof nftSymbol&&trait&&"string"==typeof trait&&["foil","category","rarity","team"].includes(trait)&&void 0!==index&&"number"==typeof index&&Number.isInteger(index)&&index>=0&&index<100&&void 0!==edition&&"number"==typeof edition&&Number.isInteger(edition)&&edition>=0,"invalid params")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:nftSymbol});if(api.assert(null!==nft,"NFT symbol must exist")&&api.assert(nft.issuer===api.sender,"not authorized for updates")){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==underManagement,"NFT not under management")&&api.assert(edition.toString()in underManagement.editionMapping,"edition not registered")){const currentTrait=await api.db.findOne(tableMapping[trait],{nft:nftSymbol,edition:edition,index:index});if(null!==currentTrait){if(name!==currentTrait.name){const oldName=currentTrait.name;currentTrait.name=name,await api.db.update(tableMapping[trait],currentTrait),api.emit("updateTraitName",{nft:nftSymbol,edition:edition,trait:trait,index:index,oldName:oldName,newName:name})}}else{const newTrait={nft:nftSymbol,edition:edition,index:index,name:name};await api.db.insert(tableMapping[trait],newTrait),api.emit("setTraitName",{nft:nftSymbol,edition:edition,trait:trait,index:index,name:name})}}}}},actions.updateEdition=async payload=>{const{nftSymbol:nftSymbol,edition:edition,editionName:editionName,categoryRO:categoryRO,rarityRO:rarityRO,teamRO:teamRO,nameRO:nameRO,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(void 0===editionName&&void 0===categoryRO&&void 0===rarityRO&&void 0===teamRO&&void 0===nameRO)return!1;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(void 0===editionName||editionName&&"string"==typeof editionName&&api.validator.isAlphanumeric(api.validator.blacklist(editionName," "))&&editionName.length>0&&editionName.length<=100,"invalid edition name: letters, numbers, whitespaces only, max length of 100")&&api.assert(nftSymbol&&"string"==typeof nftSymbol&&(void 0===categoryRO||categoryRO&&"boolean"==typeof categoryRO)&&(void 0===rarityRO||rarityRO&&"boolean"==typeof rarityRO)&&(void 0===teamRO||teamRO&&"boolean"==typeof teamRO)&&(void 0===nameRO||nameRO&&"boolean"==typeof nameRO)&&void 0!==edition&&"number"==typeof edition&&Number.isInteger(edition)&&edition>=0,"invalid params")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:nftSymbol});if(api.assert(null!==nft,"NFT symbol must exist")&&api.assert(nft.issuer===api.sender,"not authorized for updates")){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==underManagement,"NFT not under management")&&api.assert(edition.toString()in underManagement.editionMapping,"edition not registered")){const editionMap=underManagement.editionMapping[edition.toString()],update={nft:nftSymbol,edition:edition};return void 0!==editionName&&(update.oldEditionName=editionMap.editionName,editionMap.editionName=editionName,update.newEditionName=editionName),categoryRO&&(editionMap.categoryRO=!0,update.categoryRO=!0),rarityRO&&(editionMap.rarityRO=!0,update.rarityRO=!0),teamRO&&(editionMap.teamRO=!0,update.teamRO=!0),nameRO&&(editionMap.nameRO=!0,update.nameRO=!0),await api.db.update("managedNfts",underManagement),api.emit("updateEdition",update),!0}}}return!1},actions.updatePack=async payload=>{const{packSymbol:packSymbol,nftSymbol:nftSymbol,edition:edition,cardsPerPack:cardsPerPack,foilChance:foilChance,categoryChance:categoryChance,rarityChance:rarityChance,teamChance:teamChance,numRolls:numRolls,isFinalized:isFinalized,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(void 0===edition&&void 0===cardsPerPack&&void 0===foilChance&&void 0===categoryChance&&void 0===rarityChance&&void 0===teamChance&&void 0===numRolls&&void 0===isFinalized)return!1;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(packSymbol&&"string"==typeof packSymbol&&nftSymbol&&"string"==typeof nftSymbol&&(void 0===isFinalized||isFinalized&&"boolean"==typeof isFinalized)&&(void 0===edition||"number"==typeof edition&&Number.isInteger(edition)&&edition>=0)&&(void 0===numRolls||"number"==typeof numRolls&&Number.isInteger(numRolls)&&numRolls>=1&&numRolls<=10)&&(void 0===foilChance||isValidPartition(foilChance))&&(void 0===categoryChance||isValidPartition(categoryChance))&&(void 0===rarityChance||isValidPartition(rarityChance))&&(void 0===teamChance||isValidPartition(teamChance))&&(void 0===cardsPerPack||"number"==typeof cardsPerPack&&Number.isInteger(cardsPerPack)&&cardsPerPack>=1&&cardsPerPack<=30),"invalid params")){const settings=await api.db.findOne("packs",{symbol:packSymbol,nft:nftSymbol});if(api.assert(null!==settings,"pack not registered for this NFT")&&api.assert(settings.account===api.sender,"not authorized to update settings")&&api.assert(!settings.isFinalized,"pack settings already finalized")){if(void 0!==edition){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(!api.assert(null!==underManagement&&edition.toString()in underManagement.editionMapping,"edition not registered"))return!1}const update={symbol:packSymbol,nft:nftSymbol};return void 0!==edition&&(update.oldEdition=settings.edition,settings.edition=edition,update.newEdition=edition),void 0!==cardsPerPack&&(update.oldCardsPerPack=settings.cardsPerPack,settings.cardsPerPack=cardsPerPack,update.newCardsPerPack=cardsPerPack),void 0!==foilChance&&(update.oldFoilChance=settings.foilChance,settings.foilChance=foilChance,update.newFoilChance=foilChance),void 0!==categoryChance&&(update.oldCategoryChance=settings.categoryChance,settings.categoryChance=categoryChance,update.newCategoryChance=categoryChance),void 0!==rarityChance&&(update.oldRarityChance=settings.rarityChance,settings.rarityChance=rarityChance,update.newRarityChance=rarityChance),void 0!==teamChance&&(update.oldTeamChance=settings.teamChance,settings.teamChance=teamChance,update.newTeamChance=teamChance),void 0!==numRolls&&(update.oldNumRolls=settings.numRolls,settings.numRolls=numRolls,update.newNumRolls=numRolls),isFinalized&&(settings.isFinalized=!0,update.isFinalized=!0),await api.db.update("packs",settings),api.emit("updatePack",update),!0}}return!1},actions.registerPack=async payload=>{const{packSymbol:packSymbol,nftSymbol:nftSymbol,edition:edition,editionName:editionName,cardsPerPack:cardsPerPack,foilChance:foilChance,categoryChance:categoryChance,rarityChance:rarityChance,teamChance:teamChance,numRolls:numRolls,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(void 0===editionName||editionName&&"string"==typeof editionName&&api.validator.isAlphanumeric(api.validator.blacklist(editionName," "))&&editionName.length>0&&editionName.length<=100,"invalid edition name: letters, numbers, whitespaces only, max length of 100")&&api.assert(packSymbol&&"string"==typeof packSymbol&&nftSymbol&&"string"==typeof nftSymbol&&void 0!==edition&&"number"==typeof edition&&Number.isInteger(edition)&&edition>=0&&void 0!==numRolls&&"number"==typeof numRolls&&Number.isInteger(numRolls)&&numRolls>=1&&numRolls<=10&&isValidPartition(foilChance)&&isValidPartition(categoryChance)&&isValidPartition(rarityChance)&&isValidPartition(teamChance)&&void 0!==cardsPerPack&&"number"==typeof cardsPerPack&&Number.isInteger(cardsPerPack)&&cardsPerPack>=1&&cardsPerPack<=30,"invalid params")){const params=await api.db.findOne("params",{}),hasEnoughBalance=await verifyTokenBalance(params.registerFee,"BEE",api.sender);if(api.assert(hasEnoughBalance,"you must have enough tokens to cover the registration fee")){const packToken=await api.db.findOneInTable("tokens","tokens",{symbol:packSymbol});if(api.assert(null!==packToken,"pack symbol must exist")){const underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==underManagement,"NFT not under management")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:nftSymbol});if(api.assert(null!==nft,"NFT symbol must exist")&&api.assert(nft.issuer===api.sender,"not authorized to register")){const settings=await api.db.findOne("packs",{symbol:packSymbol,nft:nftSymbol});if(api.assert(null===settings,`pack already registered for ${nftSymbol}`)){if(!api.assert(edition.toString()in underManagement.editionMapping||editionName&&!(edition.toString()in underManagement.editionMapping),"must provide a name for the new edition"))return!1;if(!await transferFee(params.registerFee,"null",isSignedWithActiveKey))return!1;const newSettings={account:api.sender,symbol:packSymbol,nft:nftSymbol,edition:edition,cardsPerPack:cardsPerPack,foilChance:foilChance,categoryChance:categoryChance,rarityChance:rarityChance,teamChance:teamChance,numRolls:numRolls,isFinalized:!1};if(!(edition.toString()in underManagement.editionMapping)){const newMapping={nextTypeId:0,editionName:editionName,categoryRO:!1,rarityRO:!1,teamRO:!1,nameRO:!1};underManagement.editionMapping[edition.toString()]=newMapping,await api.db.update("managedNfts",underManagement)}return await api.db.insert("packs",newSettings),api.emit("registerPack",{account:api.sender,symbol:packSymbol,nft:nftSymbol}),!0}}}}}}return!1},actions.createNft=async payload=>{const{name:name,orgName:orgName,productName:productName,symbol:symbol,url:url,isFoilReadOnly:isFoilReadOnly,isTypeReadOnly:isTypeReadOnly,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&(void 0===isFoilReadOnly||"boolean"==typeof isFoilReadOnly)&&(void 0===isTypeReadOnly||"boolean"==typeof isTypeReadOnly),"invalid params")){const nftParams=await api.db.findOneInTable("nft","params",{}),{nftCreationFee:nftCreationFee}=nftParams,hasEnoughBalance=await verifyTokenBalance(nftCreationFee,"BEE",api.sender);if(api.assert(hasEnoughBalance,"you must have enough tokens to cover the NFT creation")){let nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(api.assert(null===nft,"symbol already exists")&&(await api.executeSmartContract("nft","create",{name:name,symbol:symbol,orgName:orgName,productName:productName,url:url,authorizedIssuingAccounts:[],authorizedIssuingContracts:["packmanager"],isSignedWithActiveKey:isSignedWithActiveKey}),nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol}),api.assert(null!==nft,"error creating NFT"))){const finalIsFoilReadOnly=void 0===isFoilReadOnly||isFoilReadOnly,finalIsTypeReadOnly=void 0===isTypeReadOnly||isTypeReadOnly;await api.executeSmartContract("nft","addProperty",{symbol:symbol,name:"edition",type:"number",isReadOnly:!0,authorizedEditingAccounts:[],authorizedEditingContracts:["packmanager"],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:symbol,name:"foil",type:"number",isReadOnly:finalIsFoilReadOnly,authorizedEditingContracts:["packmanager"],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:symbol,name:"type",type:"number",isReadOnly:finalIsTypeReadOnly,authorizedEditingContracts:["packmanager"],isSignedWithActiveKey:isSignedWithActiveKey}),nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});const propertyCount=Object.keys(nft.properties).length;if(api.assert(3===propertyCount,"NFT created but error adding data properties")){await api.executeSmartContract("nft","setGroupBy",{symbol:symbol,properties:["edition","foil","type"],isSignedWithActiveKey:isSignedWithActiveKey});const newRecord={nft:symbol,feePool:"0",editionMapping:{}};await api.db.insert("managedNfts",newRecord),nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});const groupByCount=nft.groupBy.length;api.assert(3===groupByCount,"NFT created with data properties, but error setting groupBy")&&api.emit("createNft",{symbol:symbol})}}}}};const generateRandomInstance=(settings,nftSymbol,to,types)=>{const foil=doRandomRoll(settings.foilChance);let candidateTypes=[],rollCount=0;for(;0===candidateTypes.length&&rollCount<settings.numRolls;){const category=doRandomRoll(settings.categoryChance),rarity=doRandomRoll(settings.rarityChance),team=doRandomRoll(settings.teamChance);candidateTypes=types.filter(t=>t.category===category&&t.rarity===rarity&&t.team===team),rollCount+=1}const type=candidateTypes.length>0?candidateTypes[Math.floor(api.random()*candidateTypes.length)].typeId:0;return{symbol:nftSymbol,fromType:"contract",to:to,feeSymbol:"BEE",properties:{edition:settings.edition,foil:foil,type:type}}};actions.open=async payload=>{const{packSymbol:packSymbol,nftSymbol:nftSymbol,packs:packs,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(packSymbol&&"string"==typeof packSymbol&&nftSymbol&&"string"==typeof nftSymbol&&void 0!==packs&&"number"==typeof packs&&Number.isInteger(packs)&&packs>=1&&packs<=999,"invalid params")){const settings=await api.db.findOne("packs",{symbol:packSymbol,nft:nftSymbol});if(api.assert(null!==settings,"pack does not open this NFT")){const hasEnoughPacks=await verifyTokenBalance(packs,packSymbol,api.sender);if(api.assert(hasEnoughPacks,"you must have enough packs")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:nftSymbol}),underManagement=await api.db.findOne("managedNfts",{nft:nftSymbol});if(api.assert(null!==nft,"NFT symbol must exist")&&api.assert(null!==underManagement,"NFT not under management")){const numNfts=packs*settings.cardsPerPack;if(!api.assert(numNfts<=60,"unable to open that many packs at once"))return!1;const nftParams=await api.db.findOneInTable("nft","params",{}),{nftIssuanceFee:nftIssuanceFee}=nftParams,propertyCount=Object.keys(nft.properties).length,totalIssuanceFee=api.BigNumber(nftIssuanceFee.BEE).multipliedBy(propertyCount+1).multipliedBy(numNfts),canAffordIssuance=api.BigNumber(underManagement.feePool).gte(totalIssuanceFee);if(api.assert(canAffordIssuance,"contract cannot afford issuance")){const types=await api.db.find("types",{nft:nftSymbol,edition:settings.edition},0,0,[{index:"typeId",descending:!1},{index:"_id",descending:!1}]);if(!api.assert(types.length>=1,"NFT must have at least 1 instance type"))return!1;let res=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:packSymbol,quantity:packs.toString(),isSignedWithActiveKey:isSignedWithActiveKey});if(!api.assert(isTokenTransferVerified(res,api.sender,"null",packSymbol,packs.toString(),"transfer"),"unable to transfer pack tokens"))return!1;let issueCounter=0,verifiedCount=0,instances=[];for(;issueCounter<numNfts;)instances.push(generateRandomInstance(settings,nftSymbol,api.sender,types)),issueCounter+=1,10===instances.length&&(res=await api.executeSmartContract("nft","issueMultiple",{instances:instances,isSignedWithActiveKey:isSignedWithActiveKey}),verifiedCount+=countNftIssuance(res,"packmanager",api.sender,nftSymbol),instances=[]);return instances.length>0&&(res=await api.executeSmartContract("nft","issueMultiple",{instances:instances,isSignedWithActiveKey:isSignedWithActiveKey}),verifiedCount+=countNftIssuance(res,"packmanager",api.sender,nftSymbol)),underManagement.feePool=calculateBalance(underManagement.feePool,totalIssuanceFee,8,!1),await api.db.update("managedNfts",underManagement),!!api.assert(verifiedCount===numNfts,`unable to issue all NFT instances; ${verifiedCount} of ${numNfts} issued`)}}}}}return!1};