const CONTRACT_NAME="nftairdrops",UTILITY_TOKEN_SYMBOL="BEE",UTILITY_TOKEN_PRECISION=8,ALLOWED_TO_TYPES=["user","contract"],ALLOWED_FROM_TYPES=["user","contract"],isValidAccountName=(name,accountType)=>!!ALLOWED_TO_TYPES.includes(accountType)&&("contract"===accountType?api.validator.isAlphanumeric(name)&&name.length>=3&&name.length<=50:api.isValidAccountName(name)),arrayHasDuplicates=arr=>new Set(arr).size!==arr.length,tokenTransferVerified=({transaction:transaction,from:from,fromType:fromType,to:to,toType:toType,quantity:quantity})=>{const{errors:errors,events:events}=transaction;let eventType="transfer";return"contract"===fromType?eventType="transferFromContract":"contract"===toType&&(eventType="transferToContract"),!(void 0!==errors||!events||void 0===events.find(el=>"tokens"===el.contract&&el.event===eventType&&"BEE"===el.data.symbol&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)))},nftTransferVerified=async({symbol:symbol,to:to,toType:toType,ids:ids})=>{const newOwnedBy="contract"===toType?"c":"u";return null===await api.db.findOneInTable("nft",symbol+"instances",{_id:{$in:ids.map(x=>api.BigNumber(x).toNumber())},$or:[{account:{$ne:to}},{ownedBy:{$ne:newOwnedBy}}]})},burnFee=async({from:from,fromType:fromType,quantity:quantity})=>{if(api.BigNumber(quantity).eq(0))return!0;let transaction=null;return transaction="contract"===fromType?await api.transferTokensFromCallingContract("null","BEE",quantity,"user"):await api.executeSmartContract("tokens","transfer",{from:from,to:"null",symbol:"BEE",quantity:quantity}),tokenTransferVerified({transaction:transaction,from:from,fromType:fromType,to:"null",toType:"user",quantity:quantity})},reserveNFTs=async({fromType:fromType,symbol:symbol,ids:ids,batchSize:batchSize})=>{for(let i=0,n=ids.length;i<n;i+=batchSize){if(void 0!==(await api.executeSmartContract("nft","transfer",{fromType:fromType,to:"nftairdrops",toType:"contract",nfts:[{symbol:symbol,ids:ids.slice(i,i+batchSize)}],isSignedWithActiveKey:!0})).errors)return!1}return nftTransferVerified({symbol:symbol,to:"nftairdrops",toType:"contract",ids:ids})},reimburseNFTs=async({to:to,toType:toType,symbol:symbol,ids:ids,batchSize:batchSize})=>{const reservedNfts=[];for(let i=0,n=ids.length;i<n;i+=1e3){const nftsInContract=await api.db.findInTable("nft",symbol+"instances",{_id:{$in:ids.map(x=>api.BigNumber(x).toNumber())},account:"nftairdrops",ownedBy:"c"},1e3,i,[{index:"_id",descending:!1}]);reservedNfts.push(...nftsInContract.map(x=>api.BigNumber(x._id).toString()))}for(let i=0,n=reservedNfts.length;i<n;i+=batchSize)await api.executeSmartContract("nft","transfer",{fromType:"contract",to:to,toType:toType,nfts:[{symbol:symbol,ids:reservedNfts.slice(i,i+batchSize)}],isSignedWithActiveKey:!0});return nftTransferVerified({symbol:symbol,to:to,toType:toType,ids:reservedNfts})},parseAndValidateAirdrop=async({symbol:symbol,sender:sender,senderType:senderType,list:list,startBlockNumber:startBlockNumber,softFail:softFail=!0,params:params})=>{const instanceTableName=symbol+"instances",airdrop={isValid:!1,softFail:!1!==softFail,blockNumber:startBlockNumber||api.blockNumber+1,airdropId:api.transactionId,symbol:symbol,from:sender,fromType:senderType,list:list,nftIds:[],totalFee:null};if(api.assert(params.enabledFromTypes.includes(senderType),"invalid fromType")&&api.assert("string"==typeof symbol&&api.validator.isAlpha(symbol)&&api.validator.isUppercase(symbol)&&symbol.length>0&&null!==await api.db.findOneInTable("nft","nfts",{symbol:symbol}),"invalid symbol")&&api.assert(Array.isArray(list)&&list.length>0&&api.assert(list.length<=params.maxTransactionsPerAirdrop,"exceeded airdrop transactions limit")&&list.every((element,index)=>{if("object"==typeof element){const{to:to,ids:ids}=element,toType=element.toType||"user";if(api.assert(isValidAccountName(to,toType),`invalid account ${to} at index ${index}`)&&api.assert(Array.isArray(ids)&&ids.length>0&&ids.length<=params.maxTransactionsPerAccount&&ids.every(i=>"string"==typeof i&&api.BigNumber(i).gt(0)),`invalid nft ids array for account ${to} at index ${index}`)&&api.assert(airdrop.nftIds.length<params.maxTransactionsPerAirdrop,"exceeded airdrop transactions limit"))return airdrop.nftIds.push(...ids),!0}return!1}),"invalid list")&&api.assert(!arrayHasDuplicates(airdrop.nftIds),"airdrop list contains duplicate nfts")){const ownedByType="contract"===senderType?"c":"u",result=await api.db.findOneInTable("nft",instanceTableName,{_id:{$in:airdrop.nftIds.map(x=>api.BigNumber(x).toNumber())},$or:[{account:{$ne:sender}},{ownedBy:{$ne:ownedByType}},{delegatedTo:{$exists:!0}},{soulBound:!0}]});api.assert(null===result,"cannot airdrop nfts that are delegated or not owned by this account or soulBound")&&api.assert(Number.isInteger(airdrop.blockNumber)&&airdrop.blockNumber>api.blockNumber,"invalid startBlockNumber")&&(airdrop.totalFee=api.BigNumber(params.feePerTransaction).times(airdrop.nftIds.length).toFixed(8),airdrop.isValid=!0)}return airdrop},processAirdrop=async(airdrop,batchSize)=>{const{softFail:softFail,symbol:symbol,list:list,nftIds:nftIds}=airdrop,processed=[],failed=[];for(let i=list.length-1;i>=0;i-=1){const{to:to,toType:toType,ids:ids}=list.pop(),batch=ids.splice(0,batchSize-processed.length);if(ids.length>0&&list.push({to:to,toType:toType,ids:ids}),batch.length>0){const transfer=await api.executeSmartContract("nft","transfer",{fromType:"contract",to:to,toType:toType,nfts:[{symbol:symbol,ids:batch}],isSignedWithActiveKey:!0});if(void 0!==transfer.errors){const success=transfer.events?transfer.events.map(x=>x.data.id):[];failed.push(...batch.filter(x=>!success.includes(x)))}if(failed.length>0&&!0!==softFail){airdrop.isValid=!1;break}}if(processed.push(...batch)>=batchSize)break}return 0===list.length&&(airdrop.isValid=!1),nftIds.splice(0,nftIds.length,...nftIds.filter(x=>failed.includes(x)||!processed.includes(x))),processed.length};actions.createSSC=async()=>{if(!1===await api.db.tableExists("pendingAirdrops")){await api.db.createTable("pendingAirdrops",["airdropId","symbol"]),await api.db.createTable("params");const params={feePerTransaction:"0.1",maxTransactionsPerAirdrop:1e4,maxTransactionsPerAccount:50,maxTransactionsPerBlock:500,maxAirdropsPerBlock:1,processingBatchSize:50,enabledFromTypes:["user"]};await api.db.insert("params",params)}},actions.updateParams=async payload=>{if(api.assert(api.sender===api.owner,"not authorized")){const{feePerTransaction:feePerTransaction,maxTransactionsPerAirdrop:maxTransactionsPerAirdrop,maxTransactionsPerAccount:maxTransactionsPerAccount,maxTransactionsPerBlock:maxTransactionsPerBlock,maxAirdropsPerBlock:maxAirdropsPerBlock,processingBatchSize:processingBatchSize,enabledFromTypes:enabledFromTypes}=payload,params=await api.db.findOne("params",{});void 0!==feePerTransaction&&api.assert("string"==typeof feePerTransaction&&!api.BigNumber(feePerTransaction).isNaN()&&api.BigNumber(feePerTransaction).gte(0),"invalid feePerTransaction")&&(params.feePerTransaction=feePerTransaction),void 0!==maxTransactionsPerAirdrop&&api.assert(Number.isInteger(maxTransactionsPerAirdrop)&&maxTransactionsPerAirdrop>0,"invalid maxTransactionsPerAirdrop")&&(params.maxTransactionsPerAirdrop=maxTransactionsPerAirdrop),void 0!==maxTransactionsPerAccount&&api.assert(Number.isInteger(maxTransactionsPerAccount)&&maxTransactionsPerAccount>0&&maxTransactionsPerAccount<=params.maxTransactionsPerAirdrop,"invalid maxTransactionsPerAccount")&&(params.maxTransactionsPerAccount=maxTransactionsPerAccount),void 0!==maxTransactionsPerBlock&&api.assert(Number.isInteger(maxTransactionsPerBlock)&&maxTransactionsPerBlock>0,"invalid maxTransactionsPerBlock")&&(params.maxTransactionsPerBlock=maxTransactionsPerBlock),void 0!==maxAirdropsPerBlock&&api.assert(Number.isInteger(maxAirdropsPerBlock)&&maxAirdropsPerBlock>0,"invalid maxAirdropsPerBlock")&&(params.maxAirdropsPerBlock=maxAirdropsPerBlock),void 0!==processingBatchSize&&api.assert(Number.isInteger(processingBatchSize)&&processingBatchSize>0,"invalid processingBatchSize")&&(params.processingBatchSize=processingBatchSize),void 0!==enabledFromTypes&&api.assert(Array.isArray(enabledFromTypes)&&enabledFromTypes.length>0&&enabledFromTypes.every(x=>ALLOWED_FROM_TYPES.includes(x)),"invalid enabledFromTypes")&&(params.enabledFromTypes=Array.from(new Set(enabledFromTypes))),await api.db.update("params",params),delete params._id,api.emit("paramsUpdated",params)}},actions.newAirdrop=async payload=>{const{symbol:symbol,list:list,startBlockNumber:startBlockNumber,softFail:softFail,fromType:fromType,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")){const senderType=void 0===callingContractInfo||"contract"!==fromType?"user":"contract",sender="user"===senderType?api.sender:callingContractInfo.name,params=await api.db.findOne("params",{}),airdrop=await parseAndValidateAirdrop({symbol:symbol,sender:sender,senderType:senderType,list:list,startBlockNumber:startBlockNumber,softFail:softFail,params:params});if(airdrop.isValid){const tokensTable="contract"===senderType?"contractsBalances":"balances",utilityToken=await api.db.findOneInTable("tokens",tokensTable,{account:sender,symbol:"BEE"});if(api.assert(utilityToken&&api.BigNumber(utilityToken.balance).gte(airdrop.totalFee),"you must have enough tokens to cover the airdrop fee")&&api.assert(await burnFee({from:sender,fromType:senderType,quantity:airdrop.totalFee}),"could not secure airdrop fee")){if(api.assert(await reserveNFTs({fromType:senderType,symbol:symbol,ids:airdrop.nftIds,batchSize:params.processingBatchSize}),"could not secure NFTs"))return await api.db.insert("pendingAirdrops",airdrop),api.emit("newNftAirdrop",{airdropId:airdrop.airdropId,sender:sender,senderType:senderType,symbol:symbol,startBlockNumber:airdrop.blockNumber}),!0;await reimburseNFTs({to:sender,toType:senderType,symbol:symbol,ids:airdrop.nftIds,batchSize:params.processingBatchSize})}}}return!1},actions.tick=async()=>{if(api.assert("null"===api.sender,`not authorized: ${api.sender}`)){const params=await api.db.findOne("params",{}),pendingAirdrops=await api.db.find("pendingAirdrops",{blockNumber:{$lte:api.blockNumber}},params.maxAirdropsPerBlock,0,[{index:"_id",descending:!1}]);if(pendingAirdrops.length>0){const batchSize=Math.floor(params.maxTransactionsPerBlock/pendingAirdrops.length);for(let i=0,n=pendingAirdrops.length;i<n;i+=1){const airdrop=pendingAirdrops[i],nftsProcessed=await processAirdrop(airdrop,batchSize);api.emit("nftAirdropDistribution",{airdropId:airdrop.airdropId,symbol:airdrop.symbol,transactionCount:nftsProcessed}),!0===airdrop.isValid?await api.db.update("pendingAirdrops",airdrop):(await api.db.remove("pendingAirdrops",airdrop),await reimburseNFTs({to:airdrop.from,toType:airdrop.fromType,symbol:airdrop.symbol,ids:airdrop.nftIds,batchSize:params.processingBatchSize}),!1===airdrop.softFail&&airdrop.nftIds.length>0?api.emit("nftAirdropFailed",{airdropId:airdrop.airdropId,symbol:airdrop.symbol}):api.emit("nftAirdropFinished",{airdropId:airdrop.airdropId,symbol:airdrop.symbol}))}}}};