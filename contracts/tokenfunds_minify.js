const FeeMethod=["burn","issuer"],PayoutType=["user","contract"];function validateTokens(payTokenObj,voteTokenObj){return!!api.assert(payTokenObj&&(payTokenObj.issuer===api.sender||"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"===payTokenObj.symbol&&api.sender===api.owner),"must be issuer of payToken")&&!!api.assert(voteTokenObj&&voteTokenObj.stakingEnabled,"voteToken must have staking enabled")}function validateDateTime(str){if(24===str.length){for(let i=0;i<str.length&&1===[5,8,11,14,17,21].indexOf(i);i+=1){const code=str.charCodeAt(i);if(!(code>47&&code<58))return!1}return!0}return!1}function validateDateRange(startDate,endDate,maxDays){if(!api.assert(validateDateTime(startDate)&&validateDateTime(endDate),"invalid datetime format: YYYY-MM-DDThh:mm:ss.sssZ"))return!1;const now=new Date(`${api.hiveBlockTimestamp}.000Z`),start=new Date(startDate),end=new Date(endDate);if(!api.assert(api.BigNumber(start.getTime()).lt(api.BigNumber(end.getTime()).minus(864e5)),"dates must be at least 1 day apart")||!api.assert(api.BigNumber(start.getTime()).gt(api.BigNumber(now.getTime()).plus(864e5)),"startDate must be at least 1 day in the future"))return!1;const rangeDays=api.BigNumber(start.getTime()).minus(end.getTime()).abs().dividedBy(864e5).toFixed(0,api.BigNumber.ROUND_CEIL);return!!api.assert(api.BigNumber(rangeDays).lte(maxDays),"date range exceeds DTF maxDays")}function validateDateChange(proposal,newDate,maxDays){if(!api.assert(validateDateTime(newDate),"invalid datetime format: YYYY-MM-DDThh:mm:ss.sssZ"))return!1;const start=new Date(proposal.startDate),cur=new Date(proposal.endDate),repl=new Date(newDate);if(!api.assert(api.BigNumber(start.getTime()).lt(api.BigNumber(repl.getTime()).minus(864e5)),"dates must be at least 1 day apart"))return!1;if(!api.assert(repl<=cur,"date can only be reduced"))return!1;const rangeDays=api.BigNumber(start.getTime()).minus(repl.getTime()).abs().dividedBy(864e5).toFixed(0,api.BigNumber.ROUND_CEIL);return!!api.assert(api.BigNumber(rangeDays).lte(maxDays),"date range exceeds DTF maxDays")}function validatePending(proposal){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`);return new Date(proposal.endDate)>=blockDate}async function updateProposalWeight(id,deltaApprovalWeight,deltaToken=null){const proposal=await api.db.findOne("proposals",{_id:id});if(proposal&&validatePending(proposal)){if(deltaToken){if((await api.db.findOne("funds",{id:proposal.fundId})).voteToken!==deltaToken.symbol)return!0}return proposal.approvalWeight={$numberDecimal:api.BigNumber(proposal.approvalWeight.$numberDecimal).plus(deltaApprovalWeight)},await api.db.update("proposals",proposal),!0}return!1}async function checkPendingProposals(dtf,params){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),payTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:dtf.payToken}),tickPayRatio=api.BigNumber(params.dtfTickHours).dividedBy(24),funded=[],fundedLog=[];let proposals,offset=0,runningPay=api.BigNumber(dtf.maxAmountPerDay).times(tickPayRatio);for(;runningPay.gt(0);){proposals=await api.db.find("proposals",{fundId:dtf.id,active:!0,approvalWeight:{$gt:{$numberDecimal:api.BigNumber(dtf.voteThreshold)}},startDate:{$lte:blockDate.toISOString()},endDate:{$gte:blockDate.toISOString()}},params.processQueryLimit,offset,[{index:"byApprovalWeight",descending:!0},{index:"_id",descending:!1}]);for(let i=0;i<proposals.length;i+=1){if(api.BigNumber(proposals[i].amountPerDay).times(tickPayRatio).gte(runningPay)){proposals[i].tickPay=runningPay.toFixed(payTokenObj.precision,api.BigNumber.ROUND_DOWN),funded.push(proposals[i]),runningPay=api.BigNumber(0);break}proposals[i].tickPay=api.BigNumber(proposals[i].amountPerDay).times(tickPayRatio).toFixed(payTokenObj.precision,api.BigNumber.ROUND_DOWN),funded.push(proposals[i]),runningPay=runningPay.minus(proposals[i].tickPay)}if(proposals.length<params.processQueryLimit)break;offset+=params.processQueryLimit}for(let i=0;i<funded.length;i+=1){const fund=funded[i];fundedLog.push({id:fund._id,tickPay:fund.tickPay}),"user"===fund.payout.type?await api.executeSmartContract("tokens","issue",{to:fund.payout.name,symbol:payTokenObj.symbol,quantity:fund.tickPay}):"contract"===fund.payout.type&&(await api.executeSmartContract("tokens","issueToContract",{to:fund.payout.name,symbol:payTokenObj.symbol,quantity:fund.tickPay}),await api.executeSmartContract(fund.payout.name,"receiveDtfTokens",{data:fund.payout.contractPayload,symbol:payTokenObj.symbol,quantity:fund.tickPay}))}dtf.lastTickTime=api.BigNumber(blockDate.getTime()).toNumber(),await api.db.update("funds",dtf),api.emit("fundProposals",{fundId:dtf.id,funded:fundedLog})}actions.createSSC=async()=>{if(!1===await api.db.tableExists("funds")){await api.db.createTable("funds",["id","lastTickTime"]),await api.db.createTable("proposals",["fundId",{name:"byApprovalWeight",index:{fundId:1,approvalWeight:1}}]),await api.db.createTable("approvals",["from","to"]),await api.db.createTable("accounts",[],{primaryKey:["account"]}),await api.db.createTable("params");const params={dtfCreationFee:"1000",dtfUpdateFee:"300",dtfTickHours:"24",maxDtfsPerBlock:40,maxAccountApprovals:50,processQueryLimit:1e3};await api.db.insert("params",params)}else{const params=await api.db.findOne("params",{});if(!params.updateIndex){const dtfs=await api.db.find("funds",{}),voteTokens=new Set;for(let i=0;i<dtfs.length;i+=1)voteTokens.add(dtfs[i].voteToken);const resetAccounts=await api.db.find("accounts",{});for(let i=0;i<resetAccounts.length;i+=1){const acct=resetAccounts[i];acct.weights=acct.weights.filter(ele=>voteTokens.has(ele.symbol)),await api.db.update("accounts",acct)}const resetProposals=await api.db.find("proposals",{});for(let i=0;i<resetProposals.length;i+=1){const prop=resetProposals[i],propFund=dtfs.find(x=>x.id===prop.fundId),propApprovals=await api.db.find("approvals",{to:prop._id});let newApprovalWeight=api.BigNumber("0");for(let j=0;j<propApprovals.length;j+=1){const approval=propApprovals[j],approvalAcctWgt=resetAccounts.find(x=>x.account===approval.from).weights.find(x=>x.symbol===propFund.voteToken);newApprovalWeight=newApprovalWeight.plus(approvalAcctWgt.weight)}prop.approvalWeight={$numberDecimal:newApprovalWeight},await api.db.update("proposals",prop)}params.updateIndex=1,await api.db.update("params",params)}}},actions.updateParams=async payload=>{const{dtfCreationFee:dtfCreationFee,dtfUpdateFee:dtfUpdateFee,dtfTickHours:dtfTickHours,maxDtfsPerBlock:maxDtfsPerBlock,maxAccountApprovals:maxAccountApprovals,processQueryLimit:processQueryLimit}=payload;if(api.sender!==api.owner)return;const params=await api.db.findOne("params",{});if(dtfCreationFee){if(!api.assert("string"==typeof dtfCreationFee&&!api.BigNumber(dtfCreationFee).isNaN()&&api.BigNumber(dtfCreationFee).gte(0),"invalid dtfCreationFee"))return;params.dtfCreationFee=dtfCreationFee}if(dtfUpdateFee){if(!api.assert("string"==typeof dtfUpdateFee&&!api.BigNumber(dtfUpdateFee).isNaN()&&api.BigNumber(dtfUpdateFee).gte(0),"invalid dtfUpdateFee"))return;params.dtfUpdateFee=dtfUpdateFee}if(dtfTickHours){if(!api.assert("string"==typeof dtfTickHours&&api.BigNumber(dtfTickHours).isInteger()&&api.BigNumber(dtfTickHours).gte(1),"invalid dtfTickHours"))return;params.dtfTickHours=dtfTickHours}if(maxDtfsPerBlock){if(!api.assert("string"==typeof maxDtfsPerBlock&&api.BigNumber(maxDtfsPerBlock).isInteger()&&api.BigNumber(maxDtfsPerBlock).gte(1),"invalid maxDtfsPerBlock"))return;params.maxDtfsPerBlock=api.BigNumber(maxDtfsPerBlock).toNumber()}if(maxAccountApprovals){if(!api.assert("string"==typeof maxAccountApprovals&&api.BigNumber(maxAccountApprovals).isInteger()&&api.BigNumber(maxAccountApprovals).gte(1),"invalid maxDtfsPerBlock"))return;params.maxAccountApprovals=api.BigNumber(maxAccountApprovals).toNumber()}if(processQueryLimit){if(!api.assert("string"==typeof processQueryLimit&&api.BigNumber(processQueryLimit).isInteger()&&api.BigNumber(processQueryLimit).gte(1),"invalid processQueryLimit"))return;params.processQueryLimit=api.BigNumber(processQueryLimit).toNumber()}await api.db.update("params",params)},actions.createFund=async payload=>{const{payToken:payToken,voteToken:voteToken,voteThreshold:voteThreshold,maxDays:maxDays,maxAmountPerDay:maxAmountPerDay,proposalFee:proposalFee,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{dtfCreationFee:dtfCreationFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!api.BigNumber(dtfCreationFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(dtfCreationFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fee")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert("string"==typeof voteThreshold&&api.BigNumber(voteThreshold).gt(0),"invalid voteThreshold: greater than 0")&&api.assert("string"==typeof maxDays&&api.BigNumber(maxDays).isInteger()&&api.BigNumber(maxDays).gt(0)&&api.BigNumber(maxDays).lte(730),"invalid maxDays: integer between 1 and 730")&&api.assert("string"==typeof maxAmountPerDay&&api.BigNumber(maxAmountPerDay).gt(0),"invalid maxAmountPerDay: greater than 0")){if(proposalFee){if(!api.assert("object"==typeof proposalFee&&"string"==typeof proposalFee.method&&-1!==FeeMethod.indexOf(proposalFee.method)&&"string"==typeof proposalFee.symbol&&"string"==typeof proposalFee.amount&&api.BigNumber(proposalFee.amount).gt(0),"invalid proposalFee"))return;const feeTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:proposalFee.symbol});if(!api.assert(feeTokenObj&&api.BigNumber(proposalFee.amount).dp()<=feeTokenObj.precision,"invalid proposalFee token or precision"))return}const payTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:payToken}),voteTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:voteToken});if(!validateTokens(payTokenObj,voteTokenObj)||!api.assert(api.BigNumber(maxAmountPerDay).dp()<=payTokenObj.precision,"maxAmountPerDay precision mismatch")||!api.assert(api.BigNumber(voteThreshold).dp()<=voteTokenObj.precision,"voteThreshold precision mismatch"))return;const now=new Date(`${api.hiveBlockTimestamp}.000Z`),newDtf={payToken:payToken,voteToken:voteToken,voteThreshold:voteThreshold,maxDays:maxDays,maxAmountPerDay:maxAmountPerDay,proposalFee:proposalFee,active:!1,creator:api.sender,lastTickTime:now.getTime()};newDtf.id=`${payToken}:${voteToken}`;const existingDtf=await api.db.findOne("funds",{id:newDtf.id});if(!api.assert(!existingDtf,"DTF already exists"))return;const insertedDtf=await api.db.insert("funds",newDtf);api.sender!==api.owner&&"null"!==api.sender&&api.BigNumber(dtfCreationFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:dtfCreationFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("createFund",{id:insertedDtf.id})}},actions.updateFund=async payload=>{const{fundId:fundId,voteThreshold:voteThreshold,maxDays:maxDays,maxAmountPerDay:maxAmountPerDay,proposalFee:proposalFee,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{dtfUpdateFee:dtfUpdateFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedUpdate=!(!api.BigNumber(dtfUpdateFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(dtfUpdateFee);if(api.assert(authorizedUpdate,"you must have enough tokens to cover the update fee")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert("string"==typeof voteThreshold&&api.BigNumber(voteThreshold).gt(0),"invalid voteThreshold: greater than 0")&&api.assert("string"==typeof maxDays&&api.BigNumber(maxDays).isInteger()&&api.BigNumber(maxDays).gt(0)&&api.BigNumber(maxDays).lte(730),"invalid maxDays: integer between 1 and 730")&&api.assert("string"==typeof maxAmountPerDay&&api.BigNumber(maxAmountPerDay).gt(0),"invalid maxAmountPerDay: greater than 0")){if(proposalFee){if(!api.assert("object"==typeof proposalFee&&"string"==typeof proposalFee.method&&-1!==FeeMethod.indexOf(proposalFee.method)&&"string"==typeof proposalFee.symbol&&"string"==typeof proposalFee.amount&&api.BigNumber(proposalFee.amount).gt(0),"invalid proposalFee"))return;const feeTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:proposalFee.symbol});if(!api.assert(feeTokenObj&&api.BigNumber(proposalFee.amount).dp()<=feeTokenObj.precision,"invalid proposalFee token or precision"))return}const existingDtf=await api.db.findOne("funds",{id:fundId});if(!api.assert(existingDtf,"DTF not found")||!api.assert(existingDtf.creator===api.sender||api.owner===api.sender,"must be DTF creator"))return;const payTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:existingDtf.payToken}),voteTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:existingDtf.voteToken});if(!api.assert(api.BigNumber(maxAmountPerDay).dp()<=payTokenObj.precision,"maxAmountPerDay precision mismatch")||!api.assert(api.BigNumber(voteThreshold).dp()<=voteTokenObj.precision,"voteThreshold precision mismatch"))return;existingDtf.voteThreshold=voteThreshold,existingDtf.maxDays=maxDays,existingDtf.maxAmountPerDay=maxAmountPerDay,proposalFee&&(existingDtf.proposalFee=proposalFee),await api.db.update("funds",existingDtf),api.sender!==api.owner&&"null"!==api.sender&&api.BigNumber(dtfUpdateFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:dtfUpdateFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("updateFund",{id:fundId})}},actions.setDtfActive=async payload=>{const{fundId:fundId,active:active,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key"))return;const dtf=await api.db.findOne("funds",{id:fundId});api.assert(dtf,"DTF does not exist")&&api.assert(dtf.creator===api.sender||api.owner===api.sender,"must be DTF creator")&&(dtf.active=!!active,await api.db.update("funds",dtf),api.emit("setDtfActive",{id:dtf.id,active:dtf.active}))},actions.createProposal=async payload=>{const{fundId:fundId,title:title,startDate:startDate,endDate:endDate,amountPerDay:amountPerDay,authorPermlink:authorPermlink,payout:payout,isSignedWithActiveKey:isSignedWithActiveKey}=payload,dtf=await api.db.findOne("funds",{id:fundId});if(!api.assert(dtf,"DTF does not exist"))return;let authorizedCreation=!0;if(dtf.proposalFee){const feeTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:dtf.proposalFee.symbol});authorizedCreation=!(!api.BigNumber(dtf.proposalFee.amount).lte(0)&&api.sender!==api.owner)||feeTokenBalance&&api.BigNumber(feeTokenBalance.balance).gte(dtf.proposalFee.amount)}if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fee")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert(!0===dtf.active,"DTF is not active")&&api.assert("string"==typeof title&&title.length>0&&title.length<=80,"invalid title: between 1 and 80 characters")&&api.assert("string"==typeof authorPermlink&&authorPermlink.length>0&&authorPermlink.length<=255,"invalid authorPermlink: between 1 and 255 characters")&&api.assert("string"==typeof amountPerDay&&api.BigNumber(amountPerDay).isInteger()&&api.BigNumber(amountPerDay).gt(0),"invalid amountPerDay: greater than 0")&&api.assert(api.BigNumber(amountPerDay).lte(dtf.maxAmountPerDay),"invalid amountPerDay: exceeds DTF maxAmountPerDay")&&api.assert("object"==typeof payout&&"string"==typeof payout.type&&-1!==PayoutType.indexOf(payout.type)&&("contract"!==payout.type||"object"==typeof payout.contractPayload)&&"string"==typeof payout.name&&payout.name.length>=3&&payout.name.length<=50,"invalid payout settings")&&validateDateRange(startDate,endDate,dtf.maxDays)){const newProposal={fundId:fundId,title:title,startDate:startDate,endDate:endDate,amountPerDay:amountPerDay,authorPermlink:authorPermlink,payout:payout,creator:api.sender,approvalWeight:{$numberDecimal:"0"},active:!0},insertedProposal=await api.db.insert("proposals",newProposal);if(api.sender!==api.owner&&dtf.proposalFee)if("burn"===dtf.proposalFee.method)await api.executeSmartContract("tokens","transfer",{to:"null",symbol:dtf.proposalFee.symbol,quantity:dtf.proposalFee.amount});else if("issuer"===dtf.proposalFee.method){const feeTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:dtf.proposalFee.symbol});await api.executeSmartContract("tokens","transfer",{to:feeTokenObj.issuer,symbol:dtf.proposalFee.symbol,quantity:dtf.proposalFee.amount})}api.emit("createProposal",{id:insertedProposal._id})}},actions.updateProposal=async payload=>{const{id:id,title:title,endDate:endDate,amountPerDay:amountPerDay,authorPermlink:authorPermlink,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert("string"==typeof id&&api.BigNumber(id).isInteger(),"invalid id"))return;const proposal=await api.db.findOne("proposals",{_id:api.BigNumber(id).toNumber()});if(!api.assert(proposal,"proposal does not exist")||!api.assert(proposal.creator===api.sender||api.owner===api.sender,"must be proposal creator"))return;const dtf=await api.db.findOne("funds",{id:proposal.fundId,active:!0});api.assert(dtf,"DTF does not exist or inactive")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert(!0===dtf.active,"DTF is not active")&&api.assert(!0===proposal.active,"proposal is not active")&&api.assert("string"==typeof title&&title.length>0&&title.length<=80,"invalid title: between 1 and 80 characters")&&api.assert("string"==typeof authorPermlink&&authorPermlink.length>0&&authorPermlink.length<=255,"invalid authorPermlink: between 1 and 255 characters")&&api.assert("string"==typeof amountPerDay&&api.BigNumber(amountPerDay).isInteger()&&api.BigNumber(amountPerDay).gt(0)&&api.BigNumber(amountPerDay).lte(proposal.amountPerDay),"invalid amountPerDay: greater than 0 and cannot be increased")&&api.assert(api.BigNumber(amountPerDay).lte(dtf.maxAmountPerDay),"invalid amountPerDay: exceeds DTF maxAmountPerDay")&&validateDateChange(proposal,endDate,dtf.maxDays)&&(proposal.title=title,proposal.endDate=endDate,proposal.amountPerDay=amountPerDay,proposal.authorPermlink=authorPermlink,await api.db.update("proposals",proposal),api.emit("updateProposal",{id:proposal._id}))},actions.disableProposal=async payload=>{const{id:id,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert("string"==typeof id&&api.BigNumber(id).isInteger(),"invalid id"))return;const proposal=await api.db.findOne("proposals",{_id:api.BigNumber(id).toNumber()});api.assert(proposal,"proposal does not exist")&&api.assert(!0===proposal.active,"proposal already disabled")&&api.assert(proposal.creator===api.sender||api.owner===api.sender,"must be proposal creator")&&(proposal.active=!1,await api.db.update("proposals",proposal),api.emit("disableProposal",{id:proposal._id}))},actions.approveProposal=async payload=>{const{id:id}=payload,params=await api.db.findOne("params",{});if(api.assert("string"==typeof id&&api.BigNumber(id).isInteger(),"invalid id")){const proposal=await api.db.findOne("proposals",{_id:api.BigNumber(id).toNumber()});if(api.assert(proposal,"proposal does not exist")&&api.assert(validatePending(proposal),"proposal is not pending")){const dtf=await api.db.findOne("funds",{id:proposal.fundId}),voteTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:dtf.voteToken});let acct=await api.db.findOne("accounts",{account:api.sender});null===acct&&(acct={account:api.sender,weights:[]},acct=await api.db.insert("accounts",acct));let activeApprovals=0;const approvals=await api.db.find("approvals",{from:api.sender,proposalPending:!0},params.maxAccountApprovals,0,[{index:"_id",descending:!0}]);for(let index=0;index<approvals.length;index+=1){const approval=approvals[index],approvalProposal=await api.db.findOne("proposals",{_id:approval.to});approvalProposal&&validatePending(approvalProposal)?activeApprovals+=1:(approval.proposalPending=!1,await api.db.update("approvals",approval))}if(!api.assert(activeApprovals<params.maxAccountApprovals,`you can only approve ${params.maxAccountApprovals} active proposals`))return;let approval=await api.db.findOne("approvals",{from:api.sender,to:proposal._id});if(api.assert(null===approval,"you already approved this proposal")){approval={from:api.sender,to:proposal._id,proposalPending:!0},await api.db.insert("approvals",approval);const balance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:dtf.voteToken});let approvalWeight=0;balance&&balance.stake&&(approvalWeight=balance.stake),balance&&balance.delegationsIn&&(approvalWeight=api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(voteTokenObj.precision,api.BigNumber.ROUND_HALF_UP));const wIndex=acct.weights.findIndex(x=>x.symbol===dtf.voteToken);-1!==wIndex?acct.weights[wIndex].weight=approvalWeight:acct.weights.push({symbol:dtf.voteToken,weight:approvalWeight}),await api.db.update("accounts",acct),await updateProposalWeight(proposal._id,approvalWeight),api.emit("approveProposal",{id:proposal._id})}}}},actions.disapproveProposal=async payload=>{const{id:id}=payload;if(api.assert("string"==typeof id&&api.BigNumber(id).isInteger(),"invalid id")){const proposal=await api.db.findOne("proposals",{_id:api.BigNumber(id).toNumber()});if(api.assert(proposal,"proposal does not exist")&&api.assert(validatePending(proposal),"proposal is not pending")){const dtf=await api.db.findOne("funds",{id:proposal.fundId}),voteTokenObj=await api.db.findOneInTable("tokens","tokens",{symbol:dtf.voteToken});let acct=await api.db.findOne("accounts",{account:api.sender});null===acct&&(acct={account:api.sender,weights:[]},acct=await api.db.insert("accounts",acct));const approval=await api.db.findOne("approvals",{from:api.sender,to:proposal._id});if(api.assert(null!==approval,"you have not approved this proposal")){await api.db.remove("approvals",approval);const balance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:dtf.voteToken});let approvalWeight=0;balance&&balance.stake&&(approvalWeight=balance.stake),balance&&balance.delegationsIn&&(approvalWeight=api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(voteTokenObj.precision,api.BigNumber.ROUND_HALF_UP));const wIndex=acct.weights.findIndex(x=>x.symbol===dtf.voteToken);-1!==wIndex?acct.weights[wIndex].weight=approvalWeight:acct.weights.push({symbol:dtf.voteToken,weight:approvalWeight}),await api.db.update("accounts",acct),await updateProposalWeight(proposal._id,api.BigNumber(approvalWeight).negated()),api.emit("disapproveProposal",{id:proposal._id})}}}},actions.updateProposalApprovals=async payload=>{const{account:account,token:token,callingContractInfo:callingContractInfo}=payload;if(void 0===callingContractInfo)return;if("tokens"!==callingContractInfo.name)return;const acct=await api.db.findOne("accounts",{account:account});if(null!==acct){const params=await api.db.findOne("params",{}),wIndex=acct.weights.findIndex(x=>x.symbol===token.symbol);if(-1!==wIndex){const balance=await api.db.findOneInTable("tokens","balances",{account:account,symbol:token.symbol});let approvalWeight=0;balance&&balance.stake&&(approvalWeight=balance.stake),balance&&balance.delegationsIn&&(approvalWeight=api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(token.precision,api.BigNumber.ROUND_HALF_UP));let oldApprovalWeight=0;oldApprovalWeight=acct.weights[wIndex].weight,acct.weights[wIndex].weight=approvalWeight;const deltaApprovalWeight=api.BigNumber(approvalWeight).minus(oldApprovalWeight).dp(token.precision,api.BigNumber.ROUND_HALF_UP);if(!api.BigNumber(deltaApprovalWeight).eq(0)){await api.db.update("accounts",acct);const approvals=await api.db.find("approvals",{from:account,proposalPending:!0},params.maxAccountApprovals,0,[{index:"_id",descending:!0}]);for(let index=0;index<approvals.length;index+=1){const approval=approvals[index];await updateProposalWeight(approval.to,deltaApprovalWeight,token)||(approval.proposalPending=!1,await api.db.update("approvals",approval))}}}}},actions.checkPendingDtfs=async()=>{if(api.assert("null"===api.sender,"not authorized")){const params=await api.db.findOne("params",{}),blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),tickTime=api.BigNumber(blockDate.getTime()).minus(3600*params.dtfTickHours*1e3).toNumber(),pendingDtfs=await api.db.find("funds",{active:!0,lastTickTime:{$lte:tickTime}},params.maxDtfsPerBlock,0,[{index:"lastTickTime",descending:!1},{index:"_id",descending:!1}]);for(let i=0;i<pendingDtfs.length;i+=1)await checkPendingProposals(pendingDtfs[i],params)}};