const DistStrategy=["fixed","pool"];async function validateMinPayout(tokenMinPayout){if(!api.assert(tokenMinPayout&&Array.isArray(tokenMinPayout),"tokenMinPayout must be an array"))return!1;if(!api.assert(tokenMinPayout.length>=1,"specify at least one minimum payout configuration"))return!1;const tokenMinPayoutSymbols=new Set;for(let i=0;i<tokenMinPayout.length;i+=1){const tokenMinPayoutConfig=tokenMinPayout[i];if(!api.assert(tokenMinPayoutConfig&&tokenMinPayoutConfig.symbol&&"string"==typeof tokenMinPayoutConfig.symbol,"tokenMinPayout invalid"))return!1;if(!api.assert(!tokenMinPayoutSymbols.has(tokenMinPayoutConfig.symbol),"tokenMinPayout cannot have duplicate symbols"))return!1;if(tokenMinPayoutSymbols.add(tokenMinPayoutConfig.symbol),!api.assert(tokenMinPayoutConfig.quantity&&api.BigNumber(tokenMinPayoutConfig.quantity).dp()<=3&&api.BigNumber(tokenMinPayoutConfig.quantity).gte(0),"invalid quantity"))return!1}return!0}async function validateRecipients(params,tokenRecipients){if(!api.assert(tokenRecipients&&Array.isArray(tokenRecipients),"tokenRecipients must be an array"))return!1;if(!api.assert(tokenRecipients.length>=1&&tokenRecipients.length<=params.maxTransferLimit,`1-${params.maxTransferLimit} tokenRecipients are supported`))return!1;const tokenRecipientsAccounts=new Set;let tokenRecipientsTotalShare=0;for(let i=0;i<tokenRecipients.length;i+=1){const tokenRecipientsConfig=tokenRecipients[i];if(!api.assert(tokenRecipientsConfig&&tokenRecipientsConfig.account&&"string"==typeof tokenRecipientsConfig.account,"tokenRecipients invalid")&&!api.assert(tokenRecipientsConfig.account.length>=3&&tokenRecipientsConfig.account.length<=16,"invalid account"))return!1;if(!api.assert(!tokenRecipientsAccounts.has(tokenRecipientsConfig.account),"tokenRecipients cannot have duplicate accounts"))return!1;if(tokenRecipientsAccounts.add(tokenRecipientsConfig.account),!api.assert(Number.isInteger(tokenRecipientsConfig.pct)&&tokenRecipientsConfig.pct>=1&&tokenRecipientsConfig.pct<=100,"tokenRecipients pct must be an integer from 1 to 100"))return!1;if(tokenRecipientsTotalShare+=tokenRecipientsConfig.pct,!api.assert(["user","contract"].includes(tokenRecipientsConfig.type),"tokenRecipients type must be user or contract"))return!1;if("contract"===tokenRecipientsConfig.type&&!api.assert("object"==typeof tokenRecipientsConfig.contractPayload,"contract recipients must have contractPayload"))return!1}return!!api.assert(100===tokenRecipientsTotalShare,"tokenRecipients pct must total 100")}function validateIncomingToken(dist,symbol){for(let i=0;i<dist.tokenMinPayout.length;i+=1)if(dist.tokenMinPayout[i].symbol===symbol)return!0;return!1}function validateBonusCurve(obj){if(!api.assert("object"==typeof obj&&"Object"===obj.constructor.name,"invalid bonusCurve settings"))return!1;if("periodBonusPct"in obj||"numPeriods"in obj){if(!api.assert("string"==typeof obj.periodBonusPct&&api.BigNumber(obj.periodBonusPct).isInteger()&&api.BigNumber(obj.periodBonusPct).gt(0)&&api.BigNumber(obj.periodBonusPct).lt(100)&&"string"==typeof obj.numPeriods&&api.BigNumber(obj.numPeriods).isInteger()&&api.BigNumber(obj.numPeriods).gt(0)&&api.BigNumber(obj.numPeriods).lt(5555),"invalid bonusCurve settings"))return!1}else if(!api.assert(0===Object.keys(obj).length,"invalid bonusCurve settings"))return!1;return!0}async function validatePool(tokenPair){return null!==await api.db.findOneInTable("marketpools","pools",{tokenPair:tokenPair})}async function updateTokenBalances(dist,token,quantity){const upDist=dist;if(upDist.tokenBalances){const tIndex=upDist.tokenBalances.findIndex(t=>t.symbol===token.symbol);-1===tIndex?upDist.tokenBalances.push({symbol:token.symbol,quantity:quantity}):upDist.tokenBalances[tIndex].quantity=api.BigNumber(upDist.tokenBalances[tIndex].quantity).plus(quantity).toFixed(token.precision,api.BigNumber.ROUND_DOWN)}else upDist.tokenBalances=[{symbol:token.symbol,quantity:quantity}];await api.db.update("batches",upDist)}async function getEffectiveShares(params,dist,lp){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),timeDiff=api.BigNumber(blockDate.getTime()).minus(lp.timeFactor);if(timeDiff.lte(3600*params.distTickHours*1e3))return lp.shares;let multiplier=api.BigNumber("1");return"string"==typeof dist.bonusCurve.numPeriods&&(multiplier=timeDiff.lt(params.distTickHours*dist.bonusCurve.numPeriods*3600*1e3)?api.BigNumber(dist.bonusCurve.periodBonusPct).dividedBy("100").times(timeDiff.dividedBy(3600*params.distTickHours*1e3).dp(0,api.BigNumber.ROUND_DOWN)).plus(multiplier):api.BigNumber(dist.bonusCurve.periodBonusPct).dividedBy("100").times(dist.bonusCurve.numPeriods).plus(multiplier)),api.BigNumber(lp.shares).times(multiplier)}async function getPoolRecipients(params,dist){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),minHoldTime=api.BigNumber(blockDate.getTime()).minus(3600*params.distTickHours*1e3).toNumber(),result=[];let offset=0,processQuery=[];const pool=await api.db.findOneInTable("marketpools","pools",{tokenPair:dist.tokenPair});if(!pool||pool.totalShares<=0)return result;for(;null!==processQuery&&processQuery.length===params.processQueryLimit||0===offset;){processQuery=await api.db.findInTable("marketpools","liquidityPositions",{tokenPair:dist.tokenPair,account:{$nin:dist.excludeAccount},timeFactor:{$lte:minHoldTime}},params.processQueryLimit,offset,[{index:"_id",descending:!1}]);for(let i=0;i<processQuery.length;i+=1){const lp=processQuery[i];lp.effShares=await getEffectiveShares(params,dist,lp),result.push(lp)}offset+=params.processQueryLimit}return result}async function payRecipient(account,symbol,quantity,type="user",contractPayload=null){if(api.BigNumber(quantity).gt(0)){const res=await api.transferTokens(account,symbol,quantity,type);return"contract"===type&&contractPayload&&await api.executeSmartContract(account,"receiveDistTokens",{data:contractPayload,symbol:symbol,quantity:quantity}),!res.errors||(api.debug(`Error paying out distribution of ${quantity} ${symbol} to ${account} (TXID ${api.transactionId}): \n${res.errors}`),!1)}return!1}async function runDistribution(dist,params,flush=!1){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),upDist=JSON.parse(JSON.stringify(dist)),payTokens=dist.tokenBalances.filter(d=>api.BigNumber(d.quantity).gt(0));if(payTokens.length>0)if("fixed"===dist.strategy){const{tokenRecipients:tokenRecipients}=dist;for(;tokenRecipients.length>0;){const tr=tokenRecipients.shift();for(let i=0;i<payTokens.length;i+=1){const payToken=await api.db.findOneInTable("tokens","tokens",{symbol:payTokens[i].symbol}),minPayout=dist.tokenMinPayout.find(p=>p.symbol===payTokens[i].symbol);if(api.BigNumber(payTokens[i].quantity).gt(minPayout.quantity)||flush){const payoutShare=api.BigNumber(payTokens[i].quantity).multipliedBy(tr.pct).dividedBy(100).dividedBy(dist.numTicksLeft).toFixed(payToken.precision,api.BigNumber.ROUND_DOWN);if(api.BigNumber(payoutShare).gt(0)&&await payRecipient(tr.account,payTokens[i].symbol,payoutShare,tr.type,tr.contractPayload||null)){const tbIndex=upDist.tokenBalances.findIndex(b=>b.symbol===payTokens[i].symbol);upDist.tokenBalances[tbIndex].quantity=api.BigNumber(upDist.tokenBalances[tbIndex].quantity).minus(payoutShare).toFixed(payToken.precision,api.BigNumber.ROUND_DOWN),api.emit("payment",{distId:dist._id,tokenPair:dist.tokenPair,symbol:payTokens[i].symbol,account:tr.account,quantity:payoutShare})}}}}}else if("pool"===dist.strategy){const tokenRecipients=await getPoolRecipients(params,dist),shareTotal=tokenRecipients.reduce((acc,cur)=>acc.plus(cur.effShares),api.BigNumber(0));if(api.assert(shareTotal.gt(0),"no liquidity shares for this tokenPair")){let payTxCount=0;const storePending=[];for(;tokenRecipients.length>0;){const tr=tokenRecipients.shift(),payoutShare=api.BigNumber(tr.effShares).dividedBy(shareTotal);for(let i=0;i<payTokens.length;i+=1){const payToken=await api.db.findOneInTable("tokens","tokens",{symbol:payTokens[i].symbol}),payoutQty=api.BigNumber(payTokens[i].quantity).multipliedBy(payoutShare).dividedBy(dist.numTicksLeft).toFixed(payToken.precision,api.BigNumber.ROUND_DOWN);if(api.BigNumber(payoutQty).gt(0)){let payResult=!0,payNow=!0;if(payTxCount<params.maxTransferLimit?payResult=await payRecipient(tr.account,payTokens[i].symbol,payoutQty):(payNow=!1,storePending.push({distId:dist._id,account:tr.account,symbol:payTokens[i].symbol,quantity:payoutQty})),payResult){const tbIndex=upDist.tokenBalances.findIndex(b=>b.symbol===payTokens[i].symbol);upDist.tokenBalances[tbIndex].quantity=api.BigNumber(upDist.tokenBalances[tbIndex].quantity).minus(payoutQty).toFixed(payToken.precision,api.BigNumber.ROUND_DOWN),payNow&&api.emit("payment",{distId:dist._id,tokenPair:dist.tokenPair,symbol:payTokens[i].symbol,account:tr.account,quantity:payoutQty})}payTxCount+=1}}}storePending.length>0&&await api.db.insert("pendingPayments",{dueTime:blockDate.getTime(),accounts:storePending})}}upDist.numTicksLeft-=1,upDist.lastTickTime=blockDate.getTime(),await api.db.update("batches",upDist)}async function runPendingPay(pendingPay,params){for(let i=Math.min(params.maxTransferLimit,pendingPay.accounts.length)-1;i>=0;i-=1){const p=pendingPay.accounts[i];await payRecipient(p.account,p.symbol,p.quantity)&&(pendingPay.accounts.splice(i,1),api.emit("payment",{...p,pending:!0}))}0===pendingPay.accounts.length?await api.db.remove("pendingPayments",pendingPay):await api.db.update("pendingPayments",pendingPay)}actions.createSSC=async()=>{if(!1===await api.db.tableExists("batches")){await api.db.createTable("batches"),await api.db.createTable("params");const params={distCreationFee:"500",distUpdateFee:"250"};await api.db.insert("params",params)}else{const params=await api.db.findOne("params",{});if(params.updateIndex){if(1===params.updateIndex){const clearPending=await api.db.find("pendingPayments",{});for(let i=0;i<clearPending.length;i+=1)await api.db.remove("pendingPayments",clearPending[i]);const syncDists=await api.db.find("batches",{});for(let i=0;i<syncDists.length;i+=1){const dist=syncDists[i];if(dist.tokenBalances){let update=!1;const hiveIndex=dist.tokenBalances.findIndex(t=>"SWAP.HIVE"===t.symbol);-1!==hiveIndex&&(dist.tokenBalances[hiveIndex].quantity=api.BigNumber("0").toFixed(8),update=!0);const simIndex=dist.tokenBalances.findIndex(t=>"SIM"===t.symbol);-1!==simIndex&&(dist.tokenBalances[simIndex].quantity=api.BigNumber("0").toFixed(3),update=!0),update&&await api.db.update("batches",dist)}}params.updateIndex=2,await api.db.update("params",params)}}else await api.db.addIndexes("batches",[{name:"lastTickTime",index:{lastTickTime:1}}]),await api.db.createTable("pendingPayments",["dueTime"]),params.distTickHours="24",params.maxDistributionsLimit=1,params.maxTransferLimit=50,params.processQueryLimit=1e3,params.updateIndex=1,await api.db.update("params",params)}},actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{distCreationFee:distCreationFee,distUpdateFee:distUpdateFee,distTickHours:distTickHours,maxDistributionsLimit:maxDistributionsLimit,maxTransferLimit:maxTransferLimit,processQueryLimit:processQueryLimit}=payload,params=await api.db.findOne("params",{});if(distCreationFee){if(!api.assert("string"==typeof distCreationFee&&!api.BigNumber(distCreationFee).isNaN()&&api.BigNumber(distCreationFee).gte(0),"invalid distCreationFee"))return;params.distCreationFee=distCreationFee}if(distUpdateFee){if(!api.assert("string"==typeof distUpdateFee&&!api.BigNumber(distUpdateFee).isNaN()&&api.BigNumber(distUpdateFee).gte(0),"invalid distUpdateFee"))return;params.distUpdateFee=distUpdateFee}if(distTickHours){if(!api.assert("string"==typeof distTickHours&&api.BigNumber(distTickHours).isInteger()&&api.BigNumber(distTickHours).gte(1),"invalid distTickHours"))return;params.distTickHours=distTickHours}if(maxDistributionsLimit){if(!api.assert("string"==typeof maxDistributionsLimit&&api.BigNumber(maxDistributionsLimit).isInteger()&&api.BigNumber(maxDistributionsLimit).gte(1),"invalid maxDistributionsLimit"))return;params.maxDistributionsLimit=api.BigNumber(maxDistributionsLimit).toNumber()}if(maxTransferLimit){if(!api.assert("string"==typeof maxTransferLimit&&api.BigNumber(maxTransferLimit).isInteger()&&api.BigNumber(maxTransferLimit).gte(1),"invalid maxTransferLimit"))return;params.maxTransferLimit=api.BigNumber(maxTransferLimit).toNumber()}if(processQueryLimit){if(!api.assert("string"==typeof processQueryLimit&&api.BigNumber(processQueryLimit).isInteger()&&api.BigNumber(processQueryLimit).gte(1),"invalid processQueryLimit"))return;params.processQueryLimit=api.BigNumber(processQueryLimit).toNumber()}await api.db.update("params",params)},actions.create=async payload=>{const{strategy:strategy,numTicks:numTicks,excludeAccount:excludeAccount,tokenPair:tokenPair,bonusCurve:bonusCurve,tokenMinPayout:tokenMinPayout,tokenRecipients:tokenRecipients,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{distCreationFee:distCreationFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!api.BigNumber(distCreationFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(distCreationFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fee")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert("string"==typeof strategy&&-1!==DistStrategy.indexOf(strategy),"invalid strategy")&&api.assert("string"==typeof numTicks&&api.BigNumber(numTicks).isInteger()&&api.BigNumber(numTicks).gt(0)&&api.BigNumber(numTicks).lte(5555),"numTicks must be a number between 1 and 5555")){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),newDist={strategy:strategy,numTicks:numTicks,numTicksLeft:api.BigNumber(numTicks).toNumber(),active:!1,creator:api.sender,lastTickTime:blockDate.getTime()};if("fixed"===strategy&&await validateMinPayout(tokenMinPayout)&&await validateRecipients(params,tokenRecipients))newDist.tokenMinPayout=tokenMinPayout,newDist.tokenRecipients=tokenRecipients;else{if("pool"!==strategy)return;if(!api.assert(await validatePool(tokenPair),"invalid tokenPair"))return;if(void 0!==excludeAccount&&!api.assert(Array.isArray(excludeAccount),"excludeAccount must be an array"))return;if(void 0!==bonusCurve&&!validateBonusCurve(bonusCurve))return;newDist.tokenPair=tokenPair,newDist.excludeAccount=excludeAccount||[],newDist.bonusCurve=bonusCurve||{}}const createdDist=await api.db.insert("batches",newDist);api.sender!==api.owner&&api.BigNumber(distCreationFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:distCreationFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("create",{id:createdDist._id})}},actions.update=async payload=>{const{id:id,numTicks:numTicks,excludeAccount:excludeAccount,tokenPair:tokenPair,bonusCurve:bonusCurve,tokenMinPayout:tokenMinPayout,tokenRecipients:tokenRecipients,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{distUpdateFee:distUpdateFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!api.BigNumber(distUpdateFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(distUpdateFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the update fee")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")){const exDist=await api.db.findOne("batches",{_id:id});if(api.assert(exDist,"distribution not found")&&api.assert(api.sender===api.owner||api.sender===exDist.creator,"must be owner or creator")){if(numTicks&&api.assert("string"==typeof numTicks&&api.BigNumber(numTicks).isInteger()&&api.BigNumber(numTicks).gt(0)&&api.BigNumber(numTicks).lte(5555),"numTicks must be a number between 1 and 5555")&&(exDist.numTicks=numTicks,exDist.numTicksLeft=api.BigNumber(numTicks).toNumber()),"fixed"===exDist.strategy){if(!await validateMinPayout(tokenMinPayout)||!await validateRecipients(params,tokenRecipients))return;exDist.tokenMinPayout=tokenMinPayout,exDist.tokenRecipients=tokenRecipients}else{if("pool"!==exDist.strategy)return;void 0!==excludeAccount&&api.assert(Array.isArray(excludeAccount),"excludeAccount must be an array")&&(exDist.excludeAccount=excludeAccount),void 0!==tokenPair&&api.assert(await validatePool(tokenPair),"invalid tokenPair")&&(exDist.tokenPair=tokenPair),void 0!==bonusCurve&&validateBonusCurve(bonusCurve)&&(exDist.bonusCurve=bonusCurve)}await api.db.update("batches",exDist),api.sender!==api.owner&&api.BigNumber(distUpdateFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:distUpdateFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("update",{id:exDist._id})}}},actions.setActive=async payload=>{const{id:id,active:active,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key"))return;const dist=await api.db.findOne("batches",{_id:id});api.assert(dist,"distribution id not found")&&api.assert(dist.creator===api.sender||api.owner===api.sender,"you must be the creator of this distribution")&&(dist.active=!!active,await api.db.update("batches",dist),api.emit("setActive",{id:dist._id,active:dist.active}))},actions.deposit=async payload=>{const{id:id,symbol:symbol,quantity:quantity,isSignedWithActiveKey:isSignedWithActiveKey}=payload,depToken=await api.db.findOneInTable("tokens","tokens",{symbol:symbol});if(!api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")||!api.assert("string"==typeof quantity&&api.BigNumber(quantity).gt(0),"invalid quantity")||!api.assert(api.BigNumber(quantity).dp()<=depToken.precision,"quantity precision mismatch"))return;const dist=await api.db.findOne("batches",{_id:id});if(api.assert(dist,"distribution id not found")&&api.assert(dist.active,"distribution must be active to deposit")){if("fixed"===dist.strategy&&!api.assert(validateIncomingToken(dist,symbol),`${symbol} is not accepted by this distribution`))return;const res=await api.executeSmartContract("tokens","transferToContract",{symbol:symbol,quantity:quantity,to:"distribution"});void 0===res.errors&&res.events&&void 0!==res.events.find(el=>"tokens"===el.contract&&"transferToContract"===el.event&&el.data.from===api.sender&&"distribution"===el.data.to&&api.BigNumber(el.data.quantity).eq(quantity))&&(await updateTokenBalances(dist,depToken,quantity),api.emit("deposit",{distId:id,symbol:symbol,quantity:quantity}))}},actions.receiveDtfTokens=async payload=>{const{data:data,symbol:symbol,quantity:quantity,callingContractInfo:callingContractInfo}=payload;if(!api.assert(callingContractInfo&&"tokenfunds"===callingContractInfo.name,"not authorized"))return;if(!api.assert("object"==typeof data&&"Object"===data.constructor.name&&"distId"in data&&"string"==typeof data.distId&&api.BigNumber(data.distId).isInteger(),"invalid DTF payload"))return;const dist=await api.db.findOne("batches",{_id:api.BigNumber(data.distId).toNumber()});if(api.assert(dist,"distribution id not found")&&api.assert(dist.active,"distribution must be active to deposit")){if("fixed"===dist.strategy&&!api.assert(validateIncomingToken(dist,symbol),`${symbol} is not accepted by this distribution`))return;const depToken=await api.db.findOneInTable("tokens","tokens",{symbol:symbol});await updateTokenBalances(dist,depToken,quantity),api.emit("receiveDtfTokens",{distId:data.distId,symbol:symbol,quantity:quantity})}},actions.flush=async payload=>{const{id:id,isSignedWithActiveKey:isSignedWithActiveKey}=payload,dist=await api.db.findOne("batches",{_id:id});if(api.assert(dist,"distribution id not found")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert(api.sender===api.owner||api.sender===dist.creator,"must be owner or creator")){const params=await api.db.findOne("params",{});dist.numTicksLeft=1,await api.db.update("batches",dist),await runDistribution(dist,params,!0),api.emit("flush",{distId:dist._id})}},actions.checkPendingDistributions=async()=>{if(api.assert("null"===api.sender,"not authorized")){const params=await api.db.findOne("params",{}),blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),tickTime=api.BigNumber(blockDate.getTime()).minus(3600*params.distTickHours*1e3).toNumber(),pendingDists=await api.db.find("batches",{active:!0,numTicksLeft:{$gt:0},"tokenBalances.0":{$exists:!0},lastTickTime:{$lte:tickTime}},params.maxDistributionsLimit,0,[{index:"lastTickTime",descending:!1},{index:"_id",descending:!1}]);if(pendingDists.length>0)for(let i=0;i<pendingDists.length;i+=1)await runDistribution(pendingDists[i],params);else{const pendingPay=await api.db.find("pendingPayments",{dueTime:{$lt:blockDate.getTime()}},params.maxDistributionsLimit,0,[{index:"dueTime",descending:!1},{index:"_id",descending:!1}]);if(pendingPay.length>0)for(let i=0;i<pendingPay.length;i+=1)await runPendingPay(pendingPay[i],params)}}};