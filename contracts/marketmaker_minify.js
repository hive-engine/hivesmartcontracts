const BASE_SYMBOL="SWAP.HIVE",BASE_SYMBOL_PRECISION=8,DEBUG_MODE=!1;actions.createSSC=async()=>{};const getOrderBook=async(table,symbol,descending)=>await api.db.findInTable("market",table,{symbol:symbol},0,0,[{index:"priceDec",descending:descending},{index:"_id",descending:!1}]),cancelOrders=async(orders,type)=>{for(let k=0;k<orders.length;k+=1){const order=orders[k];await api.executeSmartContract("market","cancel",{account:order.account,type:type,id:order.txId})}},getClosestAmount=(baseCurrency,price,precision)=>baseCurrency.dividedBy(price).toFixed(precision),countBalanceInBuyOrders=orders=>orders.reduce((t,v)=>t.plus(api.BigNumber(v.tokensLocked)),api.BigNumber(0)),countBalanceInSellOrders=orders=>orders.reduce((t,v)=>t.plus(api.BigNumber(v.quantity)),api.BigNumber(0)),getOrderData=(orders,myOrders,account,qtyLimit,strategy,wallQty)=>{const data={};let counter=0;if(data.topOrder=null,1===strategy)for(;counter<orders.length;){if(qtyLimit.lt(orders[counter].quantity)){data.topOrder=orders[counter];break}counter+=1}else{let qtyCount=api.BigNumber(0);for(;counter<orders.length;){const orderQty=orders[counter].quantity;if(qtyLimit.lt(orderQty)&&(qtyCount=qtyCount.plus(orderQty),qtyCount.gte(wallQty))){data.topOrder=orders[counter];break}counter+=1}if(!data.topOrder)for(counter=0;counter<orders.length;){if(qtyLimit.lt(orders[counter].quantity)){data.topOrder=orders[counter];break}counter+=1}}for(data.isTopMine=!(!data.topOrder||data.topOrder.account!==account),data.topPrice=data.topOrder?api.BigNumber(data.topOrder.price):api.BigNumber(0),counter+=1,data.nextTopPrice=api.BigNumber(0);counter<orders.length;){const nextTopPrice=api.BigNumber(orders[counter].price);if(!nextTopPrice.eq(data.topPrice)&&qtyLimit.lt(orders[counter].quantity)){data.nextTopPrice=nextTopPrice;break}counter+=1}return data.myTopPrice=myOrders.length>0?api.BigNumber(myOrders[0].price):api.BigNumber(0),data.numOrdersAtMyPrice=0,data.myTopPrice.gt(0)&&(data.numOrdersAtMyPrice=orders.reduce((t,v)=>api.BigNumber(v.price).eq(data.myTopPrice)?t+1:t,0),data.myTopPrice.eq(data.topPrice)&&(data.isTopMine=!0)),data},tickMarket=async(market,txIdPrefix)=>{if(!market.isEnabled)return;const maxBidPrice=api.BigNumber(market.maxBidPrice),minSellPrice=api.BigNumber(market.minSellPrice);let maxBaseToSpend=api.BigNumber(market.maxBaseToSpend);const minBaseToSpend=api.BigNumber(market.minBaseToSpend);let maxTokensToSell=api.BigNumber(market.maxTokensToSell);const minTokensToSell=api.BigNumber(market.minTokensToSell);let priceIncrement=api.BigNumber(market.priceIncrement);const minSpread=api.BigNumber(market.minSpread),maxDistFromNext=api.BigNumber(market.maxDistFromNext),ignoreOrderQtyLt=api.BigNumber(market.ignoreOrderQtyLt),placeAtBidWall=api.BigNumber(market.placeAtBidWall),placeAtSellWall=api.BigNumber(market.placeAtSellWall);let baseBalance=api.BigNumber(0),tokenBalance=api.BigNumber(0);const balances=await api.db.findInTable("tokens","balances",{account:market.account,symbol:{$in:["SWAP.HIVE",market.symbol]}},2,0,[{index:"_id",descending:!1}]);for(let j=0;j<balances.length;j+=1){const balance=balances[j];"SWAP.HIVE"===balance.symbol?baseBalance=api.BigNumber(balance.balance):balance.symbol===market.symbol&&(tokenBalance=api.BigNumber(balance.balance))}const buyOrders=await getOrderBook("buyBook",market.symbol,!0),sellOrders=await getOrderBook("sellBook",market.symbol,!1),myBuyOrders=buyOrders.filter(o=>o.account===market.account),mySellOrders=sellOrders.filter(o=>o.account===market.account),isBuyBookEmpty=0===buyOrders.length||buyOrders.length===myBuyOrders.length,isSellBookEmpty=0===sellOrders.length||sellOrders.length===mySellOrders.length;if(isBuyBookEmpty&&isSellBookEmpty)return void 0;baseBalance=baseBalance.plus(countBalanceInBuyOrders(myBuyOrders)),tokenBalance=tokenBalance.plus(countBalanceInSellOrders(mySellOrders)),baseBalance.lt(maxBaseToSpend)&&(maxBaseToSpend=baseBalance),tokenBalance.lt(maxTokensToSell)&&(maxTokensToSell=tokenBalance),priceIncrement.gt(maxDistFromNext)&&(priceIncrement=maxDistFromNext);const bb=getOrderData(buyOrders,myBuyOrders,market.account,ignoreOrderQtyLt,market.strategy,placeAtBidWall),sb=getOrderData(sellOrders,mySellOrders,market.account,ignoreOrderQtyLt,market.strategy,placeAtSellWall);const isMaxBuyDistExceeded=bb.topPrice.gt(bb.nextTopPrice.plus(maxDistFromNext))||isBuyBookEmpty;let newTopBuyPrice=bb.topPrice.plus(priceIncrement);!isBuyBookEmpty&&isMaxBuyDistExceeded&&(newTopBuyPrice=bb.nextTopPrice.plus(priceIncrement)),newTopBuyPrice.gt(maxBidPrice)&&(newTopBuyPrice=maxBidPrice);const isMaxSellDistExceeded=sb.topPrice.lt(sb.nextTopPrice.minus(maxDistFromNext))||isSellBookEmpty;let newTopSellPrice=sb.topPrice.minus(priceIncrement);if(!isSellBookEmpty&&isMaxSellDistExceeded&&(newTopSellPrice=sb.nextTopPrice.minus(priceIncrement)),newTopSellPrice.lt(minSellPrice)&&(newTopSellPrice=minSellPrice),sellOrders.length>0){if(newTopBuyPrice.gte(newTopSellPrice))return;if(newTopSellPrice.minus(newTopBuyPrice).lt(minSpread))return}let shouldReplaceBuyOrder=!1;myBuyOrders.length>0&&(bb.myTopPrice.lt(bb.topPrice)&&bb.topPrice.lt(maxBidPrice)||bb.myTopPrice.gt(maxBidPrice)||bb.isTopMine&&isMaxBuyDistExceeded||bb.numOrdersAtMyPrice>1&&bb.isTopMine||bb.numOrdersAtMyPrice>1&&!bb.isTopMine&&bb.myTopPrice.lt(newTopBuyPrice))&&(await cancelOrders(myBuyOrders,"buy"),bb.isTopMine&&isMaxBuyDistExceeded&&!isBuyBookEmpty||(shouldReplaceBuyOrder=!0));let shouldReplaceSellOrder=!1;mySellOrders.length>0&&(sb.myTopPrice.gt(sb.topPrice)&&sb.topPrice.gt(minSellPrice)||sb.myTopPrice.lt(minSellPrice)||sb.isTopMine&&isMaxSellDistExceeded||sb.numOrdersAtMyPrice>1&&sb.isTopMine||sb.numOrdersAtMyPrice>1&&!sb.isTopMine&&sb.myTopPrice.gt(newTopSellPrice))&&(await cancelOrders(mySellOrders,"sell"),sb.isTopMine&&isMaxSellDistExceeded&&!isSellBookEmpty||(shouldReplaceSellOrder=!0));let orderCount=0;if((0===myBuyOrders.length||shouldReplaceBuyOrder)&&maxBaseToSpend.gte(minBaseToSpend)){const tokensToBuy=getClosestAmount(maxBaseToSpend,newTopBuyPrice,market.precision);false,await api.executeSmartContract("market","buy",{account:market.account,txId:`${txIdPrefix}-${orderCount}`,symbol:market.symbol,quantity:tokensToBuy,price:newTopBuyPrice.toFixed(8)}),orderCount+=1}(0===mySellOrders.length||shouldReplaceSellOrder)&&maxTokensToSell.gte(minTokensToSell)&&sellOrders.length>0&&(await api.executeSmartContract("market","sell",{account:market.account,txId:`${txIdPrefix}-${orderCount}`,symbol:market.symbol,quantity:maxTokensToSell.toFixed(market.precision),price:newTopSellPrice.toFixed(8)}),orderCount+=1)};actions.tick=async payload=>{if("null"!==api.sender)return;const{markets:markets,txIdBase:txIdBase}=payload;for(let i=0;i<markets.length;i+=1)await tickMarket(markets[i],`${txIdBase}-${i}`)};