const MAX_DIGITS=20,PROPERTY_OPS={ADD:{add:(x,y)=>api.BigNumber(x).plus(y),remove:(x,y)=>api.BigNumber(x).minus(y),defaultValue:0},MULTIPLY:{add:(x,y)=>api.BigNumber(x).multipliedBy(y).dp(20),remove:(x,y)=>api.BigNumber(x).dividedBy(y).dp(20),defaultValue:1}};actions.createSSC=async()=>{if(!1===await api.db.tableExists("miningPower")){await api.db.createTable("miningPower",["id","power"]),await api.db.createTable("pools",["id"]),await api.db.createTable("tokenPools",["symbol"]),await api.db.createTable("nftTokenPools",["symbol"]),await api.db.createTable("params");const params={poolCreationFee:"1000",poolUpdateFee:"300",maxLotteriesPerBlock:20,maxBalancesProcessedPerBlock:1e4,processQueryLimit:1e3};await api.db.insert("params",params)}else{const params=await api.db.findOne("params",{});params.updateIndex||(await api.db.addIndexes("miningPower",[{name:"byPoolIdAndAccount",index:{id:1,account:1}}]),params.updateIndex=1,await api.db.update("params",params))}},actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{poolCreationFee:poolCreationFee,poolUpdateFee:poolUpdateFee,maxLotteriesPerBlock:maxLotteriesPerBlock,maxBalancesProcessedPerBlock:maxBalancesProcessedPerBlock,processQueryLimit:processQueryLimit}=payload,params=await api.db.findOne("params",{});if(poolCreationFee){if(!api.assert("string"==typeof poolCreationFee&&!api.BigNumber(poolCreationFee).isNaN()&&api.BigNumber(poolCreationFee).gte(0),"invalid poolCreationFee"))return;params.poolCreationFee=poolCreationFee}if(poolUpdateFee){if(!api.assert("string"==typeof poolUpdateFee&&!api.BigNumber(poolUpdateFee).isNaN()&&api.BigNumber(poolUpdateFee).gte(0),"invalid poolUpdateFee"))return;params.poolUpdateFee=poolUpdateFee}if(maxLotteriesPerBlock){if(!api.assert(Number.isInteger(maxLotteriesPerBlock)&&maxLotteriesPerBlock>=1,"invalid maxLotteriesPerBlock"))return;params.maxLotteriesPerBlock=maxLotteriesPerBlock}if(maxBalancesProcessedPerBlock){if(!api.assert(Number.isInteger(maxBalancesProcessedPerBlock)&&maxBalancesProcessedPerBlock>=1,"invalid maxBalancesProcessedPerBlock"))return;params.maxBalancesProcessedPerBlock=maxBalancesProcessedPerBlock}if(processQueryLimit){if(!api.assert(Number.isInteger(processQueryLimit)&&processQueryLimit>=1,"invalid processQueryLimit"))return;params.processQueryLimit=processQueryLimit}await api.db.update("params",params)};const findAndProcessAll=async(contractName,table,query,callback)=>{let offset=0,results=[],done=!1;for(;!done;)if(results=await api.db.findInTable(contractName,table,query,1e3,offset),results){for(let i=0;i<results.length;i+=1)await callback(results[i]);results.length<1e3?done=!0:offset+=1e3}};async function validateNftProperties(properties){if(!api.assert(properties&&Array.isArray(properties),"invalid nftTokenMiner properties"))return!1;if(!api.assert(properties.length>0&&properties.length<=4,"nftTokenMiner properties size must be between 1 and 4"))return!1;for(let i=0;i<properties.length;i+=1){const prop=properties[i],propKeys=Object.keys(prop);for(let j=0;j<propKeys.length;j+=1){const propKey=propKeys[j];if("op"===propKey){if(!api.assert("string"==typeof prop.op&&PROPERTY_OPS[prop.op],"nftTokenMiner properties op should be ADD or MULTIPLY"))return!1}else if("name"===propKey){if(!api.assert("string"==typeof prop.name&&prop.name.length<=16,"nftTokenMiner properties name should be a string of length <= 16"))return!1}else{if("burnChange"!==propKey)return api.assert(!1,"nftTokenMiner properties field invalid"),!1;{if(!api.assert("object"==typeof prop.burnChange&&"string"==typeof prop.burnChange.symbol&&api.BigNumber(prop.burnChange.quantity).isFinite()&&api.BigNumber(prop.burnChange.quantity).isPositive(),"nftTokenMiner properties burnChange invalid"))return!1;const token=await api.db.findOneInTable("tokens","tokens",{symbol:prop.burnChange.symbol});if(!api.assert(token,"nftTokenMiner properties burnChange symbol not found"))return!1}}}}return!0}function validateNftTypeMap(typeMap,properties){if(!api.assert(typeMap&&"object"==typeof typeMap,"invalid nftTokenMiner typeMap"))return!1;const types=Object.keys(typeMap);for(let j=0;j<types.length;j+=1){const typeConfig=typeMap[types[j]];if(!api.assert(Array.isArray(typeConfig)&&typeConfig.length===properties.length,"nftTokenMiner typeConfig length mismatch"))return!1;for(let k=0;k<typeConfig.length;k+=1){const typeProperty=api.BigNumber(typeConfig[k]);if(!api.assert(!typeProperty.isNaN()&&typeProperty.isFinite(),"nftTokenMiner typeConfig invalid"))return!1;if("MULTIPLY"===properties[k].op&&!api.assert(typeProperty.gte(.01)&&typeProperty.lte(100),"nftTokenMiner typeConfig MULTIPLY property should be between 0.01 and 100"))return!1}}return!0}async function validateTokenMiners(tokenMiners,nftTokenMiner){if(!api.assert(tokenMiners&&Array.isArray(tokenMiners),"tokenMiners invalid"))return!1;if(!api.assert(tokenMiners.length>=1&&tokenMiners.length<=2||nftTokenMiner&&0===tokenMiners.length,"only 1 or 2 tokenMiners allowed"))return!1;const tokenMinerSymbols=new Set;for(let i=0;i<tokenMiners.length;i+=1){const tokenMinerConfig=tokenMiners[i];if(!api.assert(tokenMinerConfig&&tokenMinerConfig.symbol&&"string"==typeof tokenMinerConfig.symbol,"tokenMiners invalid"))return!1;if(!api.assert(!tokenMinerSymbols.has(tokenMinerConfig.symbol),"tokenMiners cannot have duplicate symbols"))return!1;tokenMinerSymbols.add(tokenMinerConfig.symbol);const{symbol:symbol}=tokenMinerConfig,token=await api.db.findOneInTable("tokens","tokens",{symbol:symbol});if(!api.assert(token&&token.stakingEnabled,"tokenMiners must have staking enabled"))return!1;if(!api.assert(Number.isInteger(tokenMinerConfig.multiplier)&&tokenMinerConfig.multiplier>=1&&tokenMinerConfig.multiplier<=100,"tokenMiner multiplier must be an integer from 1 to 100"))return!1}if(nftTokenMiner){if(!api.assert(nftTokenMiner.symbol&&"string"==typeof nftTokenMiner.symbol,"nftTokenMiner invalid"))return!1;const{symbol:symbol,typeMap:typeMap,properties:properties,typeField:typeField}=nftTokenMiner,nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(!api.assert(nft&&nft.delegationEnabled,"nftTokenMiner must have delegation enabled"))return!1;if(!api.assert(typeField&&"string"==typeof typeField,"typeField must be a string"))return!1;if(!api.assert(nft.properties[typeField]&&"string"===nft.properties[typeField].type,"nftTokenMiner must have string type property"))return!1;if(!await validateNftProperties(properties))return!1;if(!validateNftTypeMap(typeMap,properties))return!1}return!0}async function validateTokenMinersChange(oldTokenMiners,tokenMiners,oldNftTokenMiner,nftTokenMiner){if(!api.assert(tokenMiners.length===oldTokenMiners.length,"cannot change which tokens are in tokenMiners"))return!1;let changed=!1;for(let i=0;i<tokenMiners.length;i+=1){const oldConfig=oldTokenMiners[i],newConfig=tokenMiners[i];if(!api.assert(oldConfig.symbol===newConfig.symbol,"cannot change which tokens are in tokenMiners"))return!1;if(!api.assert(Number.isInteger(newConfig.multiplier)&&newConfig.multiplier>=1&&newConfig.multiplier<=100,"tokenMiner multiplier must be an integer from 1 to 100"))return!1;oldConfig.multiplier!==newConfig.multiplier&&(changed=!0)}if(!api.assert(!!oldNftTokenMiner==!!nftTokenMiner,"cannot change nftTokenMiner token"))return!1;if(nftTokenMiner){if(!api.assert(oldNftTokenMiner.symbol===nftTokenMiner.symbol,"cannot change nftTokenMiner token"))return!1;const{typeMap:typeMap,properties:properties,typeField:typeField}=nftTokenMiner;if(!api.assert(typeField&&"string"==typeof typeField&&typeField===oldNftTokenMiner.typeField,"cannot change nftTokenMiner typeField"))return!1;if(!api.assert(typeMap&&"object"==typeof typeMap,"invalid nftTokenMiner typeMap"))return!1;if(!await validateNftProperties(properties))return!1;if(properties.length!==oldNftTokenMiner.properties.length)changed=!0;else for(let i=0;i<properties.length;i+=1){const prop=properties[i],oldProp=oldNftTokenMiner.properties[i];prop.op!==oldProp.op&&(changed=!0)}if(!validateNftTypeMap(typeMap,properties))return!1;const oldTypes=Object.keys(oldNftTokenMiner.typeMap);for(let i=0;i<oldTypes.length;i+=1){const oldType=oldTypes[i],oldTypeConfig=oldNftTokenMiner.typeMap[oldType],typeConfig=typeMap[oldType];if(!api.assert(typeConfig,"typeConfig types must be a superset of old typeConfig types"))return!1;for(let j=0;j<typeConfig.length;j+=1)oldTypeConfig[j]!==typeConfig[j]&&(changed=!0)}}return{changed:changed}}function computeMiningPower(miningPower,tokenMiners,nftTokenMiner){let power=api.BigNumber(0);for(let i=0;i<tokenMiners.length;i+=1)miningPower.balances[i]&&(power=power.plus(api.BigNumber(miningPower.balances[i]).multipliedBy(tokenMiners[i].multiplier)));if(nftTokenMiner&&miningPower.nftBalances){let nftPower=api.BigNumber(1);for(let i=0;i<nftTokenMiner.properties.length;i+=1)nftPower=nftPower.multipliedBy(miningPower.nftBalances[i]).dp(20);nftPower.isFinite()||(nftPower=api.BigNumber(0)),power=power.plus(nftPower)}return power.isPositive()&&power.isFinite()?power:api.BigNumber(0)}async function updateMiningPower(pool,token,account,stakedQuantity,delegatedQuantity,updatePoolTimestamp){let miningPower=await api.db.findOne("miningPower",{id:pool.id,account:account}),stake=api.BigNumber(stakedQuantity),oldMiningPower=api.BigNumber(0);stake=stake.plus(delegatedQuantity);const tokenIndex=pool.tokenMiners.findIndex((t=>t.symbol===token));if(miningPower){if(updatePoolTimestamp&&miningPower.updatePoolTimestamp!==updatePoolTimestamp){for(let i=0;i<pool.tokenMiners.length;i+=1)miningPower.balances[i]="0";if(miningPower.nftBalances){miningPower.nftBalances={};const{nftBalances:nftBalances}=miningPower;for(let j=0;j<pool.nftTokenMiner.properties.length;j+=1){const property=pool.nftTokenMiner.properties[j],opInfo=PROPERTY_OPS[property.op];nftBalances[j]=opInfo.defaultValue}}}else miningPower.balances[tokenIndex]||(miningPower.balances[tokenIndex]="0");oldMiningPower=computeMiningPower(miningPower,pool.tokenMiners,pool.nftTokenMiner),miningPower.balances[tokenIndex]=stake.plus(miningPower.balances[tokenIndex])}else{const balances={};balances[tokenIndex]=stake,miningPower={id:pool.id,account:account,balances:balances,power:{$numberDecimal:"0"}},miningPower=await api.db.insert("miningPower",miningPower)}const newMiningPower=computeMiningPower(miningPower,pool.tokenMiners,pool.nftTokenMiner);return miningPower.power={$numberDecimal:newMiningPower},updatePoolTimestamp&&(miningPower.updatePoolTimestamp=updatePoolTimestamp),await api.db.update("miningPower",miningPower),newMiningPower.minus(oldMiningPower)}function getNftAccount(nft){return"mining"===nft.delegatedTo.account&&"c"===nft.delegatedTo.ownedBy?nft.account:"u"===nft.delegatedTo.ownedBy?nft.delegatedTo.account:null}async function updateNftMiningPower(pool,nft,add,updatePoolTimestamp){const account=getNftAccount(nft);if(!account)return api.BigNumber(0);let miningPower=await api.db.findOne("miningPower",{id:pool.id,account:account}),oldMiningPower=api.BigNumber(0);const{typeMap:typeMap,properties:properties,typeField:typeField}=pool.nftTokenMiner,typeProperties=typeMap[nft.properties[typeField]];if(miningPower){miningPower.nftBalances||(miningPower.nftBalances={});const{nftBalances:nftBalances}=miningPower;for(let i=0;i<properties.length;i+=1){const property=properties[i],opInfo=PROPERTY_OPS[property.op];nftBalances[i]&&miningPower.updatePoolTimestamp===updatePoolTimestamp||(nftBalances[i]=opInfo.defaultValue)}if(oldMiningPower=computeMiningPower(miningPower,pool.tokenMiners,pool.nftTokenMiner),typeProperties)for(let i=0;i<properties.length;i+=1){const property=properties[i],opInfo=PROPERTY_OPS[property.op];nftBalances[i]=add?opInfo.add(nftBalances[i],typeProperties[i]):opInfo.remove(nftBalances[i],typeProperties[i])}}else{const nftBalances={};for(let i=0;i<properties.length;i+=1){const property=properties[i],opInfo=PROPERTY_OPS[property.op];if(!add)return api.assert(!1,"unexpected condition: remove without previous miningPower"),api.BigNumber(0);nftBalances[i]=typeProperties?opInfo.add(opInfo.defaultValue,typeProperties[i]):opInfo.defaultValue}miningPower={id:pool.id,account:account,balances:{},nftBalances:nftBalances,power:{$numberDecimal:"0"}},miningPower=await api.db.insert("miningPower",miningPower)}const newMiningPower=computeMiningPower(miningPower,pool.tokenMiners,pool.nftTokenMiner);return miningPower.power={$numberDecimal:newMiningPower},miningPower.updatePoolTimestamp=updatePoolTimestamp,await api.db.update("miningPower",miningPower),newMiningPower.minus(oldMiningPower)}async function initMiningPower(pool,updatePoolTimestamp,params,token,lastId){let balances,adjustedPower=api.BigNumber(0),offset=0,lastIdProcessed=lastId,complete=!1;for(;!complete&&offset<params.maxBalancesProcessedPerBlock;){balances=await api.db.findInTable("tokens","balances",{symbol:token,_id:{$gt:lastId}},params.processQueryLimit,offset,[{index:"_id",descending:!1}]);for(let i=0;i<balances.length;i+=1){const balance=balances[i];if(api.BigNumber(balance.stake).gt(0)||api.BigNumber(balance.delegationsIn).gt(0)){const adjusted=await updateMiningPower(pool,token,balance.account,balance.stake,balance.delegationsIn,updatePoolTimestamp);adjustedPower=adjustedPower.plus(adjusted)}lastIdProcessed=balance._id}balances.length<params.processQueryLimit&&(complete=!0),offset+=params.processQueryLimit}return{adjustedPower:adjustedPower,nextId:lastIdProcessed,complete:complete}}async function initNftMiningPower(pool,updatePoolTimestamp,params,nftTokenMiner,lastId){let nfts,adjustedPower=api.BigNumber(0),offset=0,lastIdProcessed=lastId,complete=!1;const{symbol:symbol}=nftTokenMiner;for(;!complete&&offset<params.maxBalancesProcessedPerBlock;){const nftQuery={_id:{$gt:lastId},delegatedTo:{$ne:null},"delegatedTo.undelegateAt":{$eq:null}};nfts=await api.db.findInTable("nft",`${symbol}instances`,nftQuery,params.processQueryLimit,offset,[{index:"_id",descending:!1}]);for(let i=0;i<nfts.length;i+=1){const nft=nfts[i],adjusted=await updateNftMiningPower(pool,nft,!0,updatePoolTimestamp);adjustedPower=adjustedPower.plus(adjusted),lastIdProcessed=nft._id}nfts.length<params.processQueryLimit&&(complete=!0),offset+=params.processQueryLimit}return{adjustedPower:adjustedPower,nextId:lastIdProcessed,complete:complete}}async function resumePowerUpdate(pool,params){let{inProgress:inProgress,tokenIndex:tokenIndex,nftTokenIndex:nftTokenIndex,lastId:lastId}=pool.updating;const{updatePoolTimestamp:updatePoolTimestamp}=pool.updating;if(!inProgress)return;if(tokenIndex<pool.tokenMiners.length){const tokenConfig=pool.tokenMiners[tokenIndex],{adjustedPower:adjustedPower,nextId:nextId,complete:complete}=await initMiningPower(pool,updatePoolTimestamp,params,tokenConfig.symbol,lastId);pool.totalPower=api.BigNumber(pool.totalPower).plus(adjustedPower),complete?(lastId=0,tokenIndex+=1):lastId=nextId}else if(pool.nftTokenMiner&&nftTokenIndex<1){const{nftTokenMiner:nftTokenMiner}=pool,{adjustedPower:adjustedPower,nextId:nextId,complete:complete}=await initNftMiningPower(pool,updatePoolTimestamp,params,nftTokenMiner,lastId);pool.totalPower=api.BigNumber(pool.totalPower).plus(adjustedPower),complete?(lastId=0,nftTokenIndex+=1):lastId=nextId}tokenIndex!==pool.tokenMiners.length||pool.nftTokenMiner&&1!==nftTokenIndex||(inProgress=!1,tokenIndex=0,nftTokenIndex=0);const{updating:updating}=pool;updating.inProgress=inProgress,updating.tokenIndex=tokenIndex,updating.nftTokenIndex=nftTokenIndex,updating.lastId=lastId,await api.db.update("pools",pool)}function generatePoolId(pool){const tokenMinerString=pool.externalContract&&pool.externalMiners?`EXT-${pool.externalMiners.replace(":","")}`:pool.tokenMiners.map((t=>t.symbol.replace(".","-"))).sort().join(","),nftTokenMinerString=pool.nftTokenMiner?`:${pool.nftTokenMiner.symbol}`:"";return`${pool.minedToken.replace(".","-")}:${tokenMinerString}${nftTokenMinerString}`}async function runLottery(pool,params){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),winningNumbers=[],minedToken=await api.db.findOneInTable("tokens","tokens",{symbol:pool.minedToken}),winningAmount=api.BigNumber(pool.lotteryAmount).dividedBy(pool.lotteryWinners).toFixed(minedToken.precision,api.BigNumber.ROUND_HALF_UP);if(pool.externalContract){if("marketpools"===pool.externalContract){const marketpool=await api.db.findOneInTable("marketpools","pools",{tokenPair:pool.externalMiners});for(let i=0;i<pool.lotteryWinners;i+=1)winningNumbers[i]=api.BigNumber(marketpool.totalShares).multipliedBy(api.random())}}else for(let i=0;i<pool.lotteryWinners;i+=1)winningNumbers[i]=api.BigNumber(pool.totalPower).multipliedBy(api.random());let miningPowers,offset=0,cumulativePower=api.BigNumber(0),nextCumulativePower=api.BigNumber(0),computedWinners=0;const winners=[];for(;computedWinners<pool.lotteryWinners;){if(pool.externalContract){if("marketpools"===pool.externalContract){miningPowers=await api.db.findInTable("marketpools","liquidityPositions",{tokenPair:pool.externalMiners},params.processQueryLimit,offset,[{index:"_id",descending:!1}]);for(let i=0;i<miningPowers.length;i+=1)miningPowers[i].power={$numberDecimal:api.BigNumber(miningPowers[i].shares).toFixed(minedToken.precision,api.BigNumber.ROUND_HALF_UP)}}}else miningPowers=await api.db.find("miningPower",{id:pool.id,power:{$gt:{$numberDecimal:"0"}}},params.processQueryLimit,offset,[{index:"power",descending:!0},{index:"_id",descending:!1}]);for(let i=0;i<miningPowers.length;i+=1){const miningPower=miningPowers[i];nextCumulativePower=cumulativePower.plus(miningPower.power.$numberDecimal);for(let j=0;j<pool.lotteryWinners;j+=1){const currentWinningNumber=winningNumbers[j];cumulativePower.lte(currentWinningNumber)&&nextCumulativePower.gt(currentWinningNumber)&&(computedWinners+=1,winners.push({winner:miningPower.account,winningNumber:currentWinningNumber,winningAmount:winningAmount}))}cumulativePower=nextCumulativePower}if(computedWinners===pool.lotteryWinners||miningPowers.length<params.processQueryLimit)break;offset+=params.processQueryLimit}api.emit("miningLottery",{poolId:pool.id,winners:winners});for(let i=0;i<winners.length;i+=1){const winner=winners[i];await api.executeSmartContract("tokens","issue",{to:winner.winner,symbol:minedToken.symbol,quantity:winningAmount})}pool.nextLotteryTimestamp=api.BigNumber(blockDate.getTime()).plus(3600*pool.lotteryIntervalHours*1e3).toNumber(),await api.db.update("pools",pool)}actions.setActive=async payload=>{const{id:id,active:active,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key"))return;const pool=await api.db.findOne("pools",{id:id});if(!api.assert(pool,"pool id not found"))return;const minedTokenObject=await api.db.findOneInTable("tokens","tokens",{symbol:pool.minedToken});if(!api.assert(minedTokenObject&&(minedTokenObject.issuer===api.sender||"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"===minedTokenObject.symbol&&api.sender===api.owner),"must be issuer of minedToken"))return;const{nftTokenMiner:nftTokenMiner}=pool;if(nftTokenMiner){const nftTokenPool=await api.db.findOne("nftTokenPools",{symbol:nftTokenMiner.symbol,id:pool.id});if(active&&!nftTokenPool){const otherNftTokenPools=await api.db.find("nftTokenPools",{symbol:nftTokenMiner.symbol});if(!api.assert(!otherNftTokenPools||otherNftTokenPools.length<2,"can have at most 2 active nft token pools for nft token"))return;await api.db.insert("nftTokenPools",{symbol:nftTokenMiner.symbol,id:pool.id})}else!active&&nftTokenPool&&await api.db.remove("nftTokenPools",nftTokenPool)}pool.active=!!active;const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`);pool.nextLotteryTimestamp=api.BigNumber(blockDate.getTime()).plus(3600*pool.lotteryIntervalHours*1e3).toNumber(),await api.db.update("pools",pool)},actions.updatePool=async payload=>{const{id:id,lotteryWinners:lotteryWinners,lotteryIntervalHours:lotteryIntervalHours,lotteryAmount:lotteryAmount,tokenMiners:tokenMiners,nftTokenMiner:nftTokenMiner,callingContractInfo:callingContractInfo,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{poolUpdateFee:poolUpdateFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorized=!(!api.BigNumber(poolUpdateFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(poolUpdateFee);if(api.assert(authorized,"you must have enough tokens to cover the update fee")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(id&&"string"==typeof id&&lotteryAmount&&"string"==typeof lotteryAmount&&!api.BigNumber(lotteryAmount).isNaN()&&api.BigNumber(lotteryAmount).gt(0),"invalid params")&&api.assert(Number.isInteger(lotteryWinners)&&lotteryWinners>=1&&lotteryWinners<=20,"invalid lotteryWinners: integer between 1 and 20 only")&&api.assert(Number.isInteger(lotteryIntervalHours)&&lotteryIntervalHours>=1&&lotteryIntervalHours<=720,"invalid lotteryIntervalHours: integer between 1 and 720 only")){const pool=await api.db.findOne("pools",{id:id});if(api.assert(pool,"pool id not found")){const minedTokenObject=await api.db.findOneInTable("tokens","tokens",{symbol:pool.minedToken});if(api.assert(minedTokenObject&&(minedTokenObject.issuer===api.sender||"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"===minedTokenObject.symbol&&api.sender===api.owner),"must be issuer of minedToken")&&api.assert(api.BigNumber(lotteryAmount).dp()<=minedTokenObject.precision,"minedToken precision mismatch for lotteryAmount")){if(callingContractInfo)pool.lotteryWinners=lotteryWinners,pool.lotteryIntervalHours=lotteryIntervalHours,pool.lotteryAmount=lotteryAmount;else{const validMinersChange=await validateTokenMinersChange(pool.tokenMiners,tokenMiners,pool.nftTokenMiner,nftTokenMiner);if(validMinersChange){pool.lotteryWinners=lotteryWinners,pool.lotteryIntervalHours=lotteryIntervalHours,pool.lotteryAmount=lotteryAmount,pool.tokenMiners=tokenMiners,pool.nftTokenMiner=nftTokenMiner;const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`);validMinersChange.changed&&(pool.updating.updatePoolTimestamp=api.BigNumber(blockDate.getTime()).toNumber(),pool.updating.inProgress=!0,pool.updating.tokenIndex=0,pool.updating.nftTokenIndex=0,pool.updating.lastId=0,pool.totalPower="0"),pool.nextLotteryTimestamp=api.BigNumber(blockDate.getTime()).plus(3600*lotteryIntervalHours*1e3).toNumber()}}await api.db.update("pools",pool),api.sender!==api.owner&&api.BigNumber(poolUpdateFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:poolUpdateFee,isSignedWithActiveKey:isSignedWithActiveKey})}}}},actions.changeNftProperty=async payload=>{const{id:id,type:type,propertyName:propertyName,changeAmount:changeAmount,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(id&&"string"==typeof id&&type&&"string"==typeof type&&propertyName&&"string"==typeof propertyName&&changeAmount&&"string"==typeof changeAmount&&!api.BigNumber(changeAmount).isNaN()&&api.BigNumber(changeAmount).isFinite(),"invalid params"))return;if(!api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key"))return;const pool=await api.db.findOne("pools",{id:id});if(!api.assert(pool,"pool id not found"))return;const propertyIndex=pool.nftTokenMiner.properties.findIndex((p=>p.name===propertyName)),property=pool.nftTokenMiner.properties[propertyIndex];if(!api.assert(property&&property.burnChange,"property not enabled for burn change"))return;const typeProperties=pool.nftTokenMiner.typeMap[type];if(!api.assert(typeProperties,"type not found"))return;const burnSymbol=property.burnChange.symbol,token=await api.db.findOneInTable("tokens","tokens",{symbol:burnSymbol}),fee=api.BigNumber(changeAmount).abs().multipliedBy(property.burnChange.quantity);if(!api.assert(fee.dp()<=token.precision,`fee precision mismatch for amount ${fee}`))return;const balance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:burnSymbol}),authorized=api.BigNumber(fee).lte(0)||balance&&api.BigNumber(balance.balance).gte(fee);if(!api.assert(authorized,`you must have enough tokens to cover the update fee of ${fee} ${burnSymbol}`))return;if(typeProperties[propertyIndex]=api.BigNumber(typeProperties[propertyIndex]).plus(changeAmount),!validateNftTypeMap(pool.nftTokenMiner.typeMap,pool.nftTokenMiner.properties))return;const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`);pool.updating.updatePoolTimestamp=api.BigNumber(blockDate.getTime()).toNumber(),pool.updating.inProgress=!0,pool.updating.tokenIndex=0,pool.updating.nftTokenIndex=0,pool.updating.lastId=0,pool.totalPower="0",await api.db.update("pools",pool),api.BigNumber(fee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:burnSymbol,quantity:fee,isSignedWithActiveKey:isSignedWithActiveKey})},actions.createPool=async payload=>{const{lotteryWinners:lotteryWinners,lotteryIntervalHours:lotteryIntervalHours,lotteryAmount:lotteryAmount,minedToken:minedToken,tokenMiners:tokenMiners,nftTokenMiner:nftTokenMiner,externalMiners:externalMiners,callingContractInfo:callingContractInfo,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{poolCreationFee:poolCreationFee}=params;if(!(void 0===externalMiners||api.assert("string"==typeof externalMiners,"externalMiners must be a string")&&api.assert(callingContractInfo,"must be called from a contract")))return;const utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!api.BigNumber(poolCreationFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(poolCreationFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fee")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(minedToken&&"string"==typeof minedToken&&lotteryAmount&&"string"==typeof lotteryAmount&&!api.BigNumber(lotteryAmount).isNaN()&&api.BigNumber(lotteryAmount).gt(0),"invalid params")&&api.assert(minedToken.length>0&&minedToken.length<=10,"invalid symbol: uppercase letters only, max length of 10")&&api.assert(Number.isInteger(lotteryWinners)&&lotteryWinners>=1&&lotteryWinners<=20,"invalid lotteryWinners: integer between 1 and 20 only")&&api.assert(Number.isInteger(lotteryIntervalHours)&&lotteryIntervalHours>=1&&lotteryIntervalHours<=720,"invalid lotteryIntervalHours: integer between 1 and 720 only")){const minedTokenObject=await api.db.findOneInTable("tokens","tokens",{symbol:minedToken});if(api.assert(minedTokenObject,"minedToken does not exist")&&api.assert(minedTokenObject.issuer===api.sender||"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"===minedTokenObject.symbol&&api.sender===api.owner,"must be issuer of minedToken")&&api.assert(api.BigNumber(lotteryAmount).dp()<=minedTokenObject.precision,"minedToken precision mismatch for lotteryAmount")&&(callingContractInfo||await validateTokenMiners(tokenMiners,nftTokenMiner))){const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),newPool={minedToken:minedToken,lotteryWinners:lotteryWinners,lotteryIntervalHours:lotteryIntervalHours,lotteryAmount:lotteryAmount,tokenMiners:tokenMiners||[],nftTokenMiner:nftTokenMiner,active:!1,nextLotteryTimestamp:api.BigNumber(blockDate.getTime()).plus(3600*lotteryIntervalHours*1e3).toNumber(),totalPower:"0"};if(callingContractInfo){if(!api.assert(!nftTokenMiner,"external nftTokenMiner not currently supported"))return;newPool.externalContract=callingContractInfo.name,newPool.externalMiners=externalMiners}newPool.id=generatePoolId(newPool);const existingPool=await api.db.findOne("pools",{id:newPool.id});if(api.assert(!existingPool,"pool already exists")){if(tokenMiners)for(let i=0;i<tokenMiners.length;i+=1){const tokenConfig=tokenMiners[i];await api.db.insert("tokenPools",{symbol:tokenConfig.symbol,id:newPool.id})}newPool.updating={inProgress:!0,updatePoolTimestamp:api.BigNumber(blockDate.getTime()).toNumber(),tokenIndex:0,nftTokenIndex:0,lastId:0};const insertedPool=await api.db.insert("pools",newPool);api.sender!==api.owner&&api.BigNumber(poolCreationFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:poolCreationFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("createPool",{id:insertedPool.id})}}}},actions.checkPendingLotteries=async()=>{if(api.assert("null"===api.sender,"not authorized")){const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime(),params=await api.db.findOne("params",{}),updatingLotteries=await api.db.find("pools",{"updating.inProgress":!0},params.maxLotteriesPerBlock,0,[{index:"id",descending:!1}]);for(let i=0;i<updatingLotteries.length;i+=1){const pool=updatingLotteries[i];await resumePowerUpdate(pool,params)}const pendingLotteries=await api.db.find("pools",{active:!0,"updating.inProgress":!1,nextLotteryTimestamp:{$lte:timestamp}},params.maxLotteriesPerBlock,0,[{index:"id",descending:!1}]);for(let i=0;i<pendingLotteries.length;i+=1){const pool=pendingLotteries[i];await runLottery(pool,params)}}},actions.handleStakeChange=async payload=>{const{account:account,symbol:symbol,quantity:quantity,delegated:delegated,callingContractInfo:callingContractInfo}=payload;api.assert(callingContractInfo&&"tokens"===callingContractInfo.name,"must be called from tokens contract")&&await findAndProcessAll("mining","tokenPools",{symbol:symbol},(async tokenPool=>{const pool=await api.db.findOne("pools",{id:tokenPool.id});let adjusted;adjusted=delegated?await updateMiningPower(pool,symbol,account,0,quantity):await updateMiningPower(pool,symbol,account,quantity,0),pool.totalPower=adjusted.plus(pool.totalPower),await api.db.update("pools",pool)}))},actions.handleNftChange=async()=>{},actions.handleNftDelegationChange=async payload=>{const{symbol:symbol,nft:nft,add:add,callingContractInfo:callingContractInfo}=payload;api.assert(callingContractInfo&&"nft"===callingContractInfo.name,"must be called from nft contract")&&await findAndProcessAll("mining","nftTokenPools",{symbol:symbol},(async tokenPool=>{const pool=await api.db.findOne("pools",{id:tokenPool.id});if(pool.updating.inProgress&&pool.updating.tokenIndex===pool.tokenMiners.length&&pool.updating.lastId<nft._id)return;if(!pool.active)return;if(!pool.nftTokenMiner)return;const{typeField:typeField,typeMap:typeMap}=pool.nftTokenMiner;if(typeMap[nft.properties[typeField]]){const adjusted=await updateNftMiningPower(pool,nft,add,pool.updating.updatePoolTimestamp);pool.totalPower=adjusted.plus(pool.totalPower),await api.db.update("pools",pool)}}))},actions.handleNftSetProperty=async payload=>{};