const UTILITY_TOKEN_SYMBOL="BEE",UTILITY_TOKEN_PRECISION=8,CONTRACT_NAME="airdrops";actions.createSSC=async()=>{if(!1===await api.db.tableExists("pendingAirdrops")){await api.db.createTable("pendingAirdrops",["airdropId","symbol"]),await api.db.createTable("params");const params={feePerTransaction:"0.1",maxTransactionsPerBlock:50,maxAirdropsPerBlock:1};await api.db.insert("params",params)}},actions.updateParams=async payload=>{if(api.assert(api.sender===api.owner,"not authorized")){const{feePerTransaction:feePerTransaction,maxTransactionsPerBlock:maxTransactionsPerBlock,maxAirdropsPerBlock:maxAirdropsPerBlock}=payload,params=await api.db.findOne("params",{});if(feePerTransaction){if(!api.assert("string"==typeof feePerTransaction&&!api.BigNumber(feePerTransaction).isNaN()&&api.BigNumber(feePerTransaction).gte(0),"invalid feePerTransaction"))return;params.feePerTransaction=feePerTransaction}if(maxTransactionsPerBlock){if(!api.assert(Number.isInteger(maxTransactionsPerBlock)&&maxTransactionsPerBlock>=1,"invalid maxTransactionsPerBlock"))return;params.maxTransactionsPerBlock=maxTransactionsPerBlock}if(maxAirdropsPerBlock){if(!api.assert(Number.isInteger(maxAirdropsPerBlock)&&maxAirdropsPerBlock>=1,"invalid maxAirdropsPerBlock"))return;params.maxAirdropsPerBlock=maxAirdropsPerBlock}await api.db.update("params",params)}};const parseAirdrop=async(list,precision)=>{const params=await api.db.findOne("params",{}),airdrop={list:[],fee:"0",quantity:"0",isValid:!1};for(let i=0;i<list.length;i+=1){const{0:to,1:quantity}=list[i];if(!(api.assert(to,`list[${i}]: account name cannot be undefined`)&&api.assert(api.isValidAccountName(to),`list[${i}]: invalid account name`)&&api.assert(quantity,`list[${i}]: quantity cannot be undefined`)&&api.assert(!api.BigNumber(quantity).isNaN(),`list[${i}]: invalid quantity`)&&api.assert(api.BigNumber(quantity).gt(0),`list[${i}]: quantity must be positive`)&&api.assert(api.BigNumber(quantity).dp()<=precision,`list[${i}]: quantity precision mismatch`)))break;airdrop.list.push({to:to,quantity:quantity}),airdrop.quantity=api.BigNumber(airdrop.quantity).plus(quantity)}return airdrop.fee=api.BigNumber(params.feePerTransaction).times(airdrop.list.length).toFixed(8),api.assert(list.length>0,"list cannot be empty")&&list.length===airdrop.list.length&&(airdrop.isValid=!0),airdrop},hasValidType=(token,type)=>"transfer"===type||!("stake"!==type||!api.assert(!0===token.stakingEnabled,"staking not enabled")),transferIsSuccessful=(result,action,from,to,symbol,quantity)=>!(void 0!==result.errors||!result.events||void 0===result.events.find(el=>"tokens"===el.contract&&el.event===action&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol));actions.newAirdrop=async payload=>{const{symbol:symbol,type:type,list:list,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&type&&"string"==typeof type&&list&&Array.isArray(list),"invalid params")&&api.assert("transfer"===type||"stake"===type,"invalid type")){const token=await api.db.findOneInTable("tokens","tokens",{symbol:symbol}),utilityToken=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"BEE"}),nativeToken=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&hasValidType(token,type)){const airdrop=await parseAirdrop(list,token.precision);if(airdrop.isValid&&api.assert(utilityToken&&utilityToken.balance&&api.BigNumber(utilityToken.balance).gte(airdrop.fee),"you must have enough tokens to cover the airdrop fee")&&api.assert(nativeToken&&nativeToken.balance&&api.BigNumber(nativeToken.balance).gte(airdrop.quantity),"you must have enough tokens to do the airdrop")){const tokenTransfer=await api.executeSmartContract("tokens","transferToContract",{to:"airdrops",symbol:symbol,quantity:airdrop.quantity});if(transferIsSuccessful(tokenTransfer,"transferToContract",api.sender,"airdrops",symbol,airdrop.quantity)){const feeTransfer=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"BEE",quantity:airdrop.fee,isSignedWithActiveKey:isSignedWithActiveKey});if(transferIsSuccessful(feeTransfer,"transfer",api.sender,"null","BEE",airdrop.fee)){const res=await api.db.insert("pendingAirdrops",{airdropId:api.transactionId,symbol:symbol,type:type,list:airdrop.list,blockNumber:api.blockNumber});api.emit("newAirdrop",{airdropId:res.airdropId})}else await api.transferTokens(api.sender,symbol,airdrop.quantity,"user")}}}}};const processAirdrop=async(airdrop,maxTransactionsPerBlock)=>{const{airdropId:airdropId,list:list,symbol:symbol,type:type}=airdrop;let count=0;for(;count<maxTransactionsPerBlock&&void 0!==list[count];){const{to:to,quantity:quantity}=list[count];"transfer"===type?await api.transferTokens(to,symbol,quantity,"user"):"stake"===type&&await api.executeSmartContract("tokens","stakeFromContract",{to:to,symbol:symbol,quantity:quantity}),count+=1}api.BigNumber(count).plus(1),airdrop.list.splice(0,count),airdrop.list.length>0?await api.db.update("pendingAirdrops",airdrop):await api.db.remove("pendingAirdrops",airdrop),api.emit("airdropDistribution",{airdropId:airdropId,transactions:count})};actions.checkPendingAirdrops=async()=>{if(api.assert("null"===api.sender,"not authorized")){const params=await api.db.findOne("params",{}),pendingAirdrops=await api.db.find("pendingAirdrops",{blockNumber:{$lt:api.blockNumber}},params.maxAirdropsPerBlock,0,[{index:"_id",descending:!1}]);for(let i=0;i<pendingAirdrops.length;i+=1){const airdrop=pendingAirdrops[i];await processAirdrop(airdrop,params.maxTransactionsPerBlock)}}};