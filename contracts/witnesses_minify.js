const NB_APPROVALS_ALLOWED=30,NB_TOP_WITNESSES=20,NB_BACKUP_WITNESSES=1,NB_WITNESSES=21,NB_WITNESSES_SIGNATURES_REQUIRED=14,MAX_ROUNDS_MISSED_IN_A_ROW=3,MAX_ROUND_PROPOSITION_WAITING_PERIOD=40,NB_TOKENS_TO_REWARD_PER_BLOCK="0.01902586",NB_TOKENS_NEEDED_BEFORE_REWARDING="0.39954306",WITNESS_APPROVE_EXPIRE_BLOCKS=5184e3,WITNESS_MAX_ACCOUNT_EXPIRE_PER_BLOCK=10,UTILITY_TOKEN_SYMBOL="'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",UTILITY_TOKEN_PRECISION="${CONSTANTS.UTILITY_TOKEN_PRECISION}$",GOVERNANCE_TOKEN_SYMBOL="'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'",GOVERNANCE_TOKEN_PRECISION="${CONSTANTS.GOVERNANCE_TOKEN_PRECISION}$",GOVERNANCE_TOKEN_MIN_VALUE="'${CONSTANTS.GOVERNANCE_TOKEN_MIN_VALUE}$'",recalcTotalEnabledApprovalWeight=async()=>{let wits,totalEnabledApprovalWeight="0",offset=0;do{wits=await api.db.find("witnesses",{},1e3,offset,[{index:"_id",descending:!1}]);for(let i=0;i<wits.length;i+=1){const wit=wits[i];wit.enabled&&(totalEnabledApprovalWeight=api.BigNumber(totalEnabledApprovalWeight).plus(wit.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION))}offset+=1e3}while(1e3===wits.length);return totalEnabledApprovalWeight};actions.createSSC=async()=>{if(!1===await api.db.tableExists("witnesses")){await api.db.createTable("witnesses",["approvalWeight"]),await api.db.createTable("approvals",["from","to"]),await api.db.createTable("accounts",["account"]),await api.db.createTable("schedules"),await api.db.createTable("params");const params={totalApprovalWeight:"0",totalEnabledApprovalWeight:"0",numberOfApprovedWitnesses:0,lastVerifiedBlockNumber:0,round:0,lastBlockRound:0,currentWitness:null,blockNumberWitnessChange:0,lastWitnesses:[],numberOfApprovalsPerAccount:30,numberOfTopWitnesses:20,numberOfWitnessSlots:21,witnessSignaturesRequired:14,maxRoundsMissedInARow:3,maxRoundPropositionWaitingPeriod:40,witnessApproveExpireBlocks:5184e3};await api.db.insert("params",params)}else{const params=await api.db.findOne("params",{});params.totalEnabledApprovalWeight&&"NaN"!==params.totalEnabledApprovalWeight||(params.totalEnabledApprovalWeight=await recalcTotalEnabledApprovalWeight(),await api.db.update("params",params))}},actions.resetSchedule=async()=>{if(api.sender!==api.owner)return;const schedules=await api.db.find("schedules",{});for(let index=0;index<schedules.length;index+=1){const schedule=schedules[index];await api.db.remove("schedules",schedule)}const params=await api.db.findOne("params",{});params.currentWitness=null,params.blockNumberWitnessChange=0,params.lastWitnesses=[],params.totalEnabledApprovalWeight=await recalcTotalEnabledApprovalWeight(),await api.db.update("params",params)},actions.recalculateApprovals=async payload=>{if(api.sender!==api.owner)return;const witnessRec=await api.db.findOne("witnesses",{account:payload.witness});if(!witnessRec)return;let newApprovalWeight=api.BigNumber(0);const approvals=await api.db.find("approvals",{to:payload.witness});for(let i=0;i<approvals.length;i+=1){const approval=approvals[i],account=await api.db.findOne("accounts",{account:approval.from});account&&(newApprovalWeight=api.BigNumber(newApprovalWeight).plus(account.approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION))}const oldApprovalWeight=witnessRec.approvalWeight.$numberDecimal,deltaApprovalWeight=api.BigNumber(newApprovalWeight).minus(oldApprovalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION);await updateWitnessRank(payload.witness,deltaApprovalWeight)},actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{numberOfApprovalsPerAccount:numberOfApprovalsPerAccount,numberOfTopWitnesses:numberOfTopWitnesses,numberOfWitnessSlots:numberOfWitnessSlots,witnessSignaturesRequired:witnessSignaturesRequired,maxRoundsMissedInARow:maxRoundsMissedInARow,maxRoundPropositionWaitingPeriod:maxRoundPropositionWaitingPeriod,witnessApproveExpireBlocks:witnessApproveExpireBlocks}=payload,params=await api.db.findOne("params",{});let shouldResetSchedule=!1;numberOfApprovalsPerAccount&&Number.isInteger(numberOfApprovalsPerAccount)&&(params.numberOfApprovalsPerAccount=numberOfApprovalsPerAccount),numberOfTopWitnesses&&Number.isInteger(numberOfTopWitnesses)&&(params.numberOfTopWitnesses=numberOfTopWitnesses),numberOfWitnessSlots&&Number.isInteger(numberOfWitnessSlots)&&params.numberOfWitnessSlots!==numberOfWitnessSlots&&(shouldResetSchedule=!0,params.numberOfWitnessSlots=numberOfWitnessSlots),witnessSignaturesRequired&&Number.isInteger(witnessSignaturesRequired)&&(params.witnessSignaturesRequired=witnessSignaturesRequired),maxRoundsMissedInARow&&Number.isInteger(maxRoundsMissedInARow)&&(params.maxRoundsMissedInARow=maxRoundsMissedInARow),maxRoundPropositionWaitingPeriod&&Number.isInteger(maxRoundPropositionWaitingPeriod)&&(params.maxRoundPropositionWaitingPeriod=maxRoundPropositionWaitingPeriod),api.assert(params.numberOfTopWitnesses+1===params.numberOfWitnessSlots,"only 1 backup allowed")&&(witnessApproveExpireBlocks&&Number.isInteger(witnessApproveExpireBlocks)&&api.assert(witnessApproveExpireBlocks>params.numberOfWitnessSlots,"witnessApproveExpireBlocks should be greater than numberOfWitnessSlots")&&(params.witnessApproveExpireBlocks=witnessApproveExpireBlocks),await api.db.update("params",params),shouldResetSchedule&&await actions.resetSchedule())};const updateWitnessRank=async(witness,approvalWeight)=>{const witnessRec=await api.db.findOne("witnesses",{account:witness});if(witnessRec){const oldApprovalWeight=witnessRec.approvalWeight.$numberDecimal;witnessRec.approvalWeight.$numberDecimal=api.BigNumber(witnessRec.approvalWeight.$numberDecimal).plus(approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION),api.BigNumber(witnessRec.approvalWeight.$numberDecimal).lt(0)&&(witnessRec.approvalWeight.$numberDecimal=api.BigNumber(0)),await api.db.update("witnesses",witnessRec);const params=await api.db.findOne("params",{});params.totalApprovalWeight=api.BigNumber(params.totalApprovalWeight).plus(approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION),witnessRec.enabled&&(params.totalEnabledApprovalWeight=api.BigNumber(params.totalEnabledApprovalWeight).plus(approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION)),api.BigNumber(oldApprovalWeight).eq(0)&&api.BigNumber(witnessRec.approvalWeight.$numberDecimal).gt(0)?params.numberOfApprovedWitnesses+=1:api.BigNumber(oldApprovalWeight).gt(0)&&api.BigNumber(witnessRec.approvalWeight.$numberDecimal).eq(0)&&(params.numberOfApprovedWitnesses-=1),await api.db.update("params",params)}};actions.updateWitnessesApprovals=async payload=>{const{account:account,callingContractInfo:callingContractInfo}=payload;if(void 0===callingContractInfo)return;if("tokens"!==callingContractInfo.name)return;const acct=await api.db.findOne("accounts",{account:account});if(null!==acct){const balance=await api.db.findOneInTable("tokens","balances",{account:account,symbol:GOVERNANCE_TOKEN_SYMBOL});let approvalWeight=0;balance&&balance.stake&&(approvalWeight=balance.stake),balance&&balance.delegationsIn&&(approvalWeight=api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION));const oldApprovalWeight=acct.approvalWeight,deltaApprovalWeight=api.BigNumber(approvalWeight).minus(oldApprovalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION);if(acct.approvalWeight=approvalWeight,!api.BigNumber(deltaApprovalWeight).eq(0)){await api.db.update("accounts",acct);const approvals=await api.db.find("approvals",{from:account});for(let index=0;index<approvals.length;index+=1){const approval=approvals[index];await updateWitnessRank(approval.to,deltaApprovalWeight)}}}},actions.register=async payload=>{const{domain:domain,IP:IP,RPCPort:RPCPort,P2PPort:P2PPort,signingKey:signingKey,enabled:enabled,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"active key required")&&api.assert(domain||IP,"neither domain nor ip provided")&&api.assert(!(domain&&IP),"both domain and ip provided")&&(domain&&api.assert(domain&&"string"==typeof domain&&api.validator.isFQDN(domain),"domain is invalid")||IP&&api.assert(IP&&"string"==typeof IP&&api.validator.isIP(IP),"IP is invalid"))&&api.assert(RPCPort&&Number.isInteger(RPCPort)&&RPCPort>=0&&RPCPort<=65535,"RPCPort must be an integer between 0 and 65535")&&api.assert(P2PPort&&Number.isInteger(P2PPort)&&P2PPort>=0&&P2PPort<=65535,"P2PPort must be an integer between 0 and 65535")&&api.assert(api.validator.isAlphanumeric(signingKey)&&53===signingKey.length,"invalid signing key")&&api.assert("boolean"==typeof enabled,"enabled must be a boolean")){let witness=await api.db.findOne("witnesses",{signingKey:signingKey});if(api.assert(null===witness||witness.account===api.sender,"a witness is already using this signing key")&&(witness=IP?await api.db.findOne("witnesses",{IP:IP,P2PPort:P2PPort}):await api.db.findOne("witnesses",{domain:domain,P2PPort:P2PPort}),api.assert(null===witness||witness.account===api.sender,`a witness is already using this ${IP?"IP":"domain"}/Port`)))if(witness=await api.db.findOne("witnesses",{account:api.sender}),witness){const enabledChanged=witness.enabled!==enabled;let useUnsets=!1;const unsets={};IP?(witness.IP=IP,witness.domain&&(delete witness.domain,unsets.domain="",useUnsets=!0)):(witness.domain=domain,witness.IP&&(delete witness.IP,unsets.IP="",useUnsets=!0)),witness.RPCPort=RPCPort,witness.P2PPort=P2PPort,witness.signingKey=signingKey,witness.enabled=enabled,useUnsets?await api.db.update("witnesses",witness,unsets):await api.db.update("witnesses",witness);const params=await api.db.findOne("params",{});enabledChanged&&witness.enabled?params.totalEnabledApprovalWeight=api.BigNumber(params.totalEnabledApprovalWeight).plus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION):enabledChanged&&!witness.enabled&&(params.totalEnabledApprovalWeight=api.BigNumber(params.totalEnabledApprovalWeight).minus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION)),await api.db.update("params",params)}else witness={account:api.sender,approvalWeight:{$numberDecimal:"0"},signingKey:signingKey,RPCPort:RPCPort,P2PPort:P2PPort,enabled:enabled,missedRounds:0,missedRoundsInARow:0,verifiedRounds:0,lastRoundVerified:null,lastBlockVerified:null},IP?witness.IP=IP:witness.domain=domain,await api.db.insert("witnesses",witness)}};const removeApproval=async(approval,acct,blnce,manual=!0)=>{if(api.assert(null!==approval,"you have not approved this witness")){const{from:from,to:to}=approval;let account=acct;acct&&acct.account===from||(account=await api.db.findOne("accounts",{account:from})),await api.db.remove("approvals",approval);let balance=blnce;balance||(balance=await api.db.findOneInTable("tokens","balances",{account:from,symbol:GOVERNANCE_TOKEN_SYMBOL}));let approvalWeight=0;balance&&balance.stake&&(approvalWeight=balance.stake),balance&&balance.delegationsIn&&(approvalWeight=api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION)),manual&&(account.approvals-=1,account.approvalWeight=approvalWeight,account.lastApproveBlock=api.blockNumber,await api.db.update("accounts",account)),await updateWitnessRank(to,`-${approvalWeight}`),api.emit("witnessApprovalRemoved",{account:from,to:to,approvalWeight:approvalWeight})}};actions.approve=async payload=>{const{witness:witness}=payload,params=await api.db.findOne("params",{});if(api.assert(witness&&"string"==typeof witness&&witness.length>=3&&witness.length<=16,"invalid witness account")){const witnessRec=await api.db.findOne("witnesses",{account:witness});if(api.assert(witnessRec,"witness does not exist")){let acct=await api.db.findOne("accounts",{account:api.sender});if(null===acct&&(acct={account:api.sender,approvals:0,approvalWeight:{$numberDecimal:"0"},lastApproveBlock:api.blockNumber},acct=await api.db.insert("accounts",acct)),api.assert(acct.approvals<params.numberOfApprovalsPerAccount,`you can only approve ${params.numberOfApprovalsPerAccount} witnesses`)){let approval=await api.db.findOne("approvals",{from:api.sender,to:witness});if(api.assert(null===approval,"you already approved this witness")){approval={from:api.sender,to:witness},await api.db.insert("approvals",approval);const balance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:GOVERNANCE_TOKEN_SYMBOL});let approvalWeight=0;balance&&balance.stake&&(approvalWeight=balance.stake),balance&&balance.delegationsIn&&(approvalWeight=api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION)),acct.approvals+=1,acct.approvalWeight=approvalWeight,acct.lastApproveBlock=api.blockNumber,await api.db.update("accounts",acct),await updateWitnessRank(witness,approvalWeight),api.emit("witnessApprovalAdded",{account:api.sender,to:witness,approvalWeight:approvalWeight})}}}}},actions.disapprove=async payload=>{const{witness:witness}=payload;if(api.assert(witness&&"string"==typeof witness&&witness.length>=3&&witness.length<=16,"invalid witness account")){const witnessRec=await api.db.findOne("witnesses",{account:witness});if(api.assert(witnessRec,"witness does not exist")){let acct=await api.db.findOne("accounts",{account:api.sender});if(null===acct&&(acct={account:api.sender,approvals:0,approvalWeight:{$numberDecimal:"0"},lastApproveBlock:api.blockNumber},await api.db.insert("accounts",acct)),api.assert(acct.approvals>0,"no approvals found")){const approval=await api.db.findOne("approvals",{from:acct.account,to:witness}),balance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:GOVERNANCE_TOKEN_SYMBOL});await removeApproval(approval,acct,balance,!0)}}}};const expireAllUserApprovals=async acct=>{const approvals=await api.db.find("approvals",{from:acct.account}),balance=await api.db.findOneInTable("tokens","balances",{account:acct.account,symbol:GOVERNANCE_TOKEN_SYMBOL});for(let i=0;i<approvals.length;i+=1){const approval=approvals[i];await removeApproval(approval,acct,balance,!1)}let approvalWeight=0;balance&&balance.stake&&(approvalWeight=balance.stake),balance&&balance.delegationsIn&&(approvalWeight=api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION));const account=acct;account.approvals=0,account.approvalWeight=approvalWeight,await api.db.update("accounts",account),api.emit("witnessApprovalsExpired",{account:acct.account})},findAndExpireApprovals=async witnessApproveExpireBlocks=>{const accounts=await api.db.find("accounts",{lastApproveBlock:{$lt:api.blockNumber-witnessApproveExpireBlocks},approvals:{$gt:0}},10,0,[{index:"lastApproveBlock",descending:!1}]);for(let i=0;i<accounts.length;i+=1)await expireAllUserApprovals(accounts[i])},changeCurrentWitness=async()=>{const params=await api.db.findOne("params",{}),{currentWitness:currentWitness,totalEnabledApprovalWeight:totalEnabledApprovalWeight,lastWitnesses:lastWitnesses,lastBlockRound:lastBlockRound,round:round,maxRoundsMissedInARow:maxRoundsMissedInARow,maxRoundPropositionWaitingPeriod:maxRoundPropositionWaitingPeriod,lastVerifiedBlockNumber:lastVerifiedBlockNumber}=params;let witnessFound=!1;const random=api.random(),randomWeight=api.BigNumber(totalEnabledApprovalWeight).times(random).toFixed(GOVERNANCE_TOKEN_PRECISION,1);let offset=0,accWeight=0,witnesses=await api.db.find("witnesses",{approvalWeight:{$gt:{$numberDecimal:"0"}},enabled:!0},100,offset,[{index:"approvalWeight",descending:!0}]);const schedules=await api.db.find("schedules",{round:round}),currentWitnessSchedule=schedules.find((s=>s.witness===currentWitness)),previousRoundWitness=lastWitnesses.length>1?lastWitnesses[lastWitnesses.length-2]:"";do{for(let index=0;index<witnesses.length;index+=1){const witness=witnesses[index];if(accWeight=api.BigNumber(accWeight).plus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION),!0===witness.enabled&&witness.account!==previousRoundWitness&&void 0===schedules.find((s=>s.witness===witness.account))&&api.BigNumber(randomWeight).lte(accWeight)){api.debug(`changed witness from ${currentWitnessSchedule.witness} to ${witness.account}`);const newWitnessOrder=[witness.account];for(let index=0;index<schedules.length;index+=1){const schedule=schedules[index];schedule.witness!==currentWitness&&newWitnessOrder.push(schedule.witness),await api.db.remove("schedules",schedule)}let blockNumber=0===lastVerifiedBlockNumber?api.blockNumber:lastVerifiedBlockNumber+1;for(let i=0;i<newWitnessOrder.length;i+=1){const newSchedule={witness:newWitnessOrder[i],blockNumber:blockNumber,round:round};await api.db.insert("schedules",newSchedule),blockNumber+=1}params.currentWitness=newWitnessOrder[newWitnessOrder.length-1],params.lastWitnesses.push(newWitnessOrder[newWitnessOrder.length-1]),params.blockNumberWitnessChange=api.blockNumber+maxRoundPropositionWaitingPeriod;const scheduledWitness=await api.db.findOne("witnesses",{account:currentWitness});scheduledWitness.missedRounds+=1,scheduledWitness.missedRoundsInARow+=1,api.emit("witnessMissedRound",{witness:scheduledWitness.account}),scheduledWitness.missedRoundsInARow>=maxRoundsMissedInARow&&(scheduledWitness.missedRoundsInARow=0,scheduledWitness.enabled&&(params.totalEnabledApprovalWeight=api.BigNumber(params.totalEnabledApprovalWeight).minus(scheduledWitness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION)),scheduledWitness.enabled=!1,api.emit("witnessDisabledForMissingTooManyRoundsInARow",{witness:scheduledWitness.account})),await api.db.update("params",params),await api.db.update("witnesses",scheduledWitness),witnessFound=!0,api.emit("currentWitnessChanged",{});break}}!1===witnessFound&&(offset+=100,witnesses=await api.db.find("witnesses",{approvalWeight:{$gt:{$numberDecimal:"0"}}},100,offset,[{index:"approvalWeight",descending:!0}]))}while(witnesses.length>0&&!1===witnessFound);if(!1===witnessFound){api.debug("no backup witness was found, interchanging witnesses within the current schedule");for(let index=0;index<schedules.length-1;index+=1){const sched=schedules[index],newWitness=sched.witness;if(newWitness!==previousRoundWitness){api.debug(`changed current witness from ${currentWitness} to ${newWitness}`),schedule.witness=newWitness,await api.db.update("schedules",schedule),sched.witness=currentWitness,await api.db.update("schedules",sched),params.currentWitness=newWitness,params.lastWitnesses.push(newWitness),params.blockNumberWitnessChange=api.blockNumber+maxRoundPropositionWaitingPeriod;const scheduledWitness=await api.db.findOne("witnesses",{account:currentWitness});scheduledWitness.missedRounds+=1,scheduledWitness.missedRoundsInARow+=1,api.emit("witnessMissedRound",{witness:scheduledWitness.account}),scheduledWitness.missedRoundsInARow>=maxRoundsMissedInARow&&(scheduledWitness.missedRoundsInARow=0,scheduledWitness.enabled&&(params.totalEnabledApprovalWeight=api.BigNumber(params.totalEnabledApprovalWeight).minus(scheduledWitness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION)),scheduledWitness.enabled=!1,api.emit("witnessDisabledForMissingTooManyRoundsInARow",{witness:scheduledWitness.account})),await api.db.update("params",params),await api.db.update("witnesses",scheduledWitness),api.emit("currentWitnessChanged",{});break}}}},manageWitnessesSchedule=async()=>{if("null"!==api.sender)return;const params=await api.db.findOne("params",{}),{numberOfApprovedWitnesses:numberOfApprovedWitnesses,totalEnabledApprovalWeight:totalEnabledApprovalWeight,lastVerifiedBlockNumber:lastVerifiedBlockNumber,blockNumberWitnessChange:blockNumberWitnessChange,lastBlockRound:lastBlockRound,numberOfTopWitnesses:numberOfTopWitnesses,numberOfWitnessSlots:numberOfWitnessSlots,maxRoundPropositionWaitingPeriod:maxRoundPropositionWaitingPeriod,witnessApproveExpireBlocks:witnessApproveExpireBlocks}=params;await findAndExpireApprovals(witnessApproveExpireBlocks);const currentBlock=lastVerifiedBlockNumber+1;let schedule=await api.db.findOne("schedules",{blockNumber:currentBlock});if(null===schedule){if(api.debug("calculating new schedule"),schedule=[],numberOfApprovedWitnesses>=numberOfWitnessSlots){const random=api.random();let randomWeight=null,offset=0,accWeight=0,witnesses=await api.db.find("witnesses",{approvalWeight:{$gt:{$numberDecimal:"0"}},enabled:!0},100,offset,[{index:"approvalWeight",descending:!0}]);do{for(let index=0;index<witnesses.length;index+=1){const witness=witnesses[index];schedule.length>=numberOfTopWitnesses&&null===randomWeight&&(randomWeight=api.BigNumber(accWeight).plus(GOVERNANCE_TOKEN_MIN_VALUE).plus(api.BigNumber(totalEnabledApprovalWeight).minus(accWeight).times(random).toFixed(GOVERNANCE_TOKEN_PRECISION,1)).toFixed(GOVERNANCE_TOKEN_PRECISION)),accWeight=api.BigNumber(accWeight).plus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION),!0===witness.enabled&&(schedule.length<numberOfTopWitnesses||api.BigNumber(randomWeight).lte(accWeight))&&schedule.push({witness:witness.account,blockNumber:null}),schedule.length>=numberOfWitnessSlots&&(index=witnesses.length)}schedule.length<numberOfWitnessSlots&&(offset+=100,witnesses=await api.db.find("witnesses",{approvalWeight:{$gt:{$numberDecimal:"0"}}},100,offset,[{index:"approvalWeight",descending:!0}]))}while(witnesses.length>0&&schedule.length<numberOfWitnessSlots)}if(schedule.length===numberOfWitnessSlots){let j,x;for(let i=schedule.length-1;i>0;i-=1){const random=api.random();j=Math.floor(random*(i+1)),x=schedule[i],schedule[i]=schedule[j],schedule[j]=x}let lastWitnesses=params.lastWitnesses;const previousRoundWitness=lastWitnesses.length>0?lastWitnesses[lastWitnesses.length-1]:"";lastWitnesses.length>=numberOfWitnessSlots&&(lastWitnesses=[]);const lastWitness=schedule[schedule.length-1].witness;if(lastWitnesses.includes(lastWitness)||previousRoundWitness===lastWitness)for(let i=0;i<schedule.length;i+=1)if(!lastWitnesses.includes(schedule[i].witness)&&schedule[i].witness!==previousRoundWitness){const thisWitness=schedule[i].witness;schedule[i].witness=lastWitness,schedule[schedule.length-1].witness=thisWitness;break}if(schedule[0].witness===previousRoundWitness){const firstWitness=schedule[0].witness,secondWitness=schedule[1].witness;schedule[0].witness=secondWitness,schedule[1].witness=firstWitness}let blockNumber=0===lastVerifiedBlockNumber?api.blockNumber:lastVerifiedBlockNumber+1;params.round+=1;for(let i=0;i<schedule.length;i+=1)schedule[i].blockNumber=blockNumber,schedule[i].round=params.round,api.debug(`scheduled witness ${schedule[i].witness} for block ${blockNumber} (round ${params.round})`),await api.db.insert("schedules",schedule[i]),blockNumber+=1;0===lastVerifiedBlockNumber&&(params.lastVerifiedBlockNumber=api.blockNumber-1);const lastWitnessRoundSchedule=schedule[schedule.length-1];params.lastBlockRound=lastWitnessRoundSchedule.blockNumber,params.currentWitness=lastWitnessRoundSchedule.witness,lastWitnesses.push(lastWitnessRoundSchedule.witness),params.lastWitnesses=lastWitnesses,params.blockNumberWitnessChange=api.blockNumber+maxRoundPropositionWaitingPeriod,await api.db.update("params",params),api.emit("newSchedule",{})}}else api.blockNumber>=blockNumberWitnessChange&&(api.blockNumber>lastBlockRound?await changeCurrentWitness():(params.blockNumberWitnessChange=api.blockNumber+maxRoundPropositionWaitingPeriod,await api.db.update("params",params),api.emit("awaitingRoundEnd",{})))};actions.proposeRound=async payload=>{const{roundHash:roundHash,isSignedWithActiveKey:isSignedWithActiveKey,signatures:signatures}=payload,params=await api.db.findOne("params",{}),{lastVerifiedBlockNumber:lastVerifiedBlockNumber,round:round,lastBlockRound:lastBlockRound,currentWitness:currentWitness}=params,schedules=await api.db.find("schedules",{round:round},1e3,0,[{index:"_id",descending:!1}]),numberOfWitnessSlots=schedules.length,{witnessSignaturesRequired:witnessSignaturesRequired}=params;if(!0===isSignedWithActiveKey&&roundHash&&"string"==typeof roundHash&&64===roundHash.length&&Array.isArray(signatures)&&signatures.length<=numberOfWitnessSlots&&signatures.length>=witnessSignaturesRequired){let currentBlock=lastVerifiedBlockNumber+1,calculatedRoundHash="";if(api.sender===currentWitness){for(;currentBlock<=lastBlockRound;){const block=await api.db.getBlockInfo(currentBlock);if(null===block){calculatedRoundHash="";break}calculatedRoundHash=api.SHA256(`${calculatedRoundHash}${block.hash}`),currentBlock+=1}if(""!==calculatedRoundHash&&calculatedRoundHash===roundHash){let signaturesChecked=0;const verifiedBlockInformation=[],currentWitnessInfo=await api.db.findOne("witnesses",{account:currentWitness}),currentWitnessSignature=signatures.find((s=>s[0]===currentWitness));for(let index=0;index<schedules.length;index+=1){const scheduledWitness=schedules[index],witness=await api.db.findOne("witnesses",{account:scheduledWitness.witness});if(null!==witness){const signature=signatures.find((s=>s[0]===witness.account));signature&&api.checkSignature(calculatedRoundHash,signature[1],witness.signingKey,!0)&&(api.debug(`witness ${witness.account} signed round ${round}`),signaturesChecked+=1),verifiedBlockInformation.push({blockNumber:scheduledWitness.blockNumber,witness:currentWitness,signingKey:currentWitnessInfo.signingKey,roundSignature:currentWitnessSignature[1],round:round,roundHash:roundHash})}}if(signaturesChecked>=witnessSignaturesRequired){for(let index=0;index<verifiedBlockInformation.length;index+=1)await api.verifyBlock(verifiedBlockInformation[index]);for(let index=0;index<schedules.length;index+=1){const schedule=schedules[index];await api.db.remove("schedules",schedule)}const contractBalance=await api.db.findOneInTable("tokens","contractsBalances",{account:"witnesses",symbol:UTILITY_TOKEN_SYMBOL});if(contractBalance&&api.BigNumber(contractBalance.balance).gte("0.39954306")){const rewardAmount=api.BigNumber("0.01902586").multipliedBy(numberOfWitnessSlots).toFixed(UTILITY_TOKEN_PRECISION);await api.executeSmartContract("tokens","stakeFromContract",{to:currentWitness,symbol:UTILITY_TOKEN_SYMBOL,quantity:rewardAmount})}params.currentWitness=null,params.lastVerifiedBlockNumber=lastBlockRound,await api.db.update("params",params);const witness=await api.db.findOne("witnesses",{account:currentWitness});witness.missedRoundsInARow=0,witness.lastRoundVerified=round,witness.lastBlockVerified=lastBlockRound,witness.verifiedRounds+=1,await api.db.update("witnesses",witness),await manageWitnessesSchedule()}}}}},actions.scheduleWitnesses=async()=>{"null"===api.sender&&await manageWitnessesSchedule()};