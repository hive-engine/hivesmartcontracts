const NB_APPROVALS_ALLOWED = 30; const NB_TOP_WITNESSES = 20; const NB_BACKUP_WITNESSES = 1; const NB_WITNESSES = 21; const NB_WITNESSES_SIGNATURES_REQUIRED = 14; const MAX_ROUNDS_MISSED_IN_A_ROW = 3; const MAX_ROUND_PROPOSITION_WAITING_PERIOD = 40; const NB_TOKENS_TO_REWARD_PER_BLOCK = '0.01902586'; const NB_TOKENS_NEEDED_BEFORE_REWARDING = '0.39954306'; const WITNESS_APPROVE_EXPIRE_BLOCKS = 5184e3; const WITNESS_MAX_ACCOUNT_EXPIRE_PER_BLOCK = 10; const UTILITY_TOKEN_SYMBOL = "'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"; const UTILITY_TOKEN_PRECISION = '${CONSTANTS.UTILITY_TOKEN_PRECISION}$'; const GOVERNANCE_TOKEN_SYMBOL = "'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"; const GOVERNANCE_TOKEN_PRECISION = '${CONSTANTS.GOVERNANCE_TOKEN_PRECISION}$'; const GOVERNANCE_TOKEN_MIN_VALUE = "'${CONSTANTS.GOVERNANCE_TOKEN_MIN_VALUE}$'"; const recalcTotalEnabledApprovalWeight = async () => { let wits; let totalEnabledApprovalWeight = '0'; let offset = 0; do { wits = await api.db.find('witnesses', {}, 1e3, offset, [{ index: '_id', descending: !1 }]); for (let i = 0; i < wits.length; i += 1) { const wit = wits[i]; wit.enabled && (totalEnabledApprovalWeight = api.BigNumber(totalEnabledApprovalWeight).plus(wit.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION)); }offset += 1e3; } while (wits.length === 1e3);return totalEnabledApprovalWeight; }; actions.createSSC = async () => {
  if (!1 === await api.db.tableExists('witnesses')) {
    await api.db.createTable('witnesses', ['approvalWeight']), await api.db.createTable('approvals', ['from', 'to']), await api.db.createTable('accounts', ['account']), await api.db.createTable('schedules'), await api.db.createTable('params'); const params = {
      totalApprovalWeight: '0', totalEnabledApprovalWeight: '0', numberOfApprovedWitnesses: 0, lastVerifiedBlockNumber: 0, round: 0, lastBlockRound: 0, currentWitness: null, blockNumberWitnessChange: 0, lastWitnesses: [], numberOfApprovalsPerAccount: 30, numberOfTopWitnesses: 20, numberOfWitnessSlots: 21, witnessSignaturesRequired: 14, maxRoundsMissedInARow: 3, maxRoundPropositionWaitingPeriod: 40, witnessApproveExpireBlocks: 5184e3,
    }; await api.db.insert('params', params);
  } else { const params = await api.db.findOne('params', {}); params.totalEnabledApprovalWeight && params.totalEnabledApprovalWeight !== 'NaN' || (params.totalEnabledApprovalWeight = await recalcTotalEnabledApprovalWeight(), await api.db.update('params', params)); }
}, actions.resetSchedule = async () => { if (api.sender !== api.owner) return; const schedules = await api.db.find('schedules', {}); for (let index = 0; index < schedules.length; index += 1) { const schedule = schedules[index]; await api.db.remove('schedules', schedule); } const params = await api.db.findOne('params', {}); params.currentWitness = null, params.blockNumberWitnessChange = 0, params.lastWitnesses = [], params.totalEnabledApprovalWeight = await recalcTotalEnabledApprovalWeight(), await api.db.update('params', params); }, actions.recalculateApprovals = async (payload) => { if (api.sender !== api.owner) return; const witnessRec = await api.db.findOne('witnesses', { account: payload.witness }); if (!witnessRec) return; let newApprovalWeight = api.BigNumber(0); const approvals = await api.db.find('approvals', { to: payload.witness }); for (let i = 0; i < approvals.length; i += 1) { const approval = approvals[i]; const account = await api.db.findOne('accounts', { account: approval.from }); account && (newApprovalWeight = api.BigNumber(newApprovalWeight).plus(account.approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION)); } const oldApprovalWeight = witnessRec.approvalWeight.$numberDecimal; const deltaApprovalWeight = api.BigNumber(newApprovalWeight).minus(oldApprovalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION); await updateWitnessRank(payload.witness, deltaApprovalWeight); }, actions.updateParams = async (payload) => {
  if (api.sender !== api.owner) return; const {
    numberOfApprovalsPerAccount, numberOfTopWitnesses, numberOfWitnessSlots, witnessSignaturesRequired, maxRoundsMissedInARow, maxRoundPropositionWaitingPeriod, witnessApproveExpireBlocks,
  } = payload; const params = await api.db.findOne('params', {}); let shouldResetSchedule = !1; numberOfApprovalsPerAccount && Number.isInteger(numberOfApprovalsPerAccount) && (params.numberOfApprovalsPerAccount = numberOfApprovalsPerAccount), numberOfTopWitnesses && Number.isInteger(numberOfTopWitnesses) && (params.numberOfTopWitnesses = numberOfTopWitnesses), numberOfWitnessSlots && Number.isInteger(numberOfWitnessSlots) && params.numberOfWitnessSlots !== numberOfWitnessSlots && (shouldResetSchedule = !0, params.numberOfWitnessSlots = numberOfWitnessSlots), witnessSignaturesRequired && Number.isInteger(witnessSignaturesRequired) && (params.witnessSignaturesRequired = witnessSignaturesRequired), maxRoundsMissedInARow && Number.isInteger(maxRoundsMissedInARow) && (params.maxRoundsMissedInARow = maxRoundsMissedInARow), maxRoundPropositionWaitingPeriod && Number.isInteger(maxRoundPropositionWaitingPeriod) && (params.maxRoundPropositionWaitingPeriod = maxRoundPropositionWaitingPeriod), api.assert(params.numberOfTopWitnesses + 1 === params.numberOfWitnessSlots, 'only 1 backup allowed') && (witnessApproveExpireBlocks && Number.isInteger(witnessApproveExpireBlocks) && api.assert(witnessApproveExpireBlocks > params.numberOfWitnessSlots, 'witnessApproveExpireBlocks should be greater than numberOfWitnessSlots') && (params.witnessApproveExpireBlocks = witnessApproveExpireBlocks), await api.db.update('params', params), shouldResetSchedule && await actions.resetSchedule());
}; const updateWitnessRank = async (witness, approvalWeight) => { const witnessRec = await api.db.findOne('witnesses', { account: witness }); if (witnessRec) { const oldApprovalWeight = witnessRec.approvalWeight.$numberDecimal; witnessRec.approvalWeight.$numberDecimal = api.BigNumber(witnessRec.approvalWeight.$numberDecimal).plus(approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION), api.BigNumber(witnessRec.approvalWeight.$numberDecimal).lt(0) && (witnessRec.approvalWeight.$numberDecimal = api.BigNumber(0)), await api.db.update('witnesses', witnessRec); const params = await api.db.findOne('params', {}); params.totalApprovalWeight = api.BigNumber(params.totalApprovalWeight).plus(approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION), witnessRec.enabled && (params.totalEnabledApprovalWeight = api.BigNumber(params.totalEnabledApprovalWeight).plus(approvalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION)), api.BigNumber(oldApprovalWeight).eq(0) && api.BigNumber(witnessRec.approvalWeight.$numberDecimal).gt(0) ? params.numberOfApprovedWitnesses += 1 : api.BigNumber(oldApprovalWeight).gt(0) && api.BigNumber(witnessRec.approvalWeight.$numberDecimal).eq(0) && (params.numberOfApprovedWitnesses -= 1), await api.db.update('params', params); } }; actions.updateWitnessesApprovals = async (payload) => { const { account, callingContractInfo } = payload; if (void 0 === callingContractInfo) return; if (callingContractInfo.name !== 'tokens') return; const acct = await api.db.findOne('accounts', { account }); if (acct !== null) { const balance = await api.db.findOneInTable('tokens', 'balances', { account, symbol: GOVERNANCE_TOKEN_SYMBOL }); let approvalWeight = 0; balance && balance.stake && (approvalWeight = balance.stake), balance && balance.delegationsIn && (approvalWeight = api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION)); const oldApprovalWeight = acct.approvalWeight; const deltaApprovalWeight = api.BigNumber(approvalWeight).minus(oldApprovalWeight).toFixed(GOVERNANCE_TOKEN_PRECISION); if (acct.approvalWeight = approvalWeight, !api.BigNumber(deltaApprovalWeight).eq(0)) { await api.db.update('accounts', acct); const approvals = await api.db.find('approvals', { from: account }); for (let index = 0; index < approvals.length; index += 1) { const approval = approvals[index]; await updateWitnessRank(approval.to, deltaApprovalWeight); } } } }, actions.register = async (payload) => {
  const {
    domain, IP, RPCPort, P2PPort, signingKey, enabled, isSignedWithActiveKey,
  } = payload; if (api.assert(!0 === isSignedWithActiveKey, 'active key required') && api.assert(domain || IP, 'neither domain nor ip provided') && api.assert(!(domain && IP), 'both domain and ip provided') && (domain && api.assert(domain && typeof domain === 'string' && api.validator.isFQDN(domain), 'domain is invalid') || IP && api.assert(IP && typeof IP === 'string' && api.validator.isIP(IP), 'IP is invalid')) && api.assert(RPCPort && Number.isInteger(RPCPort) && RPCPort >= 0 && RPCPort <= 65535, 'RPCPort must be an integer between 0 and 65535') && api.assert(P2PPort && Number.isInteger(P2PPort) && P2PPort >= 0 && P2PPort <= 65535, 'P2PPort must be an integer between 0 and 65535') && api.assert(api.validator.isAlphanumeric(signingKey) && signingKey.length === 53, 'invalid signing key') && api.assert(typeof enabled === 'boolean', 'enabled must be a boolean')) {
    let witness = await api.db.findOne('witnesses', { signingKey }); if (api.assert(witness === null || witness.account === api.sender, 'a witness is already using this signing key') && (witness = IP ? await api.db.findOne('witnesses', { IP, P2PPort }) : await api.db.findOne('witnesses', { domain, P2PPort }), api.assert(witness === null || witness.account === api.sender, `a witness is already using this ${IP ? 'IP' : 'domain'}/Port`))) {
      if (witness = await api.db.findOne('witnesses', { account: api.sender }), witness) { const enabledChanged = witness.enabled !== enabled; let useUnsets = !1; const unsets = {}; IP ? (witness.IP = IP, witness.domain && (delete witness.domain, unsets.domain = '', useUnsets = !0)) : (witness.domain = domain, witness.IP && (delete witness.IP, unsets.IP = '', useUnsets = !0)), witness.RPCPort = RPCPort, witness.P2PPort = P2PPort, witness.signingKey = signingKey, witness.enabled = enabled, useUnsets ? await api.db.update('witnesses', witness, unsets) : await api.db.update('witnesses', witness); const params = await api.db.findOne('params', {}); enabledChanged && witness.enabled ? params.totalEnabledApprovalWeight = api.BigNumber(params.totalEnabledApprovalWeight).plus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION) : enabledChanged && !witness.enabled && (params.totalEnabledApprovalWeight = api.BigNumber(params.totalEnabledApprovalWeight).minus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION)), await api.db.update('params', params); } else {
        witness = {
          account: api.sender, approvalWeight: { $numberDecimal: '0' }, signingKey, RPCPort, P2PPort, enabled, missedRounds: 0, missedRoundsInARow: 0, verifiedRounds: 0, lastRoundVerified: null, lastBlockVerified: null,
        }, IP ? witness.IP = IP : witness.domain = domain, await api.db.insert('witnesses', witness);
      }
    }
  }
}; const removeApproval = async (approval, acct, blnce, manual = !0) => { if (api.assert(approval !== null, 'you have not approved this witness')) { const { from, to } = approval; let account = acct; acct && acct.account === from || (account = await api.db.findOne('accounts', { account: from })), await api.db.remove('approvals', approval); let balance = blnce; balance || (balance = await api.db.findOneInTable('tokens', 'balances', { account: from, symbol: GOVERNANCE_TOKEN_SYMBOL })); let approvalWeight = 0; balance && balance.stake && (approvalWeight = balance.stake), balance && balance.delegationsIn && (approvalWeight = api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION)), manual && (account.approvals -= 1, account.approvalWeight = approvalWeight, account.lastApproveBlock = api.blockNumber, await api.db.update('accounts', account)), await updateWitnessRank(to, `-${approvalWeight}`), api.emit('witnessApprovalRemoved', { account: from, to, approvalWeight }); } }; actions.approve = async (payload) => {
  const { witness } = payload; const params = await api.db.findOne('params', {}); if (api.assert(witness && typeof witness === 'string' && witness.length >= 3 && witness.length <= 16, 'invalid witness account')) {
    const witnessRec = await api.db.findOne('witnesses', { account: witness }); if (api.assert(witnessRec, 'witness does not exist')) {
      let acct = await api.db.findOne('accounts', { account: api.sender }); if (acct === null && (acct = {
        account: api.sender, approvals: 0, approvalWeight: { $numberDecimal: '0' }, lastApproveBlock: api.blockNumber,
      }, acct = await api.db.insert('accounts', acct)), api.assert(acct.approvals < params.numberOfApprovalsPerAccount, `you can only approve ${params.numberOfApprovalsPerAccount} witnesses`)) { let approval = await api.db.findOne('approvals', { from: api.sender, to: witness }); if (api.assert(approval === null, 'you already approved this witness')) { approval = { from: api.sender, to: witness }, await api.db.insert('approvals', approval); const balance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: GOVERNANCE_TOKEN_SYMBOL }); let approvalWeight = 0; balance && balance.stake && (approvalWeight = balance.stake), balance && balance.delegationsIn && (approvalWeight = api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION)), acct.approvals += 1, acct.approvalWeight = approvalWeight, acct.lastApproveBlock = api.blockNumber, await api.db.update('accounts', acct), await updateWitnessRank(witness, approvalWeight), api.emit('witnessApprovalAdded', { account: api.sender, to: witness, approvalWeight }); } }
    }
  }
}, actions.disapprove = async (payload) => {
  const { witness } = payload; if (api.assert(witness && typeof witness === 'string' && witness.length >= 3 && witness.length <= 16, 'invalid witness account')) {
    const witnessRec = await api.db.findOne('witnesses', { account: witness }); if (api.assert(witnessRec, 'witness does not exist')) {
      let acct = await api.db.findOne('accounts', { account: api.sender }); if (acct === null && (acct = {
        account: api.sender, approvals: 0, approvalWeight: { $numberDecimal: '0' }, lastApproveBlock: api.blockNumber,
      }, await api.db.insert('accounts', acct)), api.assert(acct.approvals > 0, 'no approvals found')) { const approval = await api.db.findOne('approvals', { from: acct.account, to: witness }); const balance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: GOVERNANCE_TOKEN_SYMBOL }); await removeApproval(approval, acct, balance, !0); }
    }
  }
}; const expireAllUserApprovals = async (acct) => { const approvals = await api.db.find('approvals', { from: acct.account }); const balance = await api.db.findOneInTable('tokens', 'balances', { account: acct.account, symbol: GOVERNANCE_TOKEN_SYMBOL }); for (let i = 0; i < approvals.length; i += 1) { const approval = approvals[i]; await removeApproval(approval, acct, balance, !1); } let approvalWeight = 0; balance && balance.stake && (approvalWeight = balance.stake), balance && balance.delegationsIn && (approvalWeight = api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(GOVERNANCE_TOKEN_PRECISION)); const account = acct; account.approvals = 0, account.approvalWeight = approvalWeight, await api.db.update('accounts', account), api.emit('witnessApprovalsExpired', { account: acct.account }); }; const findAndExpireApprovals = async (witnessApproveExpireBlocks) => { const accounts = await api.db.find('accounts', { lastApproveBlock: { $lt: api.blockNumber - witnessApproveExpireBlocks }, approvals: { $gt: 0 } }, 10, 0, [{ index: 'lastApproveBlock', descending: !1 }]); for (let i = 0; i < accounts.length; i += 1) await expireAllUserApprovals(accounts[i]); }; const changeCurrentWitness = async () => {
  const params = await api.db.findOne('params', {}); const {
    currentWitness, totalEnabledApprovalWeight, lastWitnesses, lastBlockRound, round, maxRoundsMissedInARow, maxRoundPropositionWaitingPeriod, lastVerifiedBlockNumber,
  } = params; let witnessFound = !1; const random = api.random(); const randomWeight = api.BigNumber(totalEnabledApprovalWeight).times(random).toFixed(GOVERNANCE_TOKEN_PRECISION, 1); let offset = 0; let accWeight = 0; let witnesses = await api.db.find('witnesses', { approvalWeight: { $gt: { $numberDecimal: '0' } }, enabled: !0 }, 100, offset, [{ index: 'approvalWeight', descending: !0 }]); const schedules = await api.db.find('schedules', { round }); const currentWitnessSchedule = schedules.find((s => s.witness === currentWitness)); const previousRoundWitness = lastWitnesses.length > 1 ? lastWitnesses[lastWitnesses.length - 2] : ''; do { for (let index = 0; index < witnesses.length; index += 1) { const witness = witnesses[index]; if (accWeight = api.BigNumber(accWeight).plus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION), !0 === witness.enabled && witness.account !== previousRoundWitness && void 0 === schedules.find((s => s.witness === witness.account)) && api.BigNumber(randomWeight).lte(accWeight)) { let witnessToChange = currentWitness; if (currentWitnessSchedule.verifiedRound) for (let index = 0; index < schedules.length; index += 1)schedules[index].verifiedRound || (witnessToChange = schedules[index].witness); api.debug(`changed witness from ${witnessToChange} to ${witness.account}`), api.emit('witnessChanged', { removed: witnessToChange, added: witness.account }); const newWitnessOrder = [witness.account]; for (let index = 0; index < schedules.length; index += 1) { const schedule = schedules[index]; schedule.witness !== witnessToChange && newWitnessOrder.push(schedule.witness), await api.db.remove('schedules', schedule); } let blockNumber = lastVerifiedBlockNumber === 0 ? api.blockNumber : lastVerifiedBlockNumber + 1; for (let i = 0; i < newWitnessOrder.length; i += 1) { const newSchedule = { witness: newWitnessOrder[i], blockNumber, round }; await api.db.insert('schedules', newSchedule), blockNumber += 1; } if (params.currentWitness !== newWitnessOrder[newWitnessOrder.length - 1] && (params.currentWitness = newWitnessOrder[newWitnessOrder.length - 1], params.lastWitnesses.push(newWitnessOrder[newWitnessOrder.length - 1])), params.blockNumberWitnessChange = api.blockNumber + maxRoundPropositionWaitingPeriod, !currentWitnessSchedule.verifiedRound) { const scheduledWitness = await api.db.findOne('witnesses', { account: currentWitness }); scheduledWitness.missedRounds += 1, scheduledWitness.missedRoundsInARow += 1, api.emit('witnessMissedRound', { witness: scheduledWitness.account }), scheduledWitness.missedRoundsInARow >= maxRoundsMissedInARow && (scheduledWitness.missedRoundsInARow = 0, scheduledWitness.enabled && (params.totalEnabledApprovalWeight = api.BigNumber(params.totalEnabledApprovalWeight).minus(scheduledWitness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION)), scheduledWitness.enabled = !1, api.emit('witnessDisabledForMissingTooManyRoundsInARow', { witness: scheduledWitness.account })), await api.db.update('witnesses', scheduledWitness); } await api.db.update('params', params), witnessFound = !0; break; } }!1 === witnessFound && (offset += 100, witnesses = await api.db.find('witnesses', { approvalWeight: { $gt: { $numberDecimal: '0' } } }, 100, offset, [{ index: 'approvalWeight', descending: !0 }])); } while (witnesses.length > 0 && !1 === witnessFound);if (!1 === witnessFound) { api.debug('no backup witness was found, interchanging witnesses within the current schedule'); for (let index = 0; index < schedules.length - 1; index += 1) { const sched = schedules[index]; const newWitness = sched.witness; if (newWitness !== previousRoundWitness) { api.debug(`changed current witness from ${currentWitness} to ${newWitness}`), schedule.witness = newWitness, await api.db.update('schedules', schedule), sched.witness = currentWitness, await api.db.update('schedules', sched), params.currentWitness = newWitness, params.lastWitnesses.push(newWitness), params.blockNumberWitnessChange = api.blockNumber + maxRoundPropositionWaitingPeriod; const scheduledWitness = await api.db.findOne('witnesses', { account: currentWitness }); scheduledWitness.missedRounds += 1, scheduledWitness.missedRoundsInARow += 1, api.emit('witnessMissedRound', { witness: scheduledWitness.account }), scheduledWitness.missedRoundsInARow >= maxRoundsMissedInARow && (scheduledWitness.missedRoundsInARow = 0, scheduledWitness.enabled && (params.totalEnabledApprovalWeight = api.BigNumber(params.totalEnabledApprovalWeight).minus(scheduledWitness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION)), scheduledWitness.enabled = !1, api.emit('witnessDisabledForMissingTooManyRoundsInARow', { witness: scheduledWitness.account })), await api.db.update('params', params), await api.db.update('witnesses', scheduledWitness), api.emit('currentWitnessChanged', {}); break; } } }
}; const manageWitnessesSchedule = async () => {
  if (api.sender !== 'null') return; const params = await api.db.findOne('params', {}); const {
    numberOfApprovedWitnesses, totalEnabledApprovalWeight, lastVerifiedBlockNumber, blockNumberWitnessChange, lastBlockRound, numberOfTopWitnesses, numberOfWitnessSlots, maxRoundPropositionWaitingPeriod, witnessApproveExpireBlocks,
  } = params; await findAndExpireApprovals(witnessApproveExpireBlocks); const currentBlock = lastVerifiedBlockNumber + 1; let schedule = await api.db.findOne('schedules', { blockNumber: currentBlock }); if (schedule === null) { if (api.debug('calculating new schedule'), schedule = [], numberOfApprovedWitnesses >= numberOfWitnessSlots) { const random = api.random(); let randomWeight = null; let offset = 0; let accWeight = 0; let witnesses = await api.db.find('witnesses', { approvalWeight: { $gt: { $numberDecimal: '0' } }, enabled: !0 }, 100, offset, [{ index: 'approvalWeight', descending: !0 }]); do { for (let index = 0; index < witnesses.length; index += 1) { const witness = witnesses[index]; schedule.length >= numberOfTopWitnesses && randomWeight === null && (randomWeight = api.BigNumber(accWeight).plus(GOVERNANCE_TOKEN_MIN_VALUE).plus(api.BigNumber(totalEnabledApprovalWeight).minus(accWeight).times(random).toFixed(GOVERNANCE_TOKEN_PRECISION, 1)).toFixed(GOVERNANCE_TOKEN_PRECISION)), accWeight = api.BigNumber(accWeight).plus(witness.approvalWeight.$numberDecimal).toFixed(GOVERNANCE_TOKEN_PRECISION), !0 === witness.enabled && (schedule.length < numberOfTopWitnesses || api.BigNumber(randomWeight).lte(accWeight)) && schedule.push({ witness: witness.account, blockNumber: null }), schedule.length >= numberOfWitnessSlots && (index = witnesses.length); }schedule.length < numberOfWitnessSlots && (offset += 100, witnesses = await api.db.find('witnesses', { approvalWeight: { $gt: { $numberDecimal: '0' } } }, 100, offset, [{ index: 'approvalWeight', descending: !0 }])); } while (witnesses.length > 0 && schedule.length < numberOfWitnessSlots); } if (schedule.length === numberOfWitnessSlots) { let j; let x; for (let i = schedule.length - 1; i > 0; i -= 1) { const random = api.random(); j = Math.floor(random * (i + 1)), x = schedule[i], schedule[i] = schedule[j], schedule[j] = x; } let { lastWitnesses } = params; const previousRoundWitness = lastWitnesses.length > 0 ? lastWitnesses[lastWitnesses.length - 1] : ''; lastWitnesses.length >= numberOfWitnessSlots && (lastWitnesses = []); const lastWitness = schedule[schedule.length - 1].witness; if (lastWitnesses.includes(lastWitness) || previousRoundWitness === lastWitness) for (let i = 0; i < schedule.length; i += 1) if (!lastWitnesses.includes(schedule[i].witness) && schedule[i].witness !== previousRoundWitness) { const thisWitness = schedule[i].witness; schedule[i].witness = lastWitness, schedule[schedule.length - 1].witness = thisWitness; break; } if (schedule[0].witness === previousRoundWitness) { const firstWitness = schedule[0].witness; const secondWitness = schedule[1].witness; schedule[0].witness = secondWitness, schedule[1].witness = firstWitness; } let blockNumber = lastVerifiedBlockNumber === 0 ? api.blockNumber : lastVerifiedBlockNumber + 1; params.round += 1; for (let i = 0; i < schedule.length; i += 1)schedule[i].blockNumber = blockNumber, schedule[i].round = params.round, api.debug(`scheduled witness ${schedule[i].witness} for block ${blockNumber} (round ${params.round})`), await api.db.insert('schedules', schedule[i]), blockNumber += 1; lastVerifiedBlockNumber === 0 && (params.lastVerifiedBlockNumber = api.blockNumber - 1); const lastWitnessRoundSchedule = schedule[schedule.length - 1]; params.lastBlockRound = lastWitnessRoundSchedule.blockNumber, params.currentWitness = lastWitnessRoundSchedule.witness, lastWitnesses.push(lastWitnessRoundSchedule.witness), params.lastWitnesses = lastWitnesses, params.blockNumberWitnessChange = api.blockNumber + maxRoundPropositionWaitingPeriod, await api.db.update('params', params), api.emit('newSchedule', {}); } } else api.blockNumber >= blockNumberWitnessChange && (api.blockNumber > lastBlockRound ? await changeCurrentWitness() : (params.blockNumberWitnessChange = api.blockNumber + maxRoundPropositionWaitingPeriod, await api.db.update('params', params), api.emit('awaitingRoundEnd', {})));
}; actions.proposeRound = async (payload) => {
  const { roundHash, isSignedWithActiveKey, signatures } = payload; const params = await api.db.findOne('params', {}); const {
    lastVerifiedBlockNumber, round, lastBlockRound, currentWitness,
  } = params; const schedules = await api.db.find('schedules', { round }, 1e3, 0, [{ index: '_id', descending: !1 }]); if (!api.assert(schedules && schedules.length > 0, 'invalid round')) return; const numberOfWitnessSlots = schedules.length; const { witnessSignaturesRequired } = params; if (!api.assert(isSignedWithActiveKey, 'you must use a transaction signed with your active key')) return; if (!api.assert(roundHash && typeof roundHash === 'string' && roundHash.length === 64, 'invalid round hash')) return; if (!api.assert(Array.isArray(signatures) && signatures.length <= numberOfWitnessSlots, 'invalid signatures')) return; let currentBlock = lastVerifiedBlockNumber + 1; let calculatedRoundHash = ''; if (!api.assert(api.sender === currentWitness, 'must be current witness')) return; for (;currentBlock <= lastBlockRound;) { const block = await api.db.getBlockInfo(currentBlock); if (block === null) { calculatedRoundHash = ''; break; }calculatedRoundHash = api.SHA256(`${calculatedRoundHash}${block.hash}`), currentBlock += 1; } if (!api.assert(calculatedRoundHash !== '' && calculatedRoundHash === roundHash, 'round hash mismatch')) return; let signaturesChecked = 0; const verifiedBlockInformation = []; const currentWitnessInfo = await api.db.findOne('witnesses', { account: currentWitness }); const currentWitnessSignature = signatures.find((s => s[0] === currentWitness)); for (let index = 0; index < schedules.length; index += 1) {
    const scheduledWitness = schedules[index]; const witness = await api.db.findOne('witnesses', { account: scheduledWitness.witness }); if (witness !== null) {
      const signature = signatures.find((s => s[0] === witness.account)); signature && api.checkSignature(calculatedRoundHash, signature[1], witness.signingKey, !0) && (api.debug(`witness ${witness.account} signed round ${round}`), signaturesChecked += 1, scheduledWitness.verifiedRound = !0, await api.db.update('schedules', scheduledWitness)), verifiedBlockInformation.push({
        blockNumber: scheduledWitness.blockNumber, witness: currentWitness, signingKey: currentWitnessInfo.signingKey, roundSignature: currentWitnessSignature[1], round, roundHash,
      });
    }
  } if (!api.assert(signaturesChecked >= witnessSignaturesRequired, 'valid round hash but not enough signatures')) return; for (let index = 0; index < verifiedBlockInformation.length; index += 1) await api.verifyBlock(verifiedBlockInformation[index]); for (let index = 0; index < schedules.length; index += 1) { const schedule = schedules[index]; await api.db.remove('schedules', schedule); } const contractBalance = await api.db.findOneInTable('tokens', 'contractsBalances', { account: 'witnesses', symbol: UTILITY_TOKEN_SYMBOL }); if (contractBalance && api.BigNumber(contractBalance.balance).gte('0.39954306')) { const rewardAmount = api.BigNumber('0.01902586').multipliedBy(numberOfWitnessSlots).toFixed(UTILITY_TOKEN_PRECISION); await api.executeSmartContract('tokens', 'stakeFromContract', { to: currentWitness, symbol: UTILITY_TOKEN_SYMBOL, quantity: rewardAmount }); }params.currentWitness = null, params.lastVerifiedBlockNumber = lastBlockRound, await api.db.update('params', params); const witness = await api.db.findOne('witnesses', { account: currentWitness }); witness.missedRoundsInARow = 0, witness.lastRoundVerified = round, witness.lastBlockVerified = lastBlockRound, witness.verifiedRounds += 1, await api.db.update('witnesses', witness), await manageWitnessesSchedule();
}, actions.scheduleWitnesses = async () => { api.sender === 'null' && await manageWitnessesSchedule(); };
