const ACCOUNT_BLACKLIST={gateiodeposit:1,deepcrypto8:1,bittrex:1,poloniex:1,"huobi-pro":1,"binance-hot":1,bitvavo:1,blocktrades:1,probitsteem:1,probithive:1,ionomy:1,mxchive:1,coinbasebase:1,orinoco:1,"user.dunamu":1},HE_ACCOUNTS={"hive-engine":1,"swap-eth":1,"btc-swap":1,"graphene-swap":1,"honey-swap":1},RESERVED_SYMBOLS={ENG:"null",STEEMP:"steem-peg",BTCP:"btcpeg",LTCP:"ltcp",DOGEP:"dogep",BCHP:"bchp",SMTT:"steemmonsters",EM:"steem-eng",EMFOUR:"steem-eng",HIVEP:"steem-tokens",GLINT:"steemmonsters"},VERIFIED_ISSUERS=["comments","mining","tokenfunds","beedollar","burndollar"],calculateBalance=(balance,quantity,precision,add)=>add?api.BigNumber(balance).plus(quantity).toFixed(precision):api.BigNumber(balance).minus(quantity).toFixed(precision),countDecimals=value=>api.BigNumber(value).dp(),findAndProcessAll=async(table,query,callback)=>{let offset=0,results=[],done=!1;for(;!done;)if(results=await api.db.find(table,query,1e3,offset),results){for(let i=0;i<results.length;i+=1)await callback(results[i]);results.length<1e3?done=!0:offset+=1e3}};actions.createSSC=async()=>{if(!1===await api.db.tableExists("tokens")){await api.db.createTable("tokens",["symbol"]),await api.db.createTable("balances",["account"]),await api.db.createTable("contractsBalances",["account"]),await api.db.createTable("params"),await api.db.createTable("pendingUnstakes",["account","unstakeCompleteTimestamp"]),await api.db.createTable("delegations",["from","to"]),await api.db.createTable("pendingUndelegations",["account","completeTimestamp"]);const params={tokenCreationFee:"0",enableDelegationFee:"0",enableStakingFee:"0"};await api.db.insert("params",params)}else{const params=await api.db.findOne("params",{});if(!params.blacklist){params.blacklist=ACCOUNT_BLACKLIST,params.heAccounts=HE_ACCOUNTS;const unsets={};let useUnsets=!1;params.fixMultiTxUnstakeBalance&&(delete params.fixMultiTxUnstakeBalance,unsets.fixMultiTxUnstakeBalance="",useUnsets=!0),params.cancelBadUnstakes&&(delete params.cancelBadUnstakes,unsets.cancelBadUnstakes="",useUnsets=!0),useUnsets?await api.db.update("params",params,unsets):await api.db.update("params",params)}}};const balanceTemplate={account:null,symbol:null,balance:"0",stake:"0",pendingUnstake:"0",delegationsIn:"0",delegationsOut:"0",pendingUndelegations:"0"},addStake=async(account,token,quantity)=>{let balance=await api.db.findOne("balances",{account:account,symbol:token.symbol});null===balance&&(balance=balanceTemplate,balance.account=account,balance.symbol=token.symbol,balance=await api.db.insert("balances",balance)),void 0===balance.stake&&(balance.stake="0",balance.pendingUnstake="0");const originalStake=balance.stake;return balance.stake=calculateBalance(balance.stake,quantity,token.precision,!0),!!api.assert(api.BigNumber(balance.stake).gt(originalStake),"cannot add")&&(await api.db.update("balances",balance),void 0===token.totalStaked&&(token.totalStaked="0"),token.totalStaked=calculateBalance(token.totalStaked,quantity,token.precision,!0),await api.db.update("tokens",token),!0)},subBalance=async(account,token,quantity,table)=>{const balance=await api.db.findOne(table,{account:account,symbol:token.symbol});if(api.assert(null!==balance,"balance does not exist")&&api.assert(api.BigNumber(balance.balance).gte(quantity),"overdrawn balance")){const originalBalance=balance.balance;if(balance.balance=calculateBalance(balance.balance,quantity,token.precision,!1),api.assert(api.BigNumber(balance.balance).lt(originalBalance),"cannot subtract"))return await api.db.update(table,balance),!0}return!1},addBalance=async(account,token,quantity,table)=>{let balance=await api.db.findOne(table,{account:account,symbol:token.symbol});if(null===balance)return balance=balanceTemplate,balance.account=account,balance.symbol=token.symbol,balance.balance=quantity,await api.db.insert(table,balance),!0;const originalBalance=balance.balance;return balance.balance=calculateBalance(balance.balance,quantity,token.precision,!0),!!api.assert(api.BigNumber(balance.balance).gt(originalBalance),"cannot add")&&(await api.db.update(table,balance),!0)};actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{tokenCreationFee:tokenCreationFee,enableDelegationFee:enableDelegationFee,enableStakingFee:enableStakingFee,blacklist:blacklist,heAccounts:heAccounts}=payload,params=await api.db.findOne("params",{});tokenCreationFee&&"string"==typeof tokenCreationFee&&!api.BigNumber(tokenCreationFee).isNaN()&&api.BigNumber(tokenCreationFee).gte(0)&&(params.tokenCreationFee=tokenCreationFee),enableDelegationFee&&"string"==typeof enableDelegationFee&&!api.BigNumber(enableDelegationFee).isNaN()&&api.BigNumber(enableDelegationFee).gte(0)&&(params.enableDelegationFee=enableDelegationFee),enableStakingFee&&"string"==typeof enableStakingFee&&!api.BigNumber(enableStakingFee).isNaN()&&api.BigNumber(enableStakingFee).gte(0)&&(params.enableStakingFee=enableStakingFee),blacklist&&"object"==typeof blacklist&&(params.blacklist=blacklist),heAccounts&&"object"==typeof heAccounts&&(params.heAccounts=heAccounts),await api.db.update("params",params)},actions.updateUrl=async payload=>{const{url:url,symbol:symbol}=payload;if(api.assert(symbol&&"string"==typeof symbol&&url&&"string"==typeof url,"invalid params")&&api.assert(url.length<=255,"invalid url: max length of 255")){const token=await api.db.findOne("tokens",{symbol:symbol});if(token&&api.assert(token.issuer===api.sender,"must be the issuer"))try{const metadata=JSON.parse(token.metadata);api.assert(metadata&&metadata.url,"an error occured when trying to update the url")&&(metadata.url=url,token.metadata=JSON.stringify(metadata),await api.db.update("tokens",token))}catch(e){}}},actions.updateMetadata=async payload=>{const{metadata:metadata,symbol:symbol,callingContractInfo:callingContractInfo}=payload,fromVerifiedContract="hive-engine"===api.sender&&callingContractInfo&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name);if(api.assert(symbol&&"string"==typeof symbol&&metadata&&"object"==typeof metadata,"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol});if(token&&api.assert(fromVerifiedContract||token.issuer===api.sender,"must be the issuer"))try{const finalMetadata=JSON.stringify(metadata);api.assert(finalMetadata.length<=1e3,"invalid metadata: max length of 1000")&&(token.metadata=finalMetadata,await api.db.update("tokens",token))}catch(e){}}},actions.updatePrecision=async payload=>{const{symbol:symbol,precision:precision,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol)&&api.assert(precision>0&&precision<=8&&Number.isInteger(precision),"invalid precision")){const token=await api.db.findOne("tokens",{symbol:symbol});token&&api.assert(token.issuer===api.sender,"must be the issuer")&&api.assert(precision>token.precision,"precision can only be increased")&&(token.precision=precision,await api.db.update("tokens",token))}},actions.transferOwnership=async payload=>{const{symbol:symbol,to:to,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to,"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol});if(token&&api.assert(token.issuer===api.sender,"must be the issuer")){const finalTo=to.trim();api.assert(api.isValidAccountName(finalTo),"invalid to")&&(token.issuer=finalTo,await api.db.update("tokens",token),api.emit("transferOwnership",{from:api.sender,to:finalTo,symbol:symbol}))}}},actions.create=async payload=>{const{name:name,symbol:symbol,url:url,precision:precision,maxSupply:maxSupply,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload,params=await api.db.findOne("params",{}),{tokenCreationFee:tokenCreationFee,heAccounts:heAccounts}=params,fromVerifiedContract=callingContractInfo&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name),utilityTokenBalance=fromVerifiedContract?null:await api.db.findOne("balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!fromVerifiedContract&&!api.BigNumber(tokenCreationFee).lte(0)&&1!==heAccounts[api.sender])||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(tokenCreationFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fees")&&api.assert(fromVerifiedContract||!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(name&&"string"==typeof name&&symbol&&"string"==typeof symbol&&(void 0===url||url&&"string"==typeof url)&&(precision&&"number"==typeof precision||0===precision)&&maxSupply&&"string"==typeof maxSupply&&!api.BigNumber(maxSupply).isNaN(),"invalid params")&&api.assert(symbol.length>0&&symbol.length<=10&&api.validator.isAlpha(api.validator.blacklist(symbol,"."))&&api.validator.isUppercase(symbol)&&(-1===symbol.indexOf(".")||symbol.indexOf(".")>0&&symbol.indexOf(".")<symbol.length-1&&symbol.indexOf(".")===symbol.lastIndexOf(".")),'invalid symbol: uppercase letters only and one "." allowed, max length of 10')&&api.assert(void 0===RESERVED_SYMBOLS[symbol]||api.sender===RESERVED_SYMBOLS[symbol],"cannot use this symbol")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf("SWAP"),"invalid symbol: not allowed to use SWAP")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf("ETH"),"invalid symbol: not allowed to use ETH")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf("BSC"),"invalid symbol: not allowed to use BSC")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf(".")||callingContractInfo&&"burndollar"===callingContractInfo.name,'invalid symbol: usage of "." is restricted')&&api.assert(api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=50,"invalid name: letters, numbers, whitespaces only, max length of 50")&&api.assert(void 0===url||url.length<=255,"invalid url: max length of 255")&&api.assert(precision>=0&&precision<=8&&Number.isInteger(precision),"invalid precision")&&api.assert(api.BigNumber(maxSupply).gt(0),"maxSupply must be positive")&&api.assert(api.BigNumber(maxSupply).lte(Number.MAX_SAFE_INTEGER),`maxSupply must be lower than ${Number.MAX_SAFE_INTEGER}`)){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null===token,"symbol already exists")){let metadata={url:void 0===url?"":url};metadata=JSON.stringify(metadata);const newToken={issuer:fromVerifiedContract?"null":api.sender,symbol:symbol,name:name,metadata:metadata,precision:precision,maxSupply:api.BigNumber(maxSupply).toFixed(precision),supply:"0",circulatingSupply:"0",stakingEnabled:!1,unstakingCooldown:1,delegationEnabled:!1,undelegationCooldown:0};await api.db.insert("tokens",newToken),api.BigNumber(tokenCreationFee).gt(0)&&void 0===heAccounts[api.sender]&&!fromVerifiedContract&&await actions.transfer({to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:tokenCreationFee,isSignedWithActiveKey:isSignedWithActiveKey})}}},actions.issue=async payload=>{const{to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload;let quantity=payload.quantity;const fromVerifiedContract="null"===api.sender&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name)||callingContractInfo&&"beedollar"===callingContractInfo.name||callingContractInfo&&"burndollar"===callingContractInfo.name;if(fromVerifiedContract||api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim(),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(fromVerifiedContract||token.issuer===api.sender,"not allowed to issue tokens")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must issue positive quantity")&&api.assert(api.BigNumber(token.maxSupply).minus(token.supply).gte(quantity),"quantity exceeds available supply")&&api.assert(api.isValidAccountName(finalTo),"invalid to")){quantity=api.BigNumber(quantity).toFixed(token.precision);let res=await addBalance(token.issuer,token,quantity,"balances");!0===res&&finalTo!==token.issuer&&await subBalance(token.issuer,token,quantity,"balances")&&(res=await addBalance(finalTo,token,quantity,"balances"),!1===res&&await addBalance(token.issuer,token,quantity,"balances")),!0===res&&(token.supply=calculateBalance(token.supply,quantity,token.precision,!0),"null"!==finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!0)),await api.db.update("tokens",token),api.emit("transferFromContract",{from:"tokens",to:finalTo,symbol:symbol,quantity:quantity}))}}},actions.issueToContract=async payload=>{const{to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload;let quantity=payload.quantity;const fromVerifiedContract="null"===api.sender&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name);if(fromVerifiedContract||api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim(),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(fromVerifiedContract||token.issuer===api.sender,"not allowed to issue tokens")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must issue positive quantity")&&api.assert(api.BigNumber(token.maxSupply).minus(token.supply).gte(quantity),"quantity exceeds available supply")&&api.assert(finalTo.length>=3&&finalTo.length<=50,"invalid to")){quantity=api.BigNumber(quantity).toFixed(token.precision);!0===await addBalance(finalTo,token,quantity,"contractsBalances")&&(token.supply=calculateBalance(token.supply,quantity,token.precision,!0),"null"!==finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!0)),await api.db.update("tokens",token),api.emit("issueToContract",{from:"tokens",to:finalTo,symbol:symbol,quantity:quantity}))}}},actions.transfer=async payload=>{const{to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim();if(api.assert(finalTo!==api.sender,"cannot transfer to self")){const params=await api.db.findOne("params",{}),{blacklist:blacklist}=params;if(api.assert(api.isValidAccountName(finalTo),"invalid to")&&api.assert(void 0===blacklist[finalTo],`not allowed to send to ${finalTo}`)){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must transfer positive quantity")&&await subBalance(api.sender,token,quantity,"balances")){return!1===await addBalance(finalTo,token,quantity,"balances")?(await addBalance(api.sender,token,quantity,"balances"),!1):("null"===finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!1),await api.db.update("tokens",token)),api.emit("transfer",{from:api.sender,to:finalTo,symbol:symbol,quantity:quantity}),!0)}}}}return!1},actions.transferToContract=async payload=>{const{from:from,to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;const finalFrom=void 0===from||"null"!==api.sender?api.sender:from;if(api.assert(!0===isSignedWithActiveKey||"null"===api.sender,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim().toLowerCase();if(api.assert(finalTo!==finalFrom,"cannot transfer to self")&&api.assert(finalTo.length>=3&&finalTo.length<=50,"invalid to")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must transfer positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(finalFrom,token,quantity,"balances"))){!1===await addBalance(finalTo,token,quantity,"contractsBalances")?await addBalance(finalFrom,token,quantity,"balances"):("null"===finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!1),await api.db.update("tokens",token)),api.emit("transferToContract",{from:finalFrom,to:finalTo,symbol:symbol,quantity:quantity}))}}}},actions.transferFromContract=async payload=>{if(api.assert("null"===api.sender,"not authorized")){const{from:from,to:to,symbol:symbol,type:type}=payload;let quantity=payload.quantity;const types=["user","contract"];if(api.assert(to&&"string"==typeof to&&from&&"string"==typeof from&&symbol&&"string"==typeof symbol&&type&&types.includes(type)&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim(),table="user"===type?"balances":"contractsBalances";if(api.assert("user"===type||"contract"===type&&finalTo!==from,"cannot transfer to self")){const toValid="user"===type?api.isValidAccountName(finalTo):finalTo.length>=3&&finalTo.length<=50;if(api.assert(!0===toValid,"invalid to")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must transfer positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(from,token,quantity,"contractsBalances"))){!1===await addBalance(finalTo,token,quantity,table)?await addBalance(from,token,quantity,"contractsBalances"):("null"===finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!1),await api.db.update("tokens",token)),api.emit("transferFromContract",{from:from,to:finalTo,symbol:symbol,quantity:quantity}))}}}}}};const processUnstake=async unstake=>{const{account:account,symbol:symbol,quantity:quantity,quantityLeft:quantityLeft,numberTransactionsLeft:numberTransactionsLeft}=unstake,newUnstake=unstake,balance=await api.db.findOne("balances",{account:account,symbol:symbol}),token=await api.db.findOne("tokens",{symbol:symbol});let tokensToRelease=0,nextTokensToRelease=0;if(api.assert(null!==balance,"balance does not exist")&&(1===numberTransactionsLeft?(tokensToRelease=quantityLeft,await api.db.remove("pendingUnstakes",unstake)):(tokensToRelease=api.BigNumber(quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN),newUnstake.quantityLeft=api.BigNumber(newUnstake.quantityLeft).minus(tokensToRelease).toFixed(token.precision),newUnstake.numberTransactionsLeft-=1,nextTokensToRelease=1===newUnstake.numberTransactionsLeft?newUnstake.quantityLeft:tokensToRelease,newUnstake.nextTransactionTimestamp=api.BigNumber(newUnstake.nextTransactionTimestamp).plus(newUnstake.millisecPerPeriod).toNumber(),await api.db.update("pendingUnstakes",newUnstake)),api.BigNumber(tokensToRelease).gt(0))){const originalBalance=balance.balance,originalPendingStake=balance.pendingUnstake;balance.balance=calculateBalance(balance.balance,tokensToRelease,token.precision,!0),balance.pendingUnstake=calculateBalance(balance.pendingUnstake,tokensToRelease,token.precision,!1),api.assert(api.BigNumber(balance.pendingUnstake).lt(originalPendingStake)&&api.BigNumber(balance.balance).gt(originalBalance),"cannot subtract")&&(api.BigNumber(nextTokensToRelease).gt(0)&&(balance.stake=calculateBalance(balance.stake,nextTokensToRelease,token.precision,!1),token.totalStaked=calculateBalance(token.totalStaked,nextTokensToRelease,token.precision,!1),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:symbol,quantity:api.BigNumber(nextTokensToRelease).negated()})),await api.db.update("balances",balance),await api.db.update("tokens",token),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token}),api.emit("unstake",{account:account,symbol:symbol,quantity:tokensToRelease}))}};actions.checkPendingUnstakes=async()=>{if(api.assert("null"===api.sender,"not authorized")){const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();let pendingUnstakes=await api.db.find("pendingUnstakes",{nextTransactionTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUnstakes=pendingUnstakes.length;for(;nbPendingUnstakes>0;){for(let index=0;index<nbPendingUnstakes;index+=1){const pendingUnstake=pendingUnstakes[index];await processUnstake(pendingUnstake)}pendingUnstakes=await api.db.find("pendingUnstakes",{nextTransactionTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUnstakes=pendingUnstakes.length}}},actions.enableStaking=async payload=>{const{symbol:symbol,unstakingCooldown:unstakingCooldown,numberTransactions:numberTransactions,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{enableStakingFee:enableStakingFee}=params,utilityTokenBalance=await api.db.findOne("balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),enoughFunds=utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(enableStakingFee),authorized=void 0===enableStakingFee||api.BigNumber(enableStakingFee).lte(0)||enoughFunds;if(api.assert(authorized,"you must have enough tokens to cover  fees")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol,"invalid symbol")&&api.assert(unstakingCooldown&&Number.isInteger(unstakingCooldown)&&unstakingCooldown>0&&unstakingCooldown<=18250,"unstakingCooldown must be an integer between 1 and 18250")&&api.assert(numberTransactions&&Number.isInteger(numberTransactions)&&numberTransactions>0&&numberTransactions<=18250,"numberTransactions must be an integer between 1 and 18250")){const token=await api.db.findOne("tokens",{symbol:symbol});api.assert(null!==token,"symbol does not exist")&&api.assert(token.issuer===api.sender,"must be the issuer")&&api.assert(void 0===token.stakingEnabled||!1===token.stakingEnabled,"staking already enabled")&&(token.stakingEnabled=!0,token.totalStaked="0",token.unstakingCooldown=unstakingCooldown,token.numberTransactions=numberTransactions,await api.db.update("tokens",token),api.BigNumber(enableStakingFee).gt(0)&&await actions.transfer({to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:enableStakingFee,isSignedWithActiveKey:isSignedWithActiveKey}))}},actions.stake=async payload=>{const{symbol:symbol,to:to,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol}),finalTo=to.trim();if(api.assert(api.isValidAccountName(finalTo),"invalid to")&&api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(api.BigNumber(quantity).gt(0),"must stake positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(api.sender,token,quantity,"balances"))){!1===await addStake(finalTo,token,quantity)?await addBalance(api.sender,token,quantity,"balances"):(api.emit("stake",{account:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo}),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token}))}}},actions.stakeFromContract=async payload=>{const{symbol:symbol,to:to,callingContractInfo:callingContractInfo}=payload;let quantity=payload.quantity;if(callingContractInfo&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol}),finalTo=to.trim();if(api.assert(api.isValidAccountName(finalTo),"invalid to")&&api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(api.BigNumber(quantity).gt(0),"must stake positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(callingContractInfo.name,token,quantity,"contractsBalances"))){!1===await addStake(finalTo,token,quantity)?await addBalance(callingContractInfo.name,token,quantity,"balances"):(api.emit("stakeFromContract",{account:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo}),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token}))}}};const validateAvailableStake=async(balance,token,quantity)=>{let availableStakeBalance=api.BigNumber(balance.stake);return await findAndProcessAll("pendingUnstakes",{symbol:balance.symbol,account:balance.account},(async pendingUnstake=>{if(pendingUnstake.numberTransactionsLeft>1){const tokensToRelease=api.BigNumber(pendingUnstake.quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN);availableStakeBalance=availableStakeBalance.minus(pendingUnstake.quantityLeft).plus(tokensToRelease)}})),api.assert(availableStakeBalance.gte(quantity),"overdrawn stake")},startUnstake=async(account,token,quantity)=>{const balance=await api.db.findOne("balances",{account:account,symbol:token.symbol});if(!api.assert(null!==balance,"balance does not exist")||!await validateAvailableStake(balance,token,quantity))return!1;{const originalStake=balance.stake,originalPendingStake=balance.pendingUnstake,nextTokensToRelease=token.numberTransactions>1?api.BigNumber(quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN):quantity;balance.stake=calculateBalance(balance.stake,nextTokensToRelease,token.precision,!1),balance.pendingUnstake=calculateBalance(balance.pendingUnstake,quantity,token.precision,!0),api.assert(api.BigNumber(balance.stake).lt(originalStake)&&api.BigNumber(balance.pendingUnstake).gt(originalPendingStake),"cannot subtract")&&(await api.db.update("balances",balance),token.totalStaked=calculateBalance(token.totalStaked,nextTokensToRelease,token.precision,!1),await api.db.update("tokens",token),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===token.symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:token.symbol,quantity:api.BigNumber(nextTokensToRelease).negated()}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token}))}const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),cooldownPeriodMillisec=24*token.unstakingCooldown*3600*1e3,millisecPerPeriod=api.BigNumber(cooldownPeriodMillisec).dividedBy(token.numberTransactions).integerValue(api.BigNumber.ROUND_DOWN),nextTransactionTimestamp=api.BigNumber(blockDate.getTime()).plus(millisecPerPeriod).toNumber(),unstake={account:account,symbol:token.symbol,quantity:quantity,quantityLeft:quantity,nextTransactionTimestamp:nextTransactionTimestamp,numberTransactionsLeft:token.numberTransactions,millisecPerPeriod:millisecPerPeriod,txID:api.transactionId};return await api.db.insert("pendingUnstakes",unstake),!0};actions.unstake=async payload=>{const{symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol});api.assert(null!==token,"symbol does not exist")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must unstake positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await startUnstake(api.sender,token,quantity)&&api.emit("unstakeStart",{account:api.sender,symbol:symbol,quantity:quantity}))}};const processCancelUnstake=async unstake=>{const{account:account,symbol:symbol,quantity:quantity,quantityLeft:quantityLeft,numberTransactionsLeft:numberTransactionsLeft}=unstake,balance=await api.db.findOne("balances",{account:account,symbol:symbol}),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==balance,"balance does not exist")&&api.assert(api.BigNumber(balance.pendingUnstake).gte(quantityLeft),"overdrawn pendingUnstake")){const originalStake=balance.stake,originalPendingStake=balance.pendingUnstake,tokensToRelease=numberTransactionsLeft>1?api.BigNumber(quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN):quantityLeft;if(balance.stake=calculateBalance(balance.stake,tokensToRelease,token.precision,!0),balance.pendingUnstake=calculateBalance(balance.pendingUnstake,quantityLeft,token.precision,!1),api.assert(api.BigNumber(balance.pendingUnstake).lt(originalPendingStake)&&api.BigNumber(balance.stake).gt(originalStake),"cannot subtract"))return await api.db.update("balances",balance),token.totalStaked=calculateBalance(token.totalStaked,tokensToRelease,token.precision,!0),await api.db.update("tokens",token),api.emit("unstakeCancel",{account:account,symbol:symbol,quantity:quantityLeft}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:symbol,quantity:tokensToRelease}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token}),!0}return!1};actions.cancelUnstake=async payload=>{const{txID:txID,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(txID&&"string"==typeof txID,"invalid params")){const unstake=await api.db.findOne("pendingUnstakes",{account:api.sender,txID:txID});api.assert(unstake,"unstake does not exist")&&await processCancelUnstake(unstake)&&await api.db.remove("pendingUnstakes",unstake)}},actions.enableDelegation=async payload=>{const{symbol:symbol,undelegationCooldown:undelegationCooldown,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{enableDelegationFee:enableDelegationFee}=params,utilityTokenBalance=await api.db.findOne("balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),enoughFunds=utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(enableDelegationFee),authorized=void 0===enableDelegationFee||api.BigNumber(enableDelegationFee).lte(0)||enoughFunds;if(api.assert(authorized,"you must have enough tokens to cover  fees")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol,"invalid symbol")&&api.assert(undelegationCooldown&&Number.isInteger(undelegationCooldown)&&undelegationCooldown>0&&undelegationCooldown<=18250,"undelegationCooldown must be an integer between 1 and 18250")){const token=await api.db.findOne("tokens",{symbol:symbol});api.assert(null!==token,"symbol does not exist")&&api.assert(token.issuer===api.sender,"must be the issuer")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(void 0===token.delegationEnabled||!1===token.delegationEnabled,"delegation already enabled")&&(token.delegationEnabled=!0,token.undelegationCooldown=undelegationCooldown,await api.db.update("tokens",token),api.BigNumber(enableDelegationFee).gt(0)&&await actions.transfer({to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:enableDelegationFee,isSignedWithActiveKey:isSignedWithActiveKey}))}},actions.delegate=async payload=>{const{symbol:symbol,to:to,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim();if(api.assert(api.isValidAccountName(finalTo),"invalid to")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.delegationEnabled,"delegation not enabled")&&api.assert(finalTo!==api.sender,"cannot delegate to yourself")&&api.assert(api.BigNumber(quantity).gt(0),"must delegate positive quantity")){quantity=api.BigNumber(quantity).toFixed(token.precision);const balanceFrom=await api.db.findOne("balances",{account:api.sender,symbol:symbol});if(api.assert(null!==balanceFrom,"balanceFrom does not exist")&&await validateAvailableStake(balanceFrom,token,quantity)){void 0===balanceFrom.stake?(balanceFrom.stake="0",balanceFrom.pendingUnstake="0",balanceFrom.delegationsIn="0",balanceFrom.delegationsOut="0",balanceFrom.pendingUndelegations="0"):void 0===balanceFrom.delegationsIn&&(balanceFrom.delegationsIn="0",balanceFrom.delegationsOut="0",balanceFrom.pendingUndelegations="0",balanceFrom.delegatedStake&&(delete balanceFrom.delegatedStake,delete balanceFrom.receivedStake));let balanceTo=await api.db.findOne("balances",{account:finalTo,symbol:symbol});null===balanceTo?(balanceTo=balanceTemplate,balanceTo.account=finalTo,balanceTo.symbol=symbol,balanceTo=await api.db.insert("balances",balanceTo)):void 0===balanceTo.stake?(balanceTo.stake="0",balanceTo.pendingUnstake="0",balanceTo.delegationsIn="0",balanceTo.delegationsOut="0",balanceTo.pendingUndelegations="0"):void 0===balanceTo.delegationsIn&&(balanceTo.delegationsIn="0",balanceTo.delegationsOut="0",balanceTo.pendingUndelegations="0",balanceTo.delegatedStake&&(delete balanceTo.delegatedStake,delete balanceTo.receivedStake));let delegation=await api.db.findOne("delegations",{to:finalTo,from:api.sender,symbol:symbol});const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();null==delegation?(balanceFrom.stake=calculateBalance(balanceFrom.stake,quantity,token.precision,!1),balanceFrom.delegationsOut=calculateBalance(balanceFrom.delegationsOut,quantity,token.precision,!0),await api.db.update("balances",balanceFrom),balanceTo.delegationsIn=calculateBalance(balanceTo.delegationsIn,quantity,token.precision,!0),await api.db.update("balances",balanceTo),delegation={},delegation.from=api.sender,delegation.to=finalTo,delegation.symbol=symbol,delegation.quantity=quantity,delegation.created=timestamp,delegation.updated=timestamp,await api.db.insert("delegations",delegation),api.emit("delegate",{to:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&(await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:api.sender}),await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo})),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity,delegated:!0}),await api.executeSmartContract("mining","handleStakeChange",{account:api.sender,symbol:symbol,quantity:api.BigNumber(quantity).negated()}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:api.sender,token:token}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token})):(balanceFrom.stake=calculateBalance(balanceFrom.stake,quantity,token.precision,!1),balanceFrom.delegationsOut=calculateBalance(balanceFrom.delegationsOut,quantity,token.precision,!0),await api.db.update("balances",balanceFrom),balanceTo.delegationsIn=calculateBalance(balanceTo.delegationsIn,quantity,token.precision,!0),await api.db.update("balances",balanceTo),delegation.quantity=calculateBalance(delegation.quantity,quantity,token.precision,!0),delegation.updated=timestamp,await api.db.update("delegations",delegation),api.emit("delegate",{to:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&(await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:api.sender}),await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo})),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity,delegated:!0}),await api.executeSmartContract("mining","handleStakeChange",{account:api.sender,symbol:symbol,quantity:api.BigNumber(quantity).negated()}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:api.sender,token:token}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token}))}}}}},actions.undelegate=async payload=>{const{symbol:symbol,from:from,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&from&&"string"==typeof from&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalFrom=from.trim();if(api.assert(finalFrom.length>=3&&finalFrom.length<=16,"invalid from")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.delegationEnabled,"delegation not enabled")&&api.assert(finalFrom!==api.sender,"cannot undelegate from yourself")&&api.assert(api.BigNumber(quantity).gt(0),"must undelegate positive quantity")){quantity=api.BigNumber(quantity).toFixed(token.precision);const balanceTo=await api.db.findOne("balances",{account:api.sender,symbol:symbol});if(api.assert(null!==balanceTo,"balanceTo does not exist")&&api.assert(api.BigNumber(balanceTo.delegationsOut).gte(quantity),"overdrawn delegation")){const balanceFrom=await api.db.findOne("balances",{account:finalFrom,symbol:symbol});if(api.assert(null!==balanceFrom,"balanceFrom does not exist")){const delegation=await api.db.findOne("delegations",{to:finalFrom,from:api.sender,symbol:symbol});if(api.assert(null!==delegation,"delegation does not exist")&&api.assert(api.BigNumber(delegation.quantity).gte(quantity),"overdrawn delegation")){balanceTo.pendingUndelegations=calculateBalance(balanceTo.pendingUndelegations,quantity,token.precision,!0),balanceTo.delegationsOut=calculateBalance(balanceTo.delegationsOut,quantity,token.precision,!1),await api.db.update("balances",balanceTo),balanceFrom.delegationsIn=calculateBalance(balanceFrom.delegationsIn,quantity,token.precision,!1),await api.db.update("balances",balanceFrom),delegation.quantity=calculateBalance(delegation.quantity,quantity,token.precision,!1),api.BigNumber(delegation.quantity).gt(0)?await api.db.update("delegations",delegation):await api.db.remove("delegations",delegation);const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),cooldownPeriodMillisec=24*token.undelegationCooldown*3600*1e3,completeTimestamp=blockDate.getTime()+cooldownPeriodMillisec,undelegation={account:api.sender,symbol:token.symbol,quantity:quantity,completeTimestamp:completeTimestamp,txID:api.transactionId};await api.db.insert("pendingUndelegations",undelegation),api.emit("undelegateStart",{from:finalFrom,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalFrom}),await api.executeSmartContract("mining","handleStakeChange",{account:finalFrom,symbol:symbol,quantity:api.BigNumber(quantity).negated(),delegated:!0}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalFrom,token:token})}}}}}}};const processUndelegation=async undelegation=>{const{account:account,symbol:symbol,quantity:quantity}=undelegation,balance=await api.db.findOne("balances",{account:account,symbol:symbol}),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==balance,"balance does not exist")){const originalStake=balance.stake,originalPendingUndelegations=balance.pendingUndelegations;balance.stake=calculateBalance(balance.stake,quantity,token.precision,!0),balance.pendingUndelegations=calculateBalance(balance.pendingUndelegations,quantity,token.precision,!1),api.assert(api.BigNumber(balance.pendingUndelegations).lt(originalPendingUndelegations)&&api.BigNumber(balance.stake).gt(originalStake),"cannot subtract")&&(await api.db.update("balances",balance),await api.db.remove("pendingUndelegations",undelegation),api.emit("undelegateDone",{account:account,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:symbol,quantity:quantity}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token}))}};actions.checkPendingUndelegations=async()=>{if(api.assert("null"===api.sender,"not authorized")){const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();let pendingUndelegations=await api.db.find("pendingUndelegations",{completeTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUndelegations=pendingUndelegations.length;for(;nbPendingUndelegations>0;){for(let index=0;index<nbPendingUndelegations;index+=1){const pendingUndelegation=pendingUndelegations[index];await processUndelegation(pendingUndelegation)}pendingUndelegations=await api.db.find("pendingUndelegations",{completeTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUndelegations=pendingUndelegations.length}}};