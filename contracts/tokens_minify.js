<<<<<<< HEAD
const FeeMethod = ['burn', 'issuer']; const PayoutType = ['user', 'contract']; function validateTokens(payTokenObj, voteTokenObj) { return !!api.assert(payTokenObj && (payTokenObj.issuer === api.sender || payTokenObj.symbol === "'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'" && api.sender === api.owner), 'must be issuer of payToken') && !!api.assert(voteTokenObj && voteTokenObj.stakingEnabled, 'voteToken must have staking enabled'); } function validateDateTime(str) { if (str.length === 24) { for (let i = 0; i < str.length && [5, 8, 11, 14, 17, 21].indexOf(i) === 1; i += 1) { const code = str.charCodeAt(i); if (!(code > 47 && code < 58)) return !1; } return !0; } return !1; } function validateDateRange(startDate, endDate, maxDays) {
  if (!api.assert(validateDateTime(startDate) && validateDateTime(endDate), 'invalid datetime format: YYYY-MM-DDThh:mm:ss.sssZ')) return !1; const now = new Date(`${api.hiveBlockTimestamp}.000Z`); const start = new Date(startDate); const end = new Date(endDate); if (!api.assert(api.BigNumber(start.getTime()).lt(api.BigNumber(end.getTime()).minus(864e5)), 'dates must be at least 1 day apart') || !api.assert(api.BigNumber(start.getTime()).gt(api.BigNumber(now.getTime()).plus(864e5)), 'startDate must be at least 1 day in the future')) return !1; const rangeDays = api.BigNumber(start.getTime()).minus(end.getTime()).abs().dividedBy(864e5)
    .toFixed(0, api.BigNumber.ROUND_CEIL); return !!api.assert(api.BigNumber(rangeDays).lte(maxDays), 'date range exceeds DTF maxDays');
} function validateDateChange(proposal, newDate, maxDays) {
  if (!api.assert(validateDateTime(newDate), 'invalid datetime format: YYYY-MM-DDThh:mm:ss.sssZ')) return !1; const start = new Date(proposal.startDate); const cur = new Date(proposal.endDate); const repl = new Date(newDate); if (!api.assert(api.BigNumber(start.getTime()).lt(api.BigNumber(repl.getTime()).minus(864e5)), 'dates must be at least 1 day apart')) return !1; if (!api.assert(repl <= cur, 'date can only be reduced')) return !1; const rangeDays = api.BigNumber(start.getTime()).minus(repl.getTime()).abs().dividedBy(864e5)
    .toFixed(0, api.BigNumber.ROUND_CEIL); return !!api.assert(api.BigNumber(rangeDays).lte(maxDays), 'date range exceeds DTF maxDays');
} function validatePending(proposal) { const blockDate = new Date(`${api.hiveBlockTimestamp}.000Z`); return new Date(proposal.endDate) >= blockDate; } async function updateProposalWeight(id, deltaApprovalWeight, deltaToken = null) { const proposal = await api.db.findOne('proposals', { _id: id }); if (proposal && validatePending(proposal)) { if (deltaToken) { if ((await api.db.findOne('funds', { id: proposal.fundId })).voteToken !== deltaToken.symbol) return !0; } return proposal.approvalWeight = { $numberDecimal: api.BigNumber(proposal.approvalWeight.$numberDecimal).plus(deltaApprovalWeight) }, await api.db.update('proposals', proposal), !0; } return !1; } async function checkPendingProposals(dtf, params) {
  const blockDate = new Date(`${api.hiveBlockTimestamp}.000Z`); const payTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: dtf.payToken }); const tickPayRatio = api.BigNumber(params.dtfTickHours).dividedBy(24); const funded = []; const fundedLog = []; let proposals; let offset = 0; let runningPay = api.BigNumber(dtf.maxAmountPerDay).times(tickPayRatio); for (;runningPay.gt(0);) {
    proposals = await api.db.find('proposals', {
      fundId: dtf.id, active: !0, approvalWeight: { $gt: { $numberDecimal: api.BigNumber(dtf.voteThreshold) } }, startDate: { $lte: blockDate.toISOString() }, endDate: { $gte: blockDate.toISOString() },
    }, params.processQueryLimit, offset, [{ index: 'byApprovalWeight', descending: !0 }, { index: '_id', descending: !1 }]); for (let i = 0; i < proposals.length; i += 1) { if (api.BigNumber(proposals[i].amountPerDay).times(tickPayRatio).gte(runningPay)) { proposals[i].tickPay = runningPay.toFixed(payTokenObj.precision, api.BigNumber.ROUND_DOWN), funded.push(proposals[i]), runningPay = api.BigNumber(0); break; }proposals[i].tickPay = api.BigNumber(proposals[i].amountPerDay).times(tickPayRatio).toFixed(payTokenObj.precision, api.BigNumber.ROUND_DOWN), funded.push(proposals[i]), runningPay = runningPay.minus(proposals[i].tickPay); } if (proposals.length < params.processQueryLimit) break; offset += params.processQueryLimit;
  } for (let i = 0; i < funded.length; i += 1) { const fund = funded[i]; fundedLog.push({ id: fund._id, tickPay: fund.tickPay }), fund.payout.type === 'user' ? await api.executeSmartContract('tokens', 'issue', { to: fund.payout.name, symbol: payTokenObj.symbol, quantity: fund.tickPay }) : fund.payout.type === 'contract' && (await api.executeSmartContract('tokens', 'issueToContract', { to: fund.payout.name, symbol: payTokenObj.symbol, quantity: fund.tickPay }), await api.executeSmartContract(fund.payout.name, 'receiveDtfTokens', { data: fund.payout.contractPayload, symbol: payTokenObj.symbol, quantity: fund.tickPay })); }dtf.lastTickTime = api.BigNumber(blockDate.getTime()).toNumber(), await api.db.update('funds', dtf), api.emit('fundProposals', { fundId: dtf.id, funded: fundedLog });
}actions.createSSC = async () => {
  if (!1 === await api.db.tableExists('funds')) {
    await api.db.createTable('funds', ['id', 'lastTickTime']), await api.db.createTable('proposals', ['fundId', { name: 'byApprovalWeight', index: { fundId: 1, approvalWeight: 1 } }]), await api.db.createTable('approvals', ['from', 'to']), await api.db.createTable('accounts', [], { primaryKey: ['account'] }), await api.db.createTable('params'); const params = {
      dtfCreationFee: '1000', dtfUpdateFee: '300', dtfTickHours: '24', maxDtfsPerBlock: 40, maxAccountApprovals: 50, processQueryLimit: 1e3,
    }; await api.db.insert('params', params);
  } else { const params = await api.db.findOne('params', {}); if (!params.updateIndex) { const dtfs = await api.db.find('funds', {}); const voteTokens = new Set(); for (let i = 0; i < dtfs.length; i += 1)voteTokens.add(dtfs[i].voteToken); const resetAccounts = await api.db.find('accounts', {}); for (let i = 0; i < resetAccounts.length; i += 1) { const acct = resetAccounts[i]; acct.weights = acct.weights.filter(ele => voteTokens.has(ele.symbol)), await api.db.update('accounts', acct); } const resetProposals = await api.db.find('proposals', {}); for (let i = 0; i < resetProposals.length; i += 1) { const prop = resetProposals[i]; const propFund = dtfs.find(x => x.id === prop.fundId); const propApprovals = await api.db.find('approvals', { to: prop._id }); let newApprovalWeight = api.BigNumber('0'); for (let j = 0; j < propApprovals.length; j += 1) { const approval = propApprovals[j]; const approvalAcctWgt = resetAccounts.find(x => x.account === approval.from).weights.find(x => x.symbol === propFund.voteToken); newApprovalWeight = newApprovalWeight.plus(approvalAcctWgt.weight); }prop.approvalWeight = { $numberDecimal: newApprovalWeight }, await api.db.update('proposals', prop); }params.updateIndex = 1, await api.db.update('params', params); } }
}, actions.updateParams = async (payload) => {
  const {
    dtfCreationFee, dtfUpdateFee, dtfTickHours, maxDtfsPerBlock, maxAccountApprovals, processQueryLimit,
  } = payload; if (api.sender !== api.owner) return; const params = await api.db.findOne('params', {}); if (dtfCreationFee) { if (!api.assert(typeof dtfCreationFee === 'string' && !api.BigNumber(dtfCreationFee).isNaN() && api.BigNumber(dtfCreationFee).gte(0), 'invalid dtfCreationFee')) return; params.dtfCreationFee = dtfCreationFee; } if (dtfUpdateFee) { if (!api.assert(typeof dtfUpdateFee === 'string' && !api.BigNumber(dtfUpdateFee).isNaN() && api.BigNumber(dtfUpdateFee).gte(0), 'invalid dtfUpdateFee')) return; params.dtfUpdateFee = dtfUpdateFee; } if (dtfTickHours) { if (!api.assert(typeof dtfTickHours === 'string' && api.BigNumber(dtfTickHours).isInteger() && api.BigNumber(dtfTickHours).gte(1), 'invalid dtfTickHours')) return; params.dtfTickHours = dtfTickHours; } if (maxDtfsPerBlock) { if (!api.assert(typeof maxDtfsPerBlock === 'string' && api.BigNumber(maxDtfsPerBlock).isInteger() && api.BigNumber(maxDtfsPerBlock).gte(1), 'invalid maxDtfsPerBlock')) return; params.maxDtfsPerBlock = api.BigNumber(maxDtfsPerBlock).toNumber(); } if (maxAccountApprovals) { if (!api.assert(typeof maxAccountApprovals === 'string' && api.BigNumber(maxAccountApprovals).isInteger() && api.BigNumber(maxAccountApprovals).gte(1), 'invalid maxDtfsPerBlock')) return; params.maxAccountApprovals = api.BigNumber(maxAccountApprovals).toNumber(); } if (processQueryLimit) { if (!api.assert(typeof processQueryLimit === 'string' && api.BigNumber(processQueryLimit).isInteger() && api.BigNumber(processQueryLimit).gte(1), 'invalid processQueryLimit')) return; params.processQueryLimit = api.BigNumber(processQueryLimit).toNumber(); } await api.db.update('params', params);
}, actions.createFund = async (payload) => {
  const {
    payToken, voteToken, voteThreshold, maxDays, maxAmountPerDay, proposalFee, isSignedWithActiveKey,
  } = payload; const params = await api.db.findOne('params', {}); const { dtfCreationFee } = params; const utilityTokenBalance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: "'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'" }); const authorizedCreation = !(!api.BigNumber(dtfCreationFee).lte(0) && api.sender !== api.owner) || utilityTokenBalance && api.BigNumber(utilityTokenBalance.balance).gte(dtfCreationFee); if (api.assert(authorizedCreation, 'you must have enough tokens to cover the creation fee') && api.assert(!0 === isSignedWithActiveKey, 'you must use a transaction signed with your active key') && api.assert(typeof voteThreshold === 'string' && api.BigNumber(voteThreshold).gt(0), 'invalid voteThreshold: greater than 0') && api.assert(typeof maxDays === 'string' && api.BigNumber(maxDays).isInteger() && api.BigNumber(maxDays).gt(0) && api.BigNumber(maxDays).lte(730), 'invalid maxDays: integer between 1 and 730') && api.assert(typeof maxAmountPerDay === 'string' && api.BigNumber(maxAmountPerDay).gt(0), 'invalid maxAmountPerDay: greater than 0')) {
    if (proposalFee) { if (!api.assert(typeof proposalFee === 'object' && typeof proposalFee.method === 'string' && FeeMethod.indexOf(proposalFee.method) !== -1 && typeof proposalFee.symbol === 'string' && typeof proposalFee.amount === 'string' && api.BigNumber(proposalFee.amount).gt(0), 'invalid proposalFee')) return; const feeTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: proposalFee.symbol }); if (!api.assert(feeTokenObj && api.BigNumber(proposalFee.amount).dp() <= feeTokenObj.precision, 'invalid proposalFee token or precision')) return; } const payTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: payToken }); const voteTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: voteToken }); if (!validateTokens(payTokenObj, voteTokenObj) || !api.assert(api.BigNumber(maxAmountPerDay).dp() <= payTokenObj.precision, 'maxAmountPerDay precision mismatch') || !api.assert(api.BigNumber(voteThreshold).dp() <= voteTokenObj.precision, 'voteThreshold precision mismatch')) return; const now = new Date(`${api.hiveBlockTimestamp}.000Z`); const newDtf = {
      payToken, voteToken, voteThreshold, maxDays, maxAmountPerDay, proposalFee, active: !1, creator: api.sender, lastTickTime: now.getTime(),
    }; newDtf.id = `${payToken}:${voteToken}`; const existingDtf = await api.db.findOne('funds', { id: newDtf.id }); if (!api.assert(!existingDtf, 'DTF already exists')) return; const insertedDtf = await api.db.insert('funds', newDtf); api.sender !== api.owner && api.sender !== 'null' && api.BigNumber(dtfCreationFee).gt(0) && await api.executeSmartContract('tokens', 'transfer', {
      to: 'null', symbol: "'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'", quantity: dtfCreationFee, isSignedWithActiveKey,
    }), api.emit('createFund', { id: insertedDtf.id });
  }
}, actions.updateFund = async (payload) => {
  const {
    fundId, voteThreshold, maxDays, maxAmountPerDay, proposalFee, isSignedWithActiveKey,
  } = payload; const params = await api.db.findOne('params', {}); const { dtfUpdateFee } = params; const utilityTokenBalance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: "'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'" }); const authorizedUpdate = !(!api.BigNumber(dtfUpdateFee).lte(0) && api.sender !== api.owner) || utilityTokenBalance && api.BigNumber(utilityTokenBalance.balance).gte(dtfUpdateFee); if (api.assert(authorizedUpdate, 'you must have enough tokens to cover the update fee') && api.assert(!0 === isSignedWithActiveKey, 'you must use a transaction signed with your active key') && api.assert(typeof voteThreshold === 'string' && api.BigNumber(voteThreshold).gt(0), 'invalid voteThreshold: greater than 0') && api.assert(typeof maxDays === 'string' && api.BigNumber(maxDays).isInteger() && api.BigNumber(maxDays).gt(0) && api.BigNumber(maxDays).lte(730), 'invalid maxDays: integer between 1 and 730') && api.assert(typeof maxAmountPerDay === 'string' && api.BigNumber(maxAmountPerDay).gt(0), 'invalid maxAmountPerDay: greater than 0')) {
    if (proposalFee) { if (!api.assert(typeof proposalFee === 'object' && typeof proposalFee.method === 'string' && FeeMethod.indexOf(proposalFee.method) !== -1 && typeof proposalFee.symbol === 'string' && typeof proposalFee.amount === 'string' && api.BigNumber(proposalFee.amount).gt(0), 'invalid proposalFee')) return; const feeTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: proposalFee.symbol }); if (!api.assert(feeTokenObj && api.BigNumber(proposalFee.amount).dp() <= feeTokenObj.precision, 'invalid proposalFee token or precision')) return; } const existingDtf = await api.db.findOne('funds', { id: fundId }); if (!api.assert(existingDtf, 'DTF not found') || !api.assert(existingDtf.creator === api.sender || api.owner === api.sender, 'must be DTF creator')) return; const payTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: existingDtf.payToken }); const voteTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: existingDtf.voteToken }); if (!api.assert(api.BigNumber(maxAmountPerDay).dp() <= payTokenObj.precision, 'maxAmountPerDay precision mismatch') || !api.assert(api.BigNumber(voteThreshold).dp() <= voteTokenObj.precision, 'voteThreshold precision mismatch')) return; existingDtf.voteThreshold = voteThreshold, existingDtf.maxDays = maxDays, existingDtf.maxAmountPerDay = maxAmountPerDay, proposalFee && (existingDtf.proposalFee = proposalFee), await api.db.update('funds', existingDtf), api.sender !== api.owner && api.sender !== 'null' && api.BigNumber(dtfUpdateFee).gt(0) && await api.executeSmartContract('tokens', 'transfer', {
      to: 'null', symbol: "'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'", quantity: dtfUpdateFee, isSignedWithActiveKey,
    }), api.emit('updateFund', { id: fundId });
  }
}, actions.setDtfActive = async (payload) => { const { fundId, active, isSignedWithActiveKey } = payload; if (!api.assert(!0 === isSignedWithActiveKey, 'you must use a transaction signed with your active key')) return; const dtf = await api.db.findOne('funds', { id: fundId }); api.assert(dtf, 'DTF does not exist') && api.assert(dtf.creator === api.sender || api.owner === api.sender, 'must be DTF creator') && (dtf.active = !!active, await api.db.update('funds', dtf), api.emit('setDtfActive', { id: dtf.id, active: dtf.active })); }, actions.createProposal = async (payload) => {
  const {
    fundId, title, startDate, endDate, amountPerDay, authorPermlink, payout, isSignedWithActiveKey,
  } = payload; const dtf = await api.db.findOne('funds', { id: fundId }); if (!api.assert(dtf, 'DTF does not exist')) return; let authorizedCreation = !0; if (dtf.proposalFee) { const feeTokenBalance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: dtf.proposalFee.symbol }); authorizedCreation = !(!api.BigNumber(dtf.proposalFee.amount).lte(0) && api.sender !== api.owner) || feeTokenBalance && api.BigNumber(feeTokenBalance.balance).gte(dtf.proposalFee.amount); } if (api.assert(authorizedCreation, 'you must have enough tokens to cover the creation fee') && api.assert(!0 === isSignedWithActiveKey, 'you must use a transaction signed with your active key') && api.assert(!0 === dtf.active, 'DTF is not active') && api.assert(typeof title === 'string' && title.length > 0 && title.length <= 80, 'invalid title: between 1 and 80 characters') && api.assert(typeof authorPermlink === 'string' && authorPermlink.length > 0 && authorPermlink.length <= 255, 'invalid authorPermlink: between 1 and 255 characters') && api.assert(typeof amountPerDay === 'string' && api.BigNumber(amountPerDay).isInteger() && api.BigNumber(amountPerDay).gt(0), 'invalid amountPerDay: greater than 0') && api.assert(api.BigNumber(amountPerDay).lte(dtf.maxAmountPerDay), 'invalid amountPerDay: exceeds DTF maxAmountPerDay') && api.assert(typeof payout === 'object' && typeof payout.type === 'string' && PayoutType.indexOf(payout.type) !== -1 && (payout.type !== 'contract' || typeof payout.contractPayload === 'object') && typeof payout.name === 'string' && payout.name.length >= 3 && payout.name.length <= 50, 'invalid payout settings') && validateDateRange(startDate, endDate, dtf.maxDays)) {
    const newProposal = {
      fundId, title, startDate, endDate, amountPerDay, authorPermlink, payout, creator: api.sender, approvalWeight: { $numberDecimal: '0' }, active: !0,
    }; const insertedProposal = await api.db.insert('proposals', newProposal); if (api.sender !== api.owner && dtf.proposalFee) if (dtf.proposalFee.method === 'burn') await api.executeSmartContract('tokens', 'transfer', { to: 'null', symbol: dtf.proposalFee.symbol, quantity: dtf.proposalFee.amount }); else if (dtf.proposalFee.method === 'issuer') { const feeTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: dtf.proposalFee.symbol }); await api.executeSmartContract('tokens', 'transfer', { to: feeTokenObj.issuer, symbol: dtf.proposalFee.symbol, quantity: dtf.proposalFee.amount }); }api.emit('createProposal', { id: insertedProposal._id });
  }
}, actions.updateProposal = async (payload) => {
  const {
    id, title, endDate, amountPerDay, authorPermlink, isSignedWithActiveKey,
  } = payload; if (!api.assert(typeof id === 'string' && api.BigNumber(id).isInteger(), 'invalid id')) return; const proposal = await api.db.findOne('proposals', { _id: api.BigNumber(id).toNumber() }); if (!api.assert(proposal, 'proposal does not exist') || !api.assert(proposal.creator === api.sender || api.owner === api.sender, 'must be proposal creator')) return; const dtf = await api.db.findOne('funds', { id: proposal.fundId, active: !0 }); api.assert(dtf, 'DTF does not exist or inactive') && api.assert(!0 === isSignedWithActiveKey, 'you must use a transaction signed with your active key') && api.assert(!0 === dtf.active, 'DTF is not active') && api.assert(!0 === proposal.active, 'proposal is not active') && api.assert(typeof title === 'string' && title.length > 0 && title.length <= 80, 'invalid title: between 1 and 80 characters') && api.assert(typeof authorPermlink === 'string' && authorPermlink.length > 0 && authorPermlink.length <= 255, 'invalid authorPermlink: between 1 and 255 characters') && api.assert(typeof amountPerDay === 'string' && api.BigNumber(amountPerDay).isInteger() && api.BigNumber(amountPerDay).gt(0) && api.BigNumber(amountPerDay).lte(proposal.amountPerDay), 'invalid amountPerDay: greater than 0 and cannot be increased') && api.assert(api.BigNumber(amountPerDay).lte(dtf.maxAmountPerDay), 'invalid amountPerDay: exceeds DTF maxAmountPerDay') && validateDateChange(proposal, endDate, dtf.maxDays) && (proposal.title = title, proposal.endDate = endDate, proposal.amountPerDay = amountPerDay, proposal.authorPermlink = authorPermlink, await api.db.update('proposals', proposal), api.emit('updateProposal', { id: proposal._id }));
}, actions.disableProposal = async (payload) => { const { id, isSignedWithActiveKey } = payload; if (!api.assert(typeof id === 'string' && api.BigNumber(id).isInteger(), 'invalid id')) return; const proposal = await api.db.findOne('proposals', { _id: api.BigNumber(id).toNumber() }); api.assert(proposal, 'proposal does not exist') && api.assert(!0 === proposal.active, 'proposal already disabled') && api.assert(proposal.creator === api.sender || api.owner === api.sender, 'must be proposal creator') && (proposal.active = !1, await api.db.update('proposals', proposal), api.emit('disableProposal', { id: proposal._id })); }, actions.approveProposal = async (payload) => { const { id } = payload; const params = await api.db.findOne('params', {}); if (api.assert(typeof id === 'string' && api.BigNumber(id).isInteger(), 'invalid id')) { const proposal = await api.db.findOne('proposals', { _id: api.BigNumber(id).toNumber() }); if (api.assert(proposal, 'proposal does not exist') && api.assert(validatePending(proposal), 'proposal is not pending')) { const dtf = await api.db.findOne('funds', { id: proposal.fundId }); const voteTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: dtf.voteToken }); let acct = await api.db.findOne('accounts', { account: api.sender }); acct === null && (acct = { account: api.sender, weights: [] }, acct = await api.db.insert('accounts', acct)); let activeApprovals = 0; const approvals = await api.db.find('approvals', { from: api.sender, proposalPending: !0 }, params.maxAccountApprovals, 0, [{ index: '_id', descending: !0 }]); for (let index = 0; index < approvals.length; index += 1) { const approval = approvals[index]; const approvalProposal = await api.db.findOne('proposals', { _id: approval.to }); approvalProposal && validatePending(approvalProposal) ? activeApprovals += 1 : (approval.proposalPending = !1, await api.db.update('approvals', approval)); } if (!api.assert(activeApprovals < params.maxAccountApprovals, `you can only approve ${params.maxAccountApprovals} active proposals`)) return; let approval = await api.db.findOne('approvals', { from: api.sender, to: proposal._id }); if (api.assert(approval === null, 'you already approved this proposal')) { approval = { from: api.sender, to: proposal._id, proposalPending: !0 }, await api.db.insert('approvals', approval); const balance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: dtf.voteToken }); let approvalWeight = 0; balance && balance.stake && (approvalWeight = balance.stake), balance && balance.delegationsIn && (approvalWeight = api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(voteTokenObj.precision, api.BigNumber.ROUND_HALF_UP)); const wIndex = acct.weights.findIndex(x => x.symbol === dtf.voteToken); wIndex !== -1 ? acct.weights[wIndex].weight = approvalWeight : acct.weights.push({ symbol: dtf.voteToken, weight: approvalWeight }), await api.db.update('accounts', acct), await updateProposalWeight(proposal._id, approvalWeight), api.emit('approveProposal', { id: proposal._id }); } } } }, actions.disapproveProposal = async (payload) => { const { id } = payload; if (api.assert(typeof id === 'string' && api.BigNumber(id).isInteger(), 'invalid id')) { const proposal = await api.db.findOne('proposals', { _id: api.BigNumber(id).toNumber() }); if (api.assert(proposal, 'proposal does not exist') && api.assert(validatePending(proposal), 'proposal is not pending')) { const dtf = await api.db.findOne('funds', { id: proposal.fundId }); const voteTokenObj = await api.db.findOneInTable('tokens', 'tokens', { symbol: dtf.voteToken }); let acct = await api.db.findOne('accounts', { account: api.sender }); acct === null && (acct = { account: api.sender, weights: [] }, acct = await api.db.insert('accounts', acct)); const approval = await api.db.findOne('approvals', { from: api.sender, to: proposal._id }); if (api.assert(approval !== null, 'you have not approved this proposal')) { await api.db.remove('approvals', approval); const balance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: dtf.voteToken }); let approvalWeight = 0; balance && balance.stake && (approvalWeight = balance.stake), balance && balance.delegationsIn && (approvalWeight = api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(voteTokenObj.precision, api.BigNumber.ROUND_HALF_UP)); const wIndex = acct.weights.findIndex(x => x.symbol === dtf.voteToken); wIndex !== -1 ? acct.weights[wIndex].weight = approvalWeight : acct.weights.push({ symbol: dtf.voteToken, weight: approvalWeight }), await api.db.update('accounts', acct), await updateProposalWeight(proposal._id, api.BigNumber(approvalWeight).negated()), api.emit('disapproveProposal', { id: proposal._id }); } } } }, actions.updateProposalApprovals = async (payload) => { const { account, token, callingContractInfo } = payload; if (void 0 === callingContractInfo) return; if (callingContractInfo.name !== 'tokens') return; const acct = await api.db.findOne('accounts', { account }); if (acct !== null) { const params = await api.db.findOne('params', {}); const wIndex = acct.weights.findIndex(x => x.symbol === token.symbol); if (wIndex !== -1) { const balance = await api.db.findOneInTable('tokens', 'balances', { account, symbol: token.symbol }); let approvalWeight = 0; balance && balance.stake && (approvalWeight = balance.stake), balance && balance.delegationsIn && (approvalWeight = api.BigNumber(approvalWeight).plus(balance.delegationsIn).toFixed(token.precision, api.BigNumber.ROUND_HALF_UP)); let oldApprovalWeight = 0; oldApprovalWeight = acct.weights[wIndex].weight, acct.weights[wIndex].weight = approvalWeight; const deltaApprovalWeight = api.BigNumber(approvalWeight).minus(oldApprovalWeight).dp(token.precision, api.BigNumber.ROUND_HALF_UP); if (!api.BigNumber(deltaApprovalWeight).eq(0)) { await api.db.update('accounts', acct); const approvals = await api.db.find('approvals', { from: account, proposalPending: !0 }, params.maxAccountApprovals, 0, [{ index: '_id', descending: !0 }]); for (let index = 0; index < approvals.length; index += 1) { const approval = approvals[index]; await updateProposalWeight(approval.to, deltaApprovalWeight, token) || (approval.proposalPending = !1, await api.db.update('approvals', approval)); } } } } }, actions.checkPendingDtfs = async () => { if (api.assert(api.sender === 'null', 'not authorized')) { const params = await api.db.findOne('params', {}); const blockDate = new Date(`${api.hiveBlockTimestamp}.000Z`); const tickTime = api.BigNumber(blockDate.getTime()).minus(3600 * params.dtfTickHours * 1e3).toNumber(); const pendingDtfs = await api.db.find('funds', { active: !0, lastTickTime: { $lte: tickTime } }, params.maxDtfsPerBlock, 0, [{ index: 'lastTickTime', descending: !1 }, { index: '_id', descending: !1 }]); for (let i = 0; i < pendingDtfs.length; i += 1) await checkPendingProposals(pendingDtfs[i], params); } };
=======
const ACCOUNT_BLACKLIST={gateiodeposit:1,deepcrypto8:1,bittrex:1,poloniex:1,"huobi-pro":1,"binance-hot":1,bitvavo:1,blocktrades:1,probitsteem:1,probithive:1,ionomy:1,mxchive:1,coinbasebase:1,orinoco:1,"user.dunamu":1},HE_ACCOUNTS={"hive-engine":1,"swap-eth":1,"btc-swap":1,"graphene-swap":1,"honey-swap":1},RESERVED_SYMBOLS={ENG:"null",STEEMP:"steem-peg",BTCP:"btcpeg",LTCP:"ltcp",DOGEP:"dogep",BCHP:"bchp",SMTT:"steemmonsters",EM:"steem-eng",EMFOUR:"steem-eng",HIVEP:"steem-tokens",GLINT:"steemmonsters"},VERIFIED_ISSUERS=["comments","mining","tokenfunds","beedollar","burndollar"],calculateBalance=(balance,quantity,precision,add)=>add?api.BigNumber(balance).plus(quantity).toFixed(precision):api.BigNumber(balance).minus(quantity).toFixed(precision),countDecimals=value=>api.BigNumber(value).dp(),findAndProcessAll=async(table,query,callback)=>{let offset=0,results=[],done=!1;for(;!done;)if(results=await api.db.find(table,query,1e3,offset),results){for(let i=0;i<results.length;i+=1)await callback(results[i]);results.length<1e3?done=!0:offset+=1e3}};actions.createSSC=async()=>{if(!1===await api.db.tableExists("tokens")){await api.db.createTable("tokens",["symbol"]),await api.db.createTable("balances",["account"]),await api.db.createTable("contractsBalances",["account"]),await api.db.createTable("params"),await api.db.createTable("pendingUnstakes",["account","unstakeCompleteTimestamp"]),await api.db.createTable("delegations",["from","to"]),await api.db.createTable("pendingUndelegations",["account","completeTimestamp"]);const params={tokenCreationFee:"0",enableDelegationFee:"0",enableStakingFee:"0"};await api.db.insert("params",params)}else{const params=await api.db.findOne("params",{});if(!params.blacklist){params.blacklist=ACCOUNT_BLACKLIST,params.heAccounts=HE_ACCOUNTS;const unsets={};let useUnsets=!1;params.fixMultiTxUnstakeBalance&&(delete params.fixMultiTxUnstakeBalance,unsets.fixMultiTxUnstakeBalance="",useUnsets=!0),params.cancelBadUnstakes&&(delete params.cancelBadUnstakes,unsets.cancelBadUnstakes="",useUnsets=!0),useUnsets?await api.db.update("params",params,unsets):await api.db.update("params",params)}}};const balanceTemplate={account:null,symbol:null,balance:"0",stake:"0",pendingUnstake:"0",delegationsIn:"0",delegationsOut:"0",pendingUndelegations:"0"},addStake=async(account,token,quantity)=>{let balance=await api.db.findOne("balances",{account:account,symbol:token.symbol});null===balance&&(balance=balanceTemplate,balance.account=account,balance.symbol=token.symbol,balance=await api.db.insert("balances",balance)),void 0===balance.stake&&(balance.stake="0",balance.pendingUnstake="0");const originalStake=balance.stake;return balance.stake=calculateBalance(balance.stake,quantity,token.precision,!0),!!api.assert(api.BigNumber(balance.stake).gt(originalStake),"cannot add")&&(await api.db.update("balances",balance),void 0===token.totalStaked&&(token.totalStaked="0"),token.totalStaked=calculateBalance(token.totalStaked,quantity,token.precision,!0),await api.db.update("tokens",token),!0)},subBalance=async(account,token,quantity,table)=>{const balance=await api.db.findOne(table,{account:account,symbol:token.symbol});if(api.assert(null!==balance,"balance does not exist")&&api.assert(api.BigNumber(balance.balance).gte(quantity),"overdrawn balance")){const originalBalance=balance.balance;if(balance.balance=calculateBalance(balance.balance,quantity,token.precision,!1),api.assert(api.BigNumber(balance.balance).lt(originalBalance),"cannot subtract"))return await api.db.update(table,balance),!0}return!1},addBalance=async(account,token,quantity,table)=>{let balance=await api.db.findOne(table,{account:account,symbol:token.symbol});if(null===balance)return balance=balanceTemplate,balance.account=account,balance.symbol=token.symbol,balance.balance=quantity,await api.db.insert(table,balance),!0;const originalBalance=balance.balance;return balance.balance=calculateBalance(balance.balance,quantity,token.precision,!0),!!api.assert(api.BigNumber(balance.balance).gt(originalBalance),"cannot add")&&(await api.db.update(table,balance),!0)};actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{tokenCreationFee:tokenCreationFee,enableDelegationFee:enableDelegationFee,enableStakingFee:enableStakingFee,blacklist:blacklist,heAccounts:heAccounts}=payload,params=await api.db.findOne("params",{});tokenCreationFee&&"string"==typeof tokenCreationFee&&!api.BigNumber(tokenCreationFee).isNaN()&&api.BigNumber(tokenCreationFee).gte(0)&&(params.tokenCreationFee=tokenCreationFee),enableDelegationFee&&"string"==typeof enableDelegationFee&&!api.BigNumber(enableDelegationFee).isNaN()&&api.BigNumber(enableDelegationFee).gte(0)&&(params.enableDelegationFee=enableDelegationFee),enableStakingFee&&"string"==typeof enableStakingFee&&!api.BigNumber(enableStakingFee).isNaN()&&api.BigNumber(enableStakingFee).gte(0)&&(params.enableStakingFee=enableStakingFee),blacklist&&"object"==typeof blacklist&&(params.blacklist=blacklist),heAccounts&&"object"==typeof heAccounts&&(params.heAccounts=heAccounts),await api.db.update("params",params)},actions.updateUrl=async payload=>{const{url:url,symbol:symbol}=payload;if(api.assert(symbol&&"string"==typeof symbol&&url&&"string"==typeof url,"invalid params")&&api.assert(url.length<=255,"invalid url: max length of 255")){const token=await api.db.findOne("tokens",{symbol:symbol});if(token&&api.assert(token.issuer===api.sender,"must be the issuer"))try{const metadata=JSON.parse(token.metadata);api.assert(metadata&&metadata.url,"an error occured when trying to update the url")&&(metadata.url=url,token.metadata=JSON.stringify(metadata),await api.db.update("tokens",token))}catch(e){}}},actions.updateMetadata=async payload=>{const{metadata:metadata,symbol:symbol,callingContractInfo:callingContractInfo}=payload,fromVerifiedContract="hive-engine"===api.sender&&callingContractInfo&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name);if(api.assert(symbol&&"string"==typeof symbol&&metadata&&"object"==typeof metadata,"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol});if(token&&api.assert(fromVerifiedContract||token.issuer===api.sender,"must be the issuer"))try{const finalMetadata=JSON.stringify(metadata);api.assert(finalMetadata.length<=1e3,"invalid metadata: max length of 1000")&&(token.metadata=finalMetadata,await api.db.update("tokens",token))}catch(e){}}},actions.updatePrecision=async payload=>{const{symbol:symbol,precision:precision,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol)&&api.assert(precision>0&&precision<=8&&Number.isInteger(precision),"invalid precision")){const token=await api.db.findOne("tokens",{symbol:symbol});token&&api.assert(token.issuer===api.sender,"must be the issuer")&&api.assert(precision>token.precision,"precision can only be increased")&&(token.precision=precision,await api.db.update("tokens",token))}},actions.transferOwnership=async payload=>{const{symbol:symbol,to:to,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to,"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol});if(token&&api.assert(token.issuer===api.sender,"must be the issuer")){const finalTo=to.trim();api.assert(api.isValidAccountName(finalTo),"invalid to")&&(token.issuer=finalTo,await api.db.update("tokens",token),api.emit("transferOwnership",{from:api.sender,to:finalTo,symbol:symbol}))}}},actions.create=async payload=>{const{name:name,symbol:symbol,url:url,precision:precision,maxSupply:maxSupply,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload,params=await api.db.findOne("params",{}),{tokenCreationFee:tokenCreationFee,heAccounts:heAccounts}=params,fromVerifiedContract=callingContractInfo&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name),utilityTokenBalance=fromVerifiedContract?null:await api.db.findOne("balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!fromVerifiedContract&&!api.BigNumber(tokenCreationFee).lte(0)&&1!==heAccounts[api.sender])||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(tokenCreationFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fees")&&api.assert(fromVerifiedContract||!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(name&&"string"==typeof name&&symbol&&"string"==typeof symbol&&(void 0===url||url&&"string"==typeof url)&&(precision&&"number"==typeof precision||0===precision)&&maxSupply&&"string"==typeof maxSupply&&!api.BigNumber(maxSupply).isNaN(),"invalid params")&&api.assert(symbol.length>0&&symbol.length<=10&&api.validator.isAlpha(api.validator.blacklist(symbol,"."))&&api.validator.isUppercase(symbol)&&(-1===symbol.indexOf(".")||symbol.indexOf(".")>0&&symbol.indexOf(".")<symbol.length-1&&symbol.indexOf(".")===symbol.lastIndexOf(".")),'invalid symbol: uppercase letters only and one "." allowed, max length of 10')&&api.assert(void 0===RESERVED_SYMBOLS[symbol]||api.sender===RESERVED_SYMBOLS[symbol],"cannot use this symbol")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf("SWAP"),"invalid symbol: not allowed to use SWAP")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf("ETH"),"invalid symbol: not allowed to use ETH")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf("BSC"),"invalid symbol: not allowed to use BSC")&&api.assert(1===heAccounts[api.sender]||-1===symbol.indexOf(".")||callingContractInfo&&"burndollar"===callingContractInfo.name,'invalid symbol: usage of "." is restricted')&&api.assert(api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=50,"invalid name: letters, numbers, whitespaces only, max length of 50")&&api.assert(void 0===url||url.length<=255,"invalid url: max length of 255")&&api.assert(precision>=0&&precision<=8&&Number.isInteger(precision),"invalid precision")&&api.assert(api.BigNumber(maxSupply).gt(0),"maxSupply must be positive")&&api.assert(api.BigNumber(maxSupply).lte(Number.MAX_SAFE_INTEGER),`maxSupply must be lower than ${Number.MAX_SAFE_INTEGER}`)){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null===token,"symbol already exists")){let metadata={url:void 0===url?"":url};metadata=JSON.stringify(metadata);const newToken={issuer:fromVerifiedContract?"null":api.sender,symbol:symbol,name:name,metadata:metadata,precision:precision,maxSupply:api.BigNumber(maxSupply).toFixed(precision),supply:"0",circulatingSupply:"0",stakingEnabled:!1,unstakingCooldown:1,delegationEnabled:!1,undelegationCooldown:0};await api.db.insert("tokens",newToken),api.BigNumber(tokenCreationFee).gt(0)&&void 0===heAccounts[api.sender]&&!fromVerifiedContract&&await actions.transfer({to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:tokenCreationFee,isSignedWithActiveKey:isSignedWithActiveKey})}}},actions.issue=async payload=>{const{to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload;let quantity=payload.quantity;const fromVerifiedContract="null"===api.sender&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name)||callingContractInfo&&"beedollar"===callingContractInfo.name||callingContractInfo&&"burndollar"===callingContractInfo.name;if(fromVerifiedContract||api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim(),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(fromVerifiedContract||token.issuer===api.sender,"not allowed to issue tokens")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must issue positive quantity")&&api.assert(api.BigNumber(token.maxSupply).minus(token.supply).gte(quantity),"quantity exceeds available supply")&&api.assert(api.isValidAccountName(finalTo),"invalid to")){quantity=api.BigNumber(quantity).toFixed(token.precision);let res=await addBalance(token.issuer,token,quantity,"balances");!0===res&&finalTo!==token.issuer&&await subBalance(token.issuer,token,quantity,"balances")&&(res=await addBalance(finalTo,token,quantity,"balances"),!1===res&&await addBalance(token.issuer,token,quantity,"balances")),!0===res&&(token.supply=calculateBalance(token.supply,quantity,token.precision,!0),"null"!==finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!0)),await api.db.update("tokens",token),api.emit("transferFromContract",{from:"tokens",to:finalTo,symbol:symbol,quantity:quantity}))}}},actions.issueToContract=async payload=>{const{to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload;let quantity=payload.quantity;const fromVerifiedContract="null"===api.sender&&-1!==VERIFIED_ISSUERS.indexOf(callingContractInfo.name);if(fromVerifiedContract||api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim(),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(fromVerifiedContract||token.issuer===api.sender,"not allowed to issue tokens")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must issue positive quantity")&&api.assert(api.BigNumber(token.maxSupply).minus(token.supply).gte(quantity),"quantity exceeds available supply")&&api.assert(finalTo.length>=3&&finalTo.length<=50,"invalid to")){quantity=api.BigNumber(quantity).toFixed(token.precision);!0===await addBalance(finalTo,token,quantity,"contractsBalances")&&(token.supply=calculateBalance(token.supply,quantity,token.precision,!0),"null"!==finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!0)),await api.db.update("tokens",token),api.emit("issueToContract",{from:"tokens",to:finalTo,symbol:symbol,quantity:quantity}))}}},actions.transfer=async payload=>{const{to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim();if(api.assert(finalTo!==api.sender,"cannot transfer to self")){const params=await api.db.findOne("params",{}),{blacklist:blacklist}=params;if(api.assert(api.isValidAccountName(finalTo),"invalid to")&&api.assert(void 0===blacklist[finalTo],`not allowed to send to ${finalTo}`)){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must transfer positive quantity")&&await subBalance(api.sender,token,quantity,"balances")){return!1===await addBalance(finalTo,token,quantity,"balances")?(await addBalance(api.sender,token,quantity,"balances"),!1):("null"===finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!1),await api.db.update("tokens",token)),api.emit("transfer",{from:api.sender,to:finalTo,symbol:symbol,quantity:quantity}),!0)}}}}return!1},actions.transferToContract=async payload=>{const{from:from,to:to,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;const finalFrom=void 0===from||"null"!==api.sender?api.sender:from;if(api.assert(!0===isSignedWithActiveKey||"null"===api.sender,"you must use a custom_json signed with your active key")&&api.assert(to&&"string"==typeof to&&symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim().toLowerCase();if(api.assert(finalTo!==finalFrom,"cannot transfer to self")&&api.assert(finalTo.length>=3&&finalTo.length<=50,"invalid to")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must transfer positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(finalFrom,token,quantity,"balances"))){!1===await addBalance(finalTo,token,quantity,"contractsBalances")?await addBalance(finalFrom,token,quantity,"balances"):("null"===finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!1),await api.db.update("tokens",token)),api.emit("transferToContract",{from:finalFrom,to:finalTo,symbol:symbol,quantity:quantity}))}}}},actions.transferFromContract=async payload=>{if(api.assert("null"===api.sender,"not authorized")){const{from:from,to:to,symbol:symbol,type:type}=payload;let quantity=payload.quantity;const types=["user","contract"];if(api.assert(to&&"string"==typeof to&&from&&"string"==typeof from&&symbol&&"string"==typeof symbol&&type&&types.includes(type)&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim(),table="user"===type?"balances":"contractsBalances";if(api.assert("user"===type||"contract"===type&&finalTo!==from,"cannot transfer to self")){const toValid="user"===type?api.isValidAccountName(finalTo):finalTo.length>=3&&finalTo.length<=50;if(api.assert(!0===toValid,"invalid to")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must transfer positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(from,token,quantity,"contractsBalances"))){!1===await addBalance(finalTo,token,quantity,table)?await addBalance(from,token,quantity,"contractsBalances"):("null"===finalTo&&(token.circulatingSupply=calculateBalance(token.circulatingSupply,quantity,token.precision,!1),await api.db.update("tokens",token)),api.emit("transferFromContract",{from:from,to:finalTo,symbol:symbol,quantity:quantity}))}}}}}};const processUnstake=async unstake=>{const{account:account,symbol:symbol,quantity:quantity,quantityLeft:quantityLeft,numberTransactionsLeft:numberTransactionsLeft}=unstake,newUnstake=unstake,balance=await api.db.findOne("balances",{account:account,symbol:symbol}),token=await api.db.findOne("tokens",{symbol:symbol});let tokensToRelease=0,nextTokensToRelease=0;if(api.assert(null!==balance,"balance does not exist")&&(1===numberTransactionsLeft?(tokensToRelease=quantityLeft,await api.db.remove("pendingUnstakes",unstake)):(tokensToRelease=api.BigNumber(quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN),newUnstake.quantityLeft=api.BigNumber(newUnstake.quantityLeft).minus(tokensToRelease).toFixed(token.precision),newUnstake.numberTransactionsLeft-=1,nextTokensToRelease=1===newUnstake.numberTransactionsLeft?newUnstake.quantityLeft:tokensToRelease,newUnstake.nextTransactionTimestamp=api.BigNumber(newUnstake.nextTransactionTimestamp).plus(newUnstake.millisecPerPeriod).toNumber(),await api.db.update("pendingUnstakes",newUnstake)),api.BigNumber(tokensToRelease).gt(0))){const originalBalance=balance.balance,originalPendingStake=balance.pendingUnstake;balance.balance=calculateBalance(balance.balance,tokensToRelease,token.precision,!0),balance.pendingUnstake=calculateBalance(balance.pendingUnstake,tokensToRelease,token.precision,!1),api.assert(api.BigNumber(balance.pendingUnstake).lt(originalPendingStake)&&api.BigNumber(balance.balance).gt(originalBalance),"cannot subtract")&&(api.BigNumber(nextTokensToRelease).gt(0)&&(balance.stake=calculateBalance(balance.stake,nextTokensToRelease,token.precision,!1),token.totalStaked=calculateBalance(token.totalStaked,nextTokensToRelease,token.precision,!1),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:symbol,quantity:api.BigNumber(nextTokensToRelease).negated()}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token})),await api.db.update("balances",balance),await api.db.update("tokens",token),api.emit("unstake",{account:account,symbol:symbol,quantity:tokensToRelease}))}};actions.checkPendingUnstakes=async()=>{if(api.assert("null"===api.sender,"not authorized")){const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();let pendingUnstakes=await api.db.find("pendingUnstakes",{nextTransactionTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUnstakes=pendingUnstakes.length;for(;nbPendingUnstakes>0;){for(let index=0;index<nbPendingUnstakes;index+=1){const pendingUnstake=pendingUnstakes[index];await processUnstake(pendingUnstake)}pendingUnstakes=await api.db.find("pendingUnstakes",{nextTransactionTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUnstakes=pendingUnstakes.length}}},actions.enableStaking=async payload=>{const{symbol:symbol,unstakingCooldown:unstakingCooldown,numberTransactions:numberTransactions,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{enableStakingFee:enableStakingFee}=params,utilityTokenBalance=await api.db.findOne("balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),enoughFunds=utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(enableStakingFee),authorized=void 0===enableStakingFee||api.BigNumber(enableStakingFee).lte(0)||enoughFunds;if(api.assert(authorized,"you must have enough tokens to cover  fees")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol,"invalid symbol")&&api.assert(unstakingCooldown&&Number.isInteger(unstakingCooldown)&&unstakingCooldown>0&&unstakingCooldown<=18250,"unstakingCooldown must be an integer between 1 and 18250")&&api.assert(numberTransactions&&Number.isInteger(numberTransactions)&&numberTransactions>0&&numberTransactions<=18250,"numberTransactions must be an integer between 1 and 18250")){const token=await api.db.findOne("tokens",{symbol:symbol});api.assert(null!==token,"symbol does not exist")&&api.assert(token.issuer===api.sender,"must be the issuer")&&api.assert(void 0===token.stakingEnabled||!1===token.stakingEnabled,"staking already enabled")&&(token.stakingEnabled=!0,token.totalStaked="0",token.unstakingCooldown=unstakingCooldown,token.numberTransactions=numberTransactions,await api.db.update("tokens",token),api.BigNumber(enableStakingFee).gt(0)&&await actions.transfer({to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:enableStakingFee,isSignedWithActiveKey:isSignedWithActiveKey}))}},actions.stake=async payload=>{const{symbol:symbol,to:to,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol}),finalTo=to.trim();if(api.assert(api.isValidAccountName(finalTo),"invalid to")&&api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(api.BigNumber(quantity).gt(0),"must stake positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(api.sender,token,quantity,"balances"))){!1===await addStake(finalTo,token,quantity)?await addBalance(api.sender,token,quantity,"balances"):(api.emit("stake",{account:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo}),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token}))}}},actions.stakeFromContract=async payload=>{const{symbol:symbol,to:to,callingContractInfo:callingContractInfo}=payload;let quantity=payload.quantity;if(callingContractInfo&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol}),finalTo=to.trim();if(api.assert(api.isValidAccountName(finalTo),"invalid to")&&api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(api.BigNumber(quantity).gt(0),"must stake positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await subBalance(callingContractInfo.name,token,quantity,"contractsBalances"))){!1===await addStake(finalTo,token,quantity)?await addBalance(callingContractInfo.name,token,quantity,"balances"):(api.emit("stakeFromContract",{account:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo}),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token}))}}};const validateAvailableStake=async(balance,token,quantity)=>{let availableStakeBalance=api.BigNumber(balance.stake);return await findAndProcessAll("pendingUnstakes",{symbol:balance.symbol,account:balance.account},async pendingUnstake=>{if(pendingUnstake.numberTransactionsLeft>1){const tokensToRelease=api.BigNumber(pendingUnstake.quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN);availableStakeBalance=availableStakeBalance.minus(pendingUnstake.quantityLeft).plus(tokensToRelease)}}),api.assert(availableStakeBalance.gte(quantity),"overdrawn stake")},startUnstake=async(account,token,quantity)=>{const balance=await api.db.findOne("balances",{account:account,symbol:token.symbol});if(!api.assert(null!==balance,"balance does not exist")||!await validateAvailableStake(balance,token,quantity))return!1;{const originalStake=balance.stake,originalPendingStake=balance.pendingUnstake,nextTokensToRelease=token.numberTransactions>1?api.BigNumber(quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN):quantity;balance.stake=calculateBalance(balance.stake,nextTokensToRelease,token.precision,!1),balance.pendingUnstake=calculateBalance(balance.pendingUnstake,quantity,token.precision,!0),api.assert(api.BigNumber(balance.stake).lt(originalStake)&&api.BigNumber(balance.pendingUnstake).gt(originalPendingStake),"cannot subtract")&&(await api.db.update("balances",balance),token.totalStaked=calculateBalance(token.totalStaked,nextTokensToRelease,token.precision,!1),await api.db.update("tokens",token),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===token.symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:token.symbol,quantity:api.BigNumber(nextTokensToRelease).negated()}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token}))}const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),cooldownPeriodMillisec=24*token.unstakingCooldown*3600*1e3,millisecPerPeriod=api.BigNumber(cooldownPeriodMillisec).dividedBy(token.numberTransactions).integerValue(api.BigNumber.ROUND_DOWN),nextTransactionTimestamp=api.BigNumber(blockDate.getTime()).plus(millisecPerPeriod).toNumber(),unstake={account:account,symbol:token.symbol,quantity:quantity,quantityLeft:quantity,nextTransactionTimestamp:nextTransactionTimestamp,numberTransactionsLeft:token.numberTransactions,millisecPerPeriod:millisecPerPeriod,txID:api.transactionId};return await api.db.insert("pendingUnstakes",unstake),!0};actions.unstake=async payload=>{const{symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const token=await api.db.findOne("tokens",{symbol:symbol});api.assert(null!==token,"symbol does not exist")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(api.BigNumber(quantity).gt(0),"must unstake positive quantity")&&(quantity=api.BigNumber(quantity).toFixed(token.precision),await startUnstake(api.sender,token,quantity)&&api.emit("unstakeStart",{account:api.sender,symbol:symbol,quantity:quantity}))}};const processCancelUnstake=async unstake=>{const{account:account,symbol:symbol,quantity:quantity,quantityLeft:quantityLeft,numberTransactionsLeft:numberTransactionsLeft}=unstake,balance=await api.db.findOne("balances",{account:account,symbol:symbol}),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==balance,"balance does not exist")&&api.assert(api.BigNumber(balance.pendingUnstake).gte(quantityLeft),"overdrawn pendingUnstake")){const originalStake=balance.stake,originalPendingStake=balance.pendingUnstake,tokensToRelease=numberTransactionsLeft>1?api.BigNumber(quantity).dividedBy(token.numberTransactions).toFixed(token.precision,api.BigNumber.ROUND_DOWN):quantityLeft;if(balance.stake=calculateBalance(balance.stake,tokensToRelease,token.precision,!0),balance.pendingUnstake=calculateBalance(balance.pendingUnstake,quantityLeft,token.precision,!1),api.assert(api.BigNumber(balance.pendingUnstake).lt(originalPendingStake)&&api.BigNumber(balance.stake).gt(originalStake),"cannot subtract"))return await api.db.update("balances",balance),token.totalStaked=calculateBalance(token.totalStaked,tokensToRelease,token.precision,!0),await api.db.update("tokens",token),api.emit("unstakeCancel",{account:account,symbol:symbol,quantity:quantityLeft}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:symbol,quantity:tokensToRelease}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token}),!0}return!1};actions.cancelUnstake=async payload=>{const{txID:txID,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(txID&&"string"==typeof txID,"invalid params")){const unstake=await api.db.findOne("pendingUnstakes",{account:api.sender,txID:txID});api.assert(unstake,"unstake does not exist")&&await processCancelUnstake(unstake)&&await api.db.remove("pendingUnstakes",unstake)}},actions.enableDelegation=async payload=>{const{symbol:symbol,undelegationCooldown:undelegationCooldown,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{enableDelegationFee:enableDelegationFee}=params,utilityTokenBalance=await api.db.findOne("balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),enoughFunds=utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(enableDelegationFee),authorized=void 0===enableDelegationFee||api.BigNumber(enableDelegationFee).lte(0)||enoughFunds;if(api.assert(authorized,"you must have enough tokens to cover  fees")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol,"invalid symbol")&&api.assert(undelegationCooldown&&Number.isInteger(undelegationCooldown)&&undelegationCooldown>0&&undelegationCooldown<=18250,"undelegationCooldown must be an integer between 1 and 18250")){const token=await api.db.findOne("tokens",{symbol:symbol});api.assert(null!==token,"symbol does not exist")&&api.assert(token.issuer===api.sender,"must be the issuer")&&api.assert(!0===token.stakingEnabled,"staking not enabled")&&api.assert(void 0===token.delegationEnabled||!1===token.delegationEnabled,"delegation already enabled")&&(token.delegationEnabled=!0,token.undelegationCooldown=undelegationCooldown,await api.db.update("tokens",token),api.BigNumber(enableDelegationFee).gt(0)&&await actions.transfer({to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:enableDelegationFee,isSignedWithActiveKey:isSignedWithActiveKey}))}},actions.delegate=async payload=>{const{symbol:symbol,to:to,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalTo=to.trim();if(api.assert(api.isValidAccountName(finalTo),"invalid to")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.delegationEnabled,"delegation not enabled")&&api.assert(finalTo!==api.sender,"cannot delegate to yourself")&&api.assert(api.BigNumber(quantity).gt(0),"must delegate positive quantity")){quantity=api.BigNumber(quantity).toFixed(token.precision);const balanceFrom=await api.db.findOne("balances",{account:api.sender,symbol:symbol});if(api.assert(null!==balanceFrom,"balanceFrom does not exist")&&await validateAvailableStake(balanceFrom,token,quantity)){void 0===balanceFrom.stake?(balanceFrom.stake="0",balanceFrom.pendingUnstake="0",balanceFrom.delegationsIn="0",balanceFrom.delegationsOut="0",balanceFrom.pendingUndelegations="0"):void 0===balanceFrom.delegationsIn&&(balanceFrom.delegationsIn="0",balanceFrom.delegationsOut="0",balanceFrom.pendingUndelegations="0",balanceFrom.delegatedStake&&(delete balanceFrom.delegatedStake,delete balanceFrom.receivedStake));let balanceTo=await api.db.findOne("balances",{account:finalTo,symbol:symbol});null===balanceTo?(balanceTo=balanceTemplate,balanceTo.account=finalTo,balanceTo.symbol=symbol,balanceTo=await api.db.insert("balances",balanceTo)):void 0===balanceTo.stake?(balanceTo.stake="0",balanceTo.pendingUnstake="0",balanceTo.delegationsIn="0",balanceTo.delegationsOut="0",balanceTo.pendingUndelegations="0"):void 0===balanceTo.delegationsIn&&(balanceTo.delegationsIn="0",balanceTo.delegationsOut="0",balanceTo.pendingUndelegations="0",balanceTo.delegatedStake&&(delete balanceTo.delegatedStake,delete balanceTo.receivedStake));let delegation=await api.db.findOne("delegations",{to:finalTo,from:api.sender,symbol:symbol});const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();null==delegation?(balanceFrom.stake=calculateBalance(balanceFrom.stake,quantity,token.precision,!1),balanceFrom.delegationsOut=calculateBalance(balanceFrom.delegationsOut,quantity,token.precision,!0),await api.db.update("balances",balanceFrom),balanceTo.delegationsIn=calculateBalance(balanceTo.delegationsIn,quantity,token.precision,!0),await api.db.update("balances",balanceTo),delegation={},delegation.from=api.sender,delegation.to=finalTo,delegation.symbol=symbol,delegation.quantity=quantity,delegation.created=timestamp,delegation.updated=timestamp,await api.db.insert("delegations",delegation),api.emit("delegate",{to:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&(await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:api.sender}),await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo})),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity,delegated:!0}),await api.executeSmartContract("mining","handleStakeChange",{account:api.sender,symbol:symbol,quantity:api.BigNumber(quantity).negated()}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:api.sender,token:token}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token})):(balanceFrom.stake=calculateBalance(balanceFrom.stake,quantity,token.precision,!1),balanceFrom.delegationsOut=calculateBalance(balanceFrom.delegationsOut,quantity,token.precision,!0),await api.db.update("balances",balanceFrom),balanceTo.delegationsIn=calculateBalance(balanceTo.delegationsIn,quantity,token.precision,!0),await api.db.update("balances",balanceTo),delegation.quantity=calculateBalance(delegation.quantity,quantity,token.precision,!0),delegation.updated=timestamp,await api.db.update("delegations",delegation),api.emit("delegate",{to:finalTo,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&(await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:api.sender}),await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalTo})),await api.executeSmartContract("mining","handleStakeChange",{account:finalTo,symbol:symbol,quantity:quantity,delegated:!0}),await api.executeSmartContract("mining","handleStakeChange",{account:api.sender,symbol:symbol,quantity:api.BigNumber(quantity).negated()}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:api.sender,token:token}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalTo,token:token}))}}}}},actions.undelegate=async payload=>{const{symbol:symbol,from:from,isSignedWithActiveKey:isSignedWithActiveKey}=payload;let quantity=payload.quantity;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&from&&"string"==typeof from&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const finalFrom=from.trim();if(api.assert(finalFrom.length>=3&&finalFrom.length<=16,"invalid from")){const token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(countDecimals(quantity)<=token.precision,"symbol precision mismatch")&&api.assert(!0===token.delegationEnabled,"delegation not enabled")&&api.assert(finalFrom!==api.sender,"cannot undelegate from yourself")&&api.assert(api.BigNumber(quantity).gt(0),"must undelegate positive quantity")){quantity=api.BigNumber(quantity).toFixed(token.precision);const balanceTo=await api.db.findOne("balances",{account:api.sender,symbol:symbol});if(api.assert(null!==balanceTo,"balanceTo does not exist")&&api.assert(api.BigNumber(balanceTo.delegationsOut).gte(quantity),"overdrawn delegation")){const balanceFrom=await api.db.findOne("balances",{account:finalFrom,symbol:symbol});if(api.assert(null!==balanceFrom,"balanceFrom does not exist")){const delegation=await api.db.findOne("delegations",{to:finalFrom,from:api.sender,symbol:symbol});if(api.assert(null!==delegation,"delegation does not exist")&&api.assert(api.BigNumber(delegation.quantity).gte(quantity),"overdrawn delegation")){balanceTo.pendingUndelegations=calculateBalance(balanceTo.pendingUndelegations,quantity,token.precision,!0),balanceTo.delegationsOut=calculateBalance(balanceTo.delegationsOut,quantity,token.precision,!1),await api.db.update("balances",balanceTo),balanceFrom.delegationsIn=calculateBalance(balanceFrom.delegationsIn,quantity,token.precision,!1),await api.db.update("balances",balanceFrom),delegation.quantity=calculateBalance(delegation.quantity,quantity,token.precision,!1),api.BigNumber(delegation.quantity).gt(0)?await api.db.update("delegations",delegation):await api.db.remove("delegations",delegation);const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),cooldownPeriodMillisec=24*token.undelegationCooldown*3600*1e3,completeTimestamp=blockDate.getTime()+cooldownPeriodMillisec,undelegation={account:api.sender,symbol:token.symbol,quantity:quantity,completeTimestamp:completeTimestamp,txID:api.transactionId};await api.db.insert("pendingUndelegations",undelegation),api.emit("undelegateStart",{from:finalFrom,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:finalFrom}),await api.executeSmartContract("mining","handleStakeChange",{account:finalFrom,symbol:symbol,quantity:api.BigNumber(quantity).negated(),delegated:!0}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:finalFrom,token:token})}}}}}}};const processUndelegation=async undelegation=>{const{account:account,symbol:symbol,quantity:quantity}=undelegation,balance=await api.db.findOne("balances",{account:account,symbol:symbol}),token=await api.db.findOne("tokens",{symbol:symbol});if(api.assert(null!==balance,"balance does not exist")){const originalStake=balance.stake,originalPendingUndelegations=balance.pendingUndelegations;balance.stake=calculateBalance(balance.stake,quantity,token.precision,!0),balance.pendingUndelegations=calculateBalance(balance.pendingUndelegations,quantity,token.precision,!1),api.assert(api.BigNumber(balance.pendingUndelegations).lt(originalPendingUndelegations)&&api.BigNumber(balance.stake).gt(originalStake),"cannot subtract")&&(await api.db.update("balances",balance),await api.db.remove("pendingUndelegations",undelegation),api.emit("undelegateDone",{account:account,symbol:symbol,quantity:quantity}),"'${CONSTANTS.GOVERNANCE_TOKEN_SYMBOL}$'"===symbol&&await api.executeSmartContract("witnesses","updateWitnessesApprovals",{account:account}),await api.executeSmartContract("mining","handleStakeChange",{account:account,symbol:symbol,quantity:quantity}),await api.executeSmartContract("tokenfunds","updateProposalApprovals",{account:account,token:token}))}};actions.checkPendingUndelegations=async()=>{if(api.assert("null"===api.sender,"not authorized")){const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();let pendingUndelegations=await api.db.find("pendingUndelegations",{completeTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUndelegations=pendingUndelegations.length;for(;nbPendingUndelegations>0;){for(let index=0;index<nbPendingUndelegations;index+=1){const pendingUndelegation=pendingUndelegations[index];await processUndelegation(pendingUndelegation)}pendingUndelegations=await api.db.find("pendingUndelegations",{completeTimestamp:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbPendingUndelegations=pendingUndelegations.length}}};
>>>>>>> refs/remotes/origin/qa
