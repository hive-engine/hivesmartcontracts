const UTILITY_TOKEN_SYMBOL="BEE",UTILITY_TOKEN_PRECISION=8,HIVE_PEGGED_SYMBOL="SWAP.HIVE",HIVE_PEGGED_SYMBOL_PRECISION=8,CONTRACT_NAME="claimdrops";actions.createSSC=async()=>{if(!1===await api.db.tableExists("claimdrops")){await api.db.createTable("claimdrops",["claimdropId","symbol"]),await api.db.createTable("params");const params={creationFee:"50",feePerClaim:"0.1",maxExpiryTime:7776e6};await api.db.insert("params",params)}},actions.updateParams=async payload=>{if(api.assert(api.sender===api.owner,"not authorized")){const{creationFee:creationFee,feePerClaim:feePerClaim,maxExpiryTime:maxExpiryTime}=payload,params=await api.db.findOne("params",{});if(creationFee){if(!api.assert("string"==typeof creationFee&&!api.BigNumber(creationFee).isNaN()&&api.BigNumber(creationFee).gte(0),"invalid creationFee"))return;params.creationFee=creationFee}if(feePerClaim){if(!api.assert("string"==typeof feePerClaim&&!api.BigNumber(feePerClaim).isNaN()&&api.BigNumber(feePerClaim).gte(0),"invalid feePerClaim"))return;params.feePerClaim=feePerClaim}if(maxExpiryTime){if(!api.assert(Number.isInteger(maxExpiryTime)&&maxExpiryTime>0,"invalid maxExpiryTime"))return;params.maxExpiryTime=maxExpiryTime}await api.db.update("params",params)}};const hasValidPrecision=(value,precision)=>api.BigNumber(value).dp()<=precision,transferIsSuccessful=(result,action,from,to,symbol,quantity)=>!(void 0!==result.errors||!result.events||void 0===result.events.find(el=>"tokens"===el.contract&&el.event===action&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol)),getTimestamp=value=>{try{return new Date(`${value}.00Z`).getTime()}catch(e){return!1}},validateList=(list,precision)=>{const parsedList=[];for(let i=0;i<list.length;i+=1){const{0:account,1:limit}=list[i];if(!(api.assert(account,`list[${i}]: account name cannot be undefined`)&&api.assert(api.isValidAccountName(account),`list[${i}]: invalid account name`)&&api.assert(limit,`list[${i}]: limit cannot be undefined`)&&api.assert(!api.BigNumber(limit).isNaN(),`list[${i}]: invalid limit`)&&api.assert(api.BigNumber(limit).gt(0),`list[${i}]: limit must be positive`)&&api.assert(hasValidPrecision(limit,precision),`list[${i}]: limit precision mismatch`)&&api.assert(api.BigNumber(limit).lte(Number.MAX_SAFE_INTEGER),`list[${i}]: limit must be lower than ${Number.MAX_SAFE_INTEGER}`)))break;parsedList.push({account:account,limit:limit})}return!(!api.assert(list.length>0,"list cannot be empty")||parsedList.length!==list.length)&&parsedList},isValidowner=async(name,type)=>{if("user"===type){if(api.isValidAccountName(name))return!0}else if("contract"===type){if(await api.db.findContract(name))return!0}return!1},expireClaimdrop=async claimdrop=>{const{remainingPool:remainingPool,symbol:symbol,owner:owner,ownerType:ownerType}=claimdrop;api.BigNumber(remainingPool).gt(0)&&await api.transferTokens(owner,symbol,remainingPool,ownerType),await api.db.remove("claimdrops",claimdrop),api.emit("expire",{claimdropId:claimdrop.claimdropId})},removeExpiredClaimdrops=async()=>{const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();let expired=await api.db.find("claimdrops",{expiry:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbExpired=expired.length;for(;nbExpired>0;){for(let i=0;i<nbExpired;i+=1){const claimdrop=expired[i];await expireClaimdrop(claimdrop)}expired=await api.db.find("claimdrops",{expiry:{$lte:timestamp}},1e3,0,[{index:"_id",descending:!1}]),nbExpired=expired.length}};actions.create=async payload=>{const{symbol:symbol,price:price,pool:pool,maxClaims:maxClaims,expiry:expiry,owner:owner,ownerType:ownerType,list:list,limit:limit,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&price&&"string"==typeof price&&!api.BigNumber(price).isNaN()&&pool&&"string"==typeof pool&&!api.BigNumber(pool).isNaN()&&maxClaims&&Number.isInteger(maxClaims)&&expiry&&"string"==typeof expiry&&owner&&"string"==typeof owner&&ownerType&&"string"==typeof ownerType&&(!limit&&list&&Array.isArray(list)||!list&&limit&&"string"==typeof limit&&!api.BigNumber(limit).isNaN()),"invalid params")){const token=await api.db.findOneInTable("tokens","tokens",{symbol:symbol}),params=await api.db.findOne("params",{}),timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime(),expiryTimestamp=getTimestamp(expiry),maxExpiryTimestamp=api.BigNumber(timestamp).plus(params.maxExpiryTime).toNumber(),utilityToken=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"BEE"}),nativeToken=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:symbol});if(api.assert(null!==token,"symbol does not exist")&&api.assert(api.BigNumber(price).gt(0),"price must be positive")&&api.assert(hasValidPrecision(price,8),"price precision mismatch")&&api.assert(api.BigNumber(pool).gt(0),"pool must be positive")&&api.assert(hasValidPrecision(pool,token.precision),"pool precision mismatch")&&api.assert(api.BigNumber(maxClaims).gt(0),"maxClaims must be positive number")&&api.assert(api.BigNumber(maxClaims).lte(Number.MAX_SAFE_INTEGER),`maxClaims must be lower than ${Number.MAX_SAFE_INTEGER}`)&&api.assert(expiryTimestamp&&expiryTimestamp>timestamp,"invalid expiry")&&api.assert(expiryTimestamp<=maxExpiryTimestamp,"expiry exceeds limit")&&api.assert("user"===ownerType||"contract"===ownerType,"invalid ownerType")&&api.assert(await isValidowner(owner,ownerType),"invalid owner")){const fee=api.BigNumber(params.feePerClaim).times(maxClaims).plus(params.creationFee).toFixed(8);if(api.assert(utilityToken&&utilityToken.balance&&api.BigNumber(utilityToken.balance).gte(fee),"you must have enough tokens to cover the creation fee")&&api.assert(nativeToken&&nativeToken.balance&&api.BigNumber(nativeToken.balance).gte(pool),"you must have enough tokens to cover the claimdrop pool")){const claimdrop={claimdropId:api.transactionId,symbol:symbol,price:price,remainingPool:pool,remainingClaims:maxClaims,claims:[],expiry:expiryTimestamp,owner:owner,ownerType:ownerType,sender:api.sender};if(list){const parsedList=validateList(list,token.precision);if(!parsedList)return;claimdrop.list=parsedList}else if(limit){if(!(api.assert(api.BigNumber(limit).gt(0),"limit must be positive")&&api.assert(hasValidPrecision(limit,token.precision),"limit precision mismatch")&&api.assert(api.BigNumber(limit).lte(Number.MAX_SAFE_INTEGER),`limit must be lower than ${Number.MAX_SAFE_INTEGER}`)))return;claimdrop.limit=limit}const tokenTransfer=await api.executeSmartContract("tokens","transferToContract",{to:"claimdrops",symbol:symbol,quantity:pool});if(transferIsSuccessful(tokenTransfer,"transferToContract",api.sender,"claimdrops",symbol,pool)){const feeTransfer=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"BEE",quantity:fee,isSignedWithActiveKey:isSignedWithActiveKey});if(transferIsSuccessful(feeTransfer,"transfer",api.sender,"null","BEE",fee)){const res=await api.db.insert("claimdrops",claimdrop);api.emit("create",{claimdropId:res.claimdropId})}else await api.transferTokens(api.sender,symbol,pool,"user")}}}}},actions.claim=async payload=>{const{claimdropId:claimdropId,quantity:quantity,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(await removeExpiredClaimdrops(),api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(claimdropId&&"string"==typeof claimdropId&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params")){const claimdrop=await api.db.findOne("claimdrops",{claimdropId:claimdropId});if(api.assert(claimdrop,"claimdrop does not exist or has been expired")){const token=await api.db.findOneInTable("tokens","tokens",{symbol:claimdrop.symbol});if(api.assert(claimdrop.remainingClaims>0,"maximum claims limit has been reached")&&api.assert(api.BigNumber(quantity).gt(0),"quantity must be positive")&&api.assert(hasValidPrecision(quantity,token.precision),"quantity precision mismatch")&&api.assert(api.BigNumber(claimdrop.remainingPool).gt(0),"pool limit has been reached")&&api.assert(api.BigNumber(claimdrop.remainingPool).minus(quantity).gte(0),"quantity exceeds pool")){const price=api.BigNumber(claimdrop.price).times(quantity).toFixed(8);if(!api.assert(api.BigNumber(price).gt(0),"quantity too low"))return;const hivePeggedToken=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"SWAP.HIVE"}),previousClaimIndex=claimdrop.claims.findIndex(el=>el.account===api.sender),previousClaim=claimdrop.claims[previousClaimIndex],claim=previousClaim?{account:previousClaim.account,quantity:api.BigNumber(previousClaim.quantity).plus(quantity)}:{account:api.sender,quantity:quantity};let limit;if(claimdrop.list){const accountInList=claimdrop.list.find(el=>el.account===claim.account);if(!api.assert(accountInList,"you are not eligible"))return;({limit:limit}=accountInList)}else({limit:limit}=claimdrop);if(previousClaim&&!api.assert(!api.BigNumber(previousClaim.quantity).eq(limit),"you have reached your limit"))return;if(api.assert(hivePeggedToken&&hivePeggedToken.balance&&api.BigNumber(hivePeggedToken.balance).gte(price),"you must have enough tokens to cover the price")&&api.assert(api.BigNumber(claim.quantity).lte(limit),"quantity exceeds your limit")){const transferType="user"===claimdrop.ownerType?"transfer":"transferToContract",transfer=await api.executeSmartContract("tokens",transferType,{to:claimdrop.owner,symbol:"SWAP.HIVE",quantity:price});transferIsSuccessful(transfer,transferType,api.sender,claimdrop.owner,"SWAP.HIVE",price)&&(await api.transferTokens(api.sender,claimdrop.symbol,quantity,"user"),previousClaim?claimdrop.claims[previousClaimIndex]=claim:claimdrop.claims.push(claim),claimdrop.remainingPool=api.BigNumber(claimdrop.remainingPool).minus(quantity),claimdrop.remainingClaims-=1,await api.db.update("claimdrops",claimdrop),api.emit("claim",{claimdropId:claimdrop.claimdropId,quantity:quantity}))}}}}},actions.expire=async payload=>{const{claimdropId:claimdropId,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(claimdropId&&"string"==typeof claimdropId,"invalid params")){const claimdrop=await api.db.findOne("claimdrops",{claimdropId:claimdropId});api.assert(claimdrop,"claimdrop does not exist or already expired")&&api.assert(api.sender===claimdrop.owner||api.sender===claimdrop.sender,"not authorized")&&await expireClaimdrop(claimdrop)}};