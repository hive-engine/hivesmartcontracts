const CONTRACT_NAME="nftmarket",MAX_NUM_UNITS_OPERABLE=50;actions.createSSC=async()=>{!1===await api.db.tableExists("params")&&await api.db.createTable("params",["symbol"])};const isTokenTransferVerified=(result,from,to,symbol,quantity,eventStr)=>!(void 0!==result.errors||!result.events||void 0===result.events.find((el=>"tokens"===el.contract&&el.event===eventStr&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol))),countDecimals=value=>api.BigNumber(value).dp(),isValidHiveAccountLength=account=>account.length>=3&&account.length<=16,makeMapKey=(account,type)=>account+"-"+type,makeGroupingKey=(grouping,groupBy)=>{let key="";return groupBy.forEach((name=>{key=key+":"+name+":"+grouping[name]})),key},isValidIdArray=arr=>{try{if(!api.assert(arr&&"object"==typeof arr&&Array.isArray(arr),"invalid id list"))return!1;if(!api.assert(arr.length<=50,"cannot act on more than 50 IDs at once"))return!1;for(let i=0;i<arr.length;i+=1){const id=arr[i];if(!api.assert(id&&"string"==typeof id&&!api.BigNumber(id).isNaN()&&api.BigNumber(id).gt(0),"invalid id list"))return!1}}catch(e){return!1}return!0};actions.enableMarket=async payload=>{const{symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol,"invalid params")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(api.assert(null!==nft,"symbol does not exist")&&api.assert(nft.issuer===api.sender,"must be the issuer")){const marketTableName=symbol+"sellBook",metricsTableName=symbol+"openInterest",historyTableName=symbol+"tradesHistory",tableExists=await api.db.tableExists(marketTableName);api.assert(!1===tableExists,"market already enabled")&&(await api.db.createTable(marketTableName,["ownedBy","account","nftId","grouping","priceSymbol"]),await api.db.createTable(metricsTableName,["side","priceSymbol","grouping"]),await api.db.createTable(historyTableName,["priceSymbol","timestamp"]),api.emit("enableMarket",{symbol:symbol}))}}};const updateOpenInterest=async(side,symbol,priceSymbol,groups,groupBy)=>{const metricsTableName=symbol+"openInterest",groupKeys=[];for(const info of Object.values(groups))groupKeys.push(info.grouping);if(groupKeys.length<=0)return;const openInterest=await api.db.find(metricsTableName,{side:side,priceSymbol:priceSymbol,grouping:{$in:groupKeys}},50,0,[{index:"side",descending:!1},{index:"priceSymbol",descending:!1},{index:"grouping",descending:!1}]);for(let i=0;i<openInterest.length;i+=1){const metric=openInterest[i],key=makeGroupingKey(metric.grouping,groupBy);key in groups&&(groups[key].isInCollection=!0,metric.count+=groups[key].count,metric.count<0&&(metric.count=0),await api.db.update(metricsTableName,metric))}for(const info of Object.values(groups))if(!info.isInCollection){const finalCount=info.count>0?info.count:0,newMetric={side:side,priceSymbol:priceSymbol,grouping:info.grouping,count:finalCount};await api.db.insert(metricsTableName,newMetric)}},updateTradesHistory=async(type,account,ownedBy,counterparties,symbol,priceSymbol,price,isMarketFeePaid,marketAccount,fee,isAgentFeePaid,agentAccount,agentFee,volume)=>{const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),timestampSec=blockDate.getTime()/1e3,timestampMinus24hrs=blockDate.setUTCDate(blockDate.getUTCDate()-1)/1e3,historyTableName=symbol+"tradesHistory";let tradesToDelete=await api.db.find(historyTableName,{priceSymbol:priceSymbol,timestamp:{$lt:timestampMinus24hrs}},1e3,0,[{index:"_id",descending:!1}]),nbTradesToDelete=tradesToDelete.length;for(;nbTradesToDelete>0;){for(let index=0;index<nbTradesToDelete;index+=1){const trade=tradesToDelete[index];await api.db.remove(historyTableName,trade)}tradesToDelete=await api.db.find(historyTableName,{priceSymbol:priceSymbol,timestamp:{$lt:timestampMinus24hrs}},1e3,0,[{index:"_id",descending:!1}]),nbTradesToDelete=tradesToDelete.length}const newTrade={};newTrade.type=type,newTrade.account=account,newTrade.ownedBy=ownedBy,newTrade.counterparties=counterparties,newTrade.priceSymbol=priceSymbol,newTrade.price=price,isMarketFeePaid&&(newTrade.marketAccount=marketAccount,newTrade.fee=fee),isAgentFeePaid&&(newTrade.agentAccount=agentAccount,newTrade.agentFee=agentFee),newTrade.timestamp=timestampSec,newTrade.volume=volume,await api.db.insert(historyTableName,newTrade)};actions.setMarketParams=async payload=>{const{symbol:symbol,officialMarket:officialMarket,agentCut:agentCut,minFee:minFee,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(symbol&&"string"==typeof symbol,"invalid params"))return!1;if(void 0===officialMarket&&void 0===agentCut&&void 0===minFee)return!1;const marketTableName=symbol+"sellBook",tableExists=await api.db.tableExists(marketTableName);if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(tableExists,"market not enabled for symbol")&&api.assert((void 0===officialMarket||officialMarket&&"string"==typeof officialMarket&&isValidHiveAccountLength(officialMarket.trim().toLowerCase()))&&(void 0===agentCut||"number"==typeof agentCut&&agentCut>=0&&agentCut<=1e4&&Number.isInteger(agentCut))&&(void 0===minFee||"number"==typeof minFee&&minFee>=0&&minFee<=1e4&&Number.isInteger(minFee)),"invalid params")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(nft&&api.assert(nft.issuer===api.sender,"must be the issuer")){let shouldUpdate=!1,isFirstTimeSet=!1;const update={symbol:symbol};let params=await api.db.findOne("params",{symbol:symbol});params||(isFirstTimeSet=!0,params={symbol:symbol});const finalOfficialMarket=void 0!==officialMarket?officialMarket.trim().toLowerCase():null;if(void 0===officialMarket||void 0!==params.officialMarket&&finalOfficialMarket===params.officialMarket||(void 0!==params.officialMarket&&(update.oldOfficialMarket=params.officialMarket),params.officialMarket=finalOfficialMarket,update.officialMarket=finalOfficialMarket,shouldUpdate=!0),void 0===agentCut||void 0!==params.agentCut&&agentCut===params.agentCut||(void 0!==params.agentCut&&(update.oldAgentCut=params.agentCut),params.agentCut=agentCut,update.agentCut=agentCut,shouldUpdate=!0),void 0===minFee||void 0!==params.minFee&&minFee===params.minFee||(void 0!==params.minFee&&(update.oldMinFee=params.minFee),params.minFee=minFee,update.minFee=minFee,shouldUpdate=!0),shouldUpdate)return isFirstTimeSet?await api.db.insert("params",params):await api.db.update("params",params),api.emit("setMarketParams",update),!0}}return!1},actions.changePrice=async payload=>{const{symbol:symbol,nfts:nfts,price:price,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(symbol&&"string"==typeof symbol,"invalid params"))return;const marketTableName=symbol+"sellBook",tableExists=await api.db.tableExists(marketTableName);if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&isValidIdArray(nfts)&&api.assert(price&&"string"==typeof price&&!api.BigNumber(price).isNaN(),"invalid params")&&api.assert(tableExists,"market not enabled for symbol")){const orders=await api.db.find(marketTableName,{nftId:{$in:nfts}},50,0,[{index:"nftId",descending:!1}]);if(orders.length>0){let priceSymbol="";for(let i=0;i<orders.length;i+=1){const order=orders[i];if(""===priceSymbol&&({priceSymbol:priceSymbol}=order),!api.assert(order.account===api.sender&&"u"===order.ownedBy,"all orders must be your own")||!api.assert(priceSymbol===order.priceSymbol,"all orders must have the same price symbol"))return}const token=await api.db.findOneInTable("tokens","tokens",{symbol:priceSymbol});if(api.assert(token&&api.BigNumber(price).gt(0)&&countDecimals(price)<=token.precision,"invalid price")){const finalPrice=api.BigNumber(price).toFixed(token.precision);for(let i=0;i<orders.length;i+=1){const order=orders[i],oldPrice=order.price;order.price=finalPrice,order.priceDec={$numberDecimal:finalPrice},await api.db.update(marketTableName,order),api.emit("changePrice",{symbol:symbol,nftId:order.nftId,oldPrice:oldPrice,newPrice:order.price,priceSymbol:order.priceSymbol,orderId:order._id})}}}}},actions.cancel=async payload=>{const{symbol:symbol,nfts:nfts,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(symbol&&"string"==typeof symbol,"invalid params"))return;const marketTableName=symbol+"sellBook",tableExists=await api.db.tableExists(marketTableName);if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&isValidIdArray(nfts)&&api.assert(tableExists,"market not enabled for symbol")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(!api.assert(nft&&nft.groupBy&&nft.groupBy.length>0,"market grouping not set"))return;const orders=await api.db.find(marketTableName,{nftId:{$in:nfts}},50,0,[{index:"nftId",descending:!1}]);if(orders.length>0){const ids=[],idMap={};let priceSymbol="";for(let i=0;i<orders.length;i+=1){const order=orders[i];if(""===priceSymbol&&({priceSymbol:priceSymbol}=order),!api.assert(order.account===api.sender&&"u"===order.ownedBy,"all orders must be your own")||!api.assert(priceSymbol===order.priceSymbol,"all orders must have the same price symbol"))return;ids.push(order.nftId),idMap[order.nftId]=order}const nftArray=[],wrappedNfts={symbol:symbol,ids:ids};nftArray.push(wrappedNfts);const res=await api.executeSmartContract("nft","transfer",{fromType:"contract",to:api.sender,toType:"user",nfts:nftArray,isSignedWithActiveKey:isSignedWithActiveKey});if(res.events){const groupingMap={};for(let j=0;j<res.events.length;j+=1){const ev=res.events[j];if(ev.contract&&ev.event&&ev.data&&"nft"===ev.contract&&"transfer"===ev.event&&"nftmarket"===ev.data.from&&"c"===ev.data.fromType&&ev.data.to===api.sender&&"u"===ev.data.toType&&ev.data.symbol===symbol){const instanceId=ev.data.id;if(instanceId in idMap){const order=idMap[instanceId];await api.db.remove(marketTableName,order),api.emit("cancelOrder",{account:order.account,ownedBy:order.ownedBy,symbol:symbol,nftId:order.nftId,timestamp:order.timestamp,price:order.price,priceSymbol:order.priceSymbol,fee:order.fee,orderId:order._id});const key=makeGroupingKey(order.grouping,nft.groupBy),groupInfo=key in groupingMap?groupingMap[key]:{grouping:order.grouping,isInCollection:!1,count:0};groupInfo.count-=1,groupingMap[key]=groupInfo}}}await updateOpenInterest("sell",symbol,priceSymbol,groupingMap,nft.groupBy)}}}},actions.buy=async payload=>{const{symbol:symbol,nfts:nfts,marketAccount:marketAccount,expPrice:expPrice,expPriceSymbol:expPriceSymbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(symbol&&"string"==typeof symbol&&marketAccount&&"string"==typeof marketAccount&&(void 0===expPrice||expPrice&&"string"==typeof expPrice&&!api.BigNumber(expPrice).isNaN())&&(void 0===expPriceSymbol||expPriceSymbol&&"string"==typeof expPriceSymbol),"invalid params"))return;const marketTableName=symbol+"sellBook",tableExists=await api.db.tableExists(marketTableName);if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&isValidIdArray(nfts)&&api.assert(tableExists,"market not enabled for symbol")){const finalMarketAccount=marketAccount.trim().toLowerCase();if(api.assert(isValidHiveAccountLength(finalMarketAccount),"invalid market account")&&api.assert(finalMarketAccount!==api.sender,"market account cannot be same as buyer")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(!api.assert(nft&&nft.groupBy&&nft.groupBy.length>0,"market grouping not set"))return;const orders=await api.db.find(marketTableName,{nftId:{$in:nfts}},50,0,[{index:"nftId",descending:!1}]);if(orders.length>0){let priceSymbol="";for(let i=0;i<orders.length;i+=1){const order=orders[i];if(""===priceSymbol&&({priceSymbol:priceSymbol}=order),!api.assert(!("u"===order.ownedBy&&order.account===api.sender),"cannot fill your own orders")||!api.assert(priceSymbol===order.priceSymbol,"all orders must have the same price symbol"))return}if(!api.assert(void 0===expPriceSymbol||expPriceSymbol===priceSymbol,`unexpected price symbol ${priceSymbol}`))return;const token=await api.db.findOneInTable("tokens","tokens",{symbol:priceSymbol});if(!token)return;let feeTotal=api.BigNumber(0),agentFeeTotal=api.BigNumber(0),paymentTotal=api.BigNumber(0),soldNfts=[];const sellers=[],sellerMap={};for(let i=0;i<orders.length;i+=1){const order=orders[i],finalPrice=api.BigNumber(order.price),feePercent=order.fee/1e4;let finalFee=finalPrice.multipliedBy(feePercent).decimalPlaces(token.precision);finalFee.gt(finalPrice)&&(finalFee=finalPrice);let finalPayment=finalPrice.minus(finalFee).decimalPlaces(token.precision);finalPayment.lt(0)&&(finalPayment=api.BigNumber(0)),paymentTotal=paymentTotal.plus(finalPayment),feeTotal=feeTotal.plus(finalFee);const key=makeMapKey(order.account,order.ownedBy),sellerInfo=key in sellerMap?sellerMap[key]:{account:order.account,ownedBy:order.ownedBy,nftIds:[],nftSales:[],paymentTotal:api.BigNumber(0)};sellerInfo.paymentTotal=sellerInfo.paymentTotal.plus(finalPayment),sellerInfo.nftIds.push(order.nftId),sellerMap[key]=sellerInfo,sellerInfo.nftSales.push({id:order.nftId,price:finalPrice,fee:finalFee,symbol:priceSymbol})}const params=await api.db.findOne("params",{symbol:symbol}),officialMarketAccount=params&&params.officialMarket?params.officialMarket:finalMarketAccount;if(!api.assert(officialMarketAccount!==api.sender,"official market account cannot be same as buyer"))return;if(params&&params.officialMarket&&void 0!==params.agentCut&&params.agentCut>0&&feeTotal.gt(0)){const agentFeePercent=params.agentCut/1e4;agentFeeTotal=feeTotal.multipliedBy(agentFeePercent).decimalPlaces(token.precision),agentFeeTotal.gt(feeTotal)&&(agentFeeTotal=api.BigNumber(feeTotal)),feeTotal=feeTotal.minus(agentFeeTotal).decimalPlaces(token.precision),feeTotal.lt(0)&&(feeTotal=api.BigNumber(0))}const requiredBalance=paymentTotal.plus(feeTotal).plus(agentFeeTotal).toFixed(token.precision);if(!api.assert(void 0===expPrice||api.BigNumber(expPrice).eq(requiredBalance),`total required payment ${requiredBalance} ${priceSymbol} does not match expected amount`))return;const buyerBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:priceSymbol});if(!api.assert(buyerBalance&&api.BigNumber(buyerBalance.balance).gte(requiredBalance),"you must have enough tokens for payment"))return;paymentTotal=paymentTotal.toFixed(token.precision);let isMarketFeePaid=!1;if(feeTotal.gt(0)){isMarketFeePaid=!0,feeTotal=feeTotal.toFixed(token.precision);const res=await api.executeSmartContract("tokens","transfer",{to:officialMarketAccount,symbol:priceSymbol,quantity:feeTotal,isSignedWithActiveKey:isSignedWithActiveKey});if(!api.assert(isTokenTransferVerified(res,api.sender,officialMarketAccount,priceSymbol,feeTotal,"transfer"),"unable to transfer market fees"))return}let isAgentFeePaid=!1;if(agentFeeTotal.gt(0)){isAgentFeePaid=!0,agentFeeTotal=agentFeeTotal.toFixed(token.precision);const res=await api.executeSmartContract("tokens","transfer",{to:finalMarketAccount,symbol:priceSymbol,quantity:agentFeeTotal,isSignedWithActiveKey:isSignedWithActiveKey});if(!api.assert(isTokenTransferVerified(res,api.sender,finalMarketAccount,priceSymbol,agentFeeTotal,"transfer"),"unable to transfer agent fees"))return}for(const info of Object.values(sellerMap))if(info.paymentTotal.gt(0)){const contractAction="u"===info.ownedBy?"transfer":"transferToContract";info.paymentTotal=info.paymentTotal.toFixed(token.precision);const res=await api.executeSmartContract("tokens",contractAction,{to:info.account,symbol:priceSymbol,quantity:info.paymentTotal,isSignedWithActiveKey:isSignedWithActiveKey});api.assert(isTokenTransferVerified(res,api.sender,info.account,priceSymbol,info.paymentTotal,contractAction),`unable to transfer payment to ${info.account}`)&&(soldNfts=soldNfts.concat(info.nftIds),sellers.push(info))}else soldNfts=soldNfts.concat(info.nftIds),sellers.push(info);const nftArray=[],wrappedNfts={symbol:symbol,ids:soldNfts};nftArray.push(wrappedNfts),await api.executeSmartContract("nft","transfer",{fromType:"contract",to:api.sender,toType:"user",nfts:nftArray,isSignedWithActiveKey:isSignedWithActiveKey});const groupingMap={},soldSet=new Set(soldNfts);for(let i=0;i<orders.length;i+=1){const order=orders[i];if(soldSet.has(order.nftId)){await api.db.remove(marketTableName,order);const key=makeGroupingKey(order.grouping,nft.groupBy),groupInfo=key in groupingMap?groupingMap[key]:{grouping:order.grouping,isInCollection:!1,count:0};groupInfo.count-=1,groupingMap[key]=groupInfo}}await updateTradesHistory("buy",api.sender,"u",sellers,symbol,priceSymbol,requiredBalance,isMarketFeePaid,officialMarketAccount,feeTotal,isAgentFeePaid,finalMarketAccount,agentFeeTotal,soldNfts.length);const ackPacket={symbol:symbol,priceSymbol:priceSymbol,account:api.sender,ownedBy:"u",sellers:sellers,paymentTotal:paymentTotal};isMarketFeePaid&&(ackPacket.marketAccount=officialMarketAccount,ackPacket.feeTotal=feeTotal),isAgentFeePaid&&(ackPacket.agentAccount=finalMarketAccount,ackPacket.agentFeeTotal=agentFeeTotal),api.emit("hitSellOrder",ackPacket),await updateOpenInterest("sell",symbol,priceSymbol,groupingMap,nft.groupBy)}}}},actions.sell=async payload=>{const{symbol:symbol,nfts:nfts,price:price,priceSymbol:priceSymbol,fee:fee,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(symbol&&"string"==typeof symbol,"invalid params"))return;const marketTableName=symbol+"sellBook",instanceTableName=symbol+"instances",tableExists=await api.db.tableExists(marketTableName);if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(nfts&&"object"==typeof nfts&&Array.isArray(nfts)&&priceSymbol&&"string"==typeof priceSymbol&&price&&"string"==typeof price&&!api.BigNumber(price).isNaN()&&"number"==typeof fee&&fee>=0&&fee<=1e4&&Number.isInteger(fee),"invalid params")&&api.assert(nfts.length<=50,"cannot sell more than 50 NFT instances at once")&&api.assert(tableExists,"market not enabled for symbol")){const nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(!api.assert(nft&&nft.groupBy&&nft.groupBy.length>0,"market grouping not set"))return;const params=await api.db.findOne("params",{symbol:symbol});if(params&&void 0!==params.minFee&&!api.assert(fee>=params.minFee,`fee must be >= ${params.minFee}`))return;const token=await api.db.findOneInTable("tokens","tokens",{symbol:priceSymbol});if(api.assert(token&&api.BigNumber(price).gt(0)&&countDecimals(price)<=token.precision,"invalid price")){const nftArray=[],wrappedNfts={symbol:symbol,ids:nfts};nftArray.push(wrappedNfts);const res=await api.executeSmartContract("nft","transfer",{fromType:"user",to:"nftmarket",toType:"contract",nfts:nftArray,isSignedWithActiveKey:isSignedWithActiveKey});if(res.events){const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime(),finalPrice=api.BigNumber(price).toFixed(token.precision),nftIntegerIdList=[],orderDataMap={};for(let i=0;i<res.events.length;i+=1){const ev=res.events[i];if(ev.contract&&ev.event&&ev.data&&"nft"===ev.contract&&"transfer"===ev.event&&ev.data.from===api.sender&&"u"===ev.data.fromType&&"nftmarket"===ev.data.to&&"c"===ev.data.toType&&ev.data.symbol===symbol){const instanceId=ev.data.id,orderData={nftId:instanceId,grouping:{},groupingKey:""},integerId=api.BigNumber(instanceId).toNumber();nftIntegerIdList.push(integerId),orderDataMap[integerId]=orderData}}const instances=await api.db.findInTable("nft",instanceTableName,{_id:{$in:nftIntegerIdList}},50,0,[{index:"_id",descending:!1}]);for(let j=0;j<instances.length;j+=1){const instance=instances[j],grouping={};let groupingKey="";nft.groupBy.forEach((name=>{void 0!==instance.properties[name]&&null!==instance.properties[name]?grouping[name]=instance.properties[name].toString():grouping[name]="",groupingKey=groupingKey+":"+name+":"+grouping[name]})),orderDataMap[instance._id].grouping=grouping,orderDataMap[instance._id].groupingKey=groupingKey}const groupingMap={};for(let k=0;k<nftIntegerIdList.length;k+=1){const orderInfo=orderDataMap[nftIntegerIdList[k]],order={account:api.sender,ownedBy:"u",nftId:orderInfo.nftId,grouping:orderInfo.grouping,timestamp:timestamp,price:finalPrice,priceDec:{$numberDecimal:finalPrice},priceSymbol:priceSymbol,fee:fee},result=await api.db.insert(marketTableName,order);api.emit("sellOrder",{account:order.account,ownedBy:order.ownedBy,symbol:symbol,nftId:order.nftId,timestamp:timestamp,price:order.price,priceSymbol:order.priceSymbol,fee:fee,orderId:result._id});const groupInfo=orderInfo.groupingKey in groupingMap?groupingMap[orderInfo.groupingKey]:{grouping:orderInfo.grouping,isInCollection:!1,count:0};groupInfo.count+=1,groupingMap[orderInfo.groupingKey]=groupInfo}await updateOpenInterest("sell",symbol,priceSymbol,groupingMap,nft.groupBy)}}}};