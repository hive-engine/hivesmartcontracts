const TradeType=["exactInput","exactOutput"];function getQuote(amount,liquidityIn,liquidityOut){return!(!api.assert(api.BigNumber(amount).gt(0),"insufficient amount")||!api.assert(api.BigNumber(liquidityIn).gt(0)&&api.BigNumber(liquidityOut).gt(0),"insufficient liquidity"))&&api.BigNumber(amount).times(liquidityOut).dividedBy(liquidityIn)}function getAmountIn(params,amountOut,liquidityIn,liquidityOut){if(!api.assert(api.BigNumber(amountOut).gt(0),"insufficient output amount")||!api.assert(api.BigNumber(liquidityIn).gt(0)&&api.BigNumber(liquidityOut).gt(0)&&api.BigNumber(amountOut).lt(liquidityOut),"insufficient liquidity"))return!1;const num=api.BigNumber(liquidityIn).times(amountOut),den=api.BigNumber(liquidityOut).minus(amountOut).times(params.tradeFeeMul);return num.dividedBy(den)}function getAmountOut(params,amountIn,liquidityIn,liquidityOut){if(!api.assert(api.BigNumber(amountIn).gt(0),"insufficient output amount")||!api.assert(api.BigNumber(liquidityIn).gt(0)&&api.BigNumber(liquidityOut).gt(0),"insufficient liquidity"))return!1;const amountInWithFee=api.BigNumber(amountIn).times(params.tradeFeeMul),num=api.BigNumber(amountInWithFee).times(liquidityOut),den=api.BigNumber(liquidityIn).plus(amountInWithFee),amountOut=num.dividedBy(den);return!!api.assert(api.BigNumber(amountOut).lt(liquidityOut),"insufficient liquidity")&&amountOut}async function validateOracle(pool,newPrice,maxDeviation=api.BigNumber("0.01")){const[baseSymbol,quoteSymbol]=pool.tokenPair.split(":"),baseMetrics="'${CONSTANTS.HIVE_PEGGED_SYMBOL}$'"!==baseSymbol?await api.db.findOneInTable("market","metrics",{symbol:baseSymbol}):{lastPrice:1},quoteMetrics="'${CONSTANTS.HIVE_PEGGED_SYMBOL}$'"!==quoteSymbol?await api.db.findOneInTable("market","metrics",{symbol:quoteSymbol}):{lastPrice:1};if(!baseMetrics||!quoteMetrics)return null;const oracle=api.BigNumber(baseMetrics.lastPrice).dividedBy(quoteMetrics.lastPrice),dev=api.BigNumber(newPrice).minus(oracle).abs().dividedBy(oracle);return!!api.assert(api.BigNumber(dev).lte(maxDeviation),"exceeded max deviation from order book")}async function validateTokenPair(tokenPair){if(!api.assert("string"==typeof tokenPair&&-1!==tokenPair.indexOf(":"),"invalid tokenPair format"))return!1;const[baseSymbol,quoteSymbol]=tokenPair.split(":");return!!(api.assert(baseSymbol!==quoteSymbol,"tokenPair cannot be the same token")&&api.assert(await api.db.findOneInTable("tokens","tokens",{symbol:baseSymbol}),"baseSymbol does not exist")&&api.assert(await api.db.findOneInTable("tokens","tokens",{symbol:quoteSymbol}),"quoteSymbol does not exist"))}async function validatePool(tokenPair){const[baseSymbol,quoteSymbol]=tokenPair.split(":"),pool=await api.db.findOne("pools",{tokenPair:tokenPair}),revPool=await api.db.findOne("pools",{tokenPair:[quoteSymbol,baseSymbol].join(":")});return!!api.assert(null===pool&&null===revPool,"a pool already exists for this tokenPair")}async function updatePoolStats(pool,baseAdjusted,quoteAdjusted,sharesAdjusted,swap){const uPool=pool;uPool.baseQuantity=api.BigNumber(pool.baseQuantity).plus(baseAdjusted).toFixed(pool.precision,api.BigNumber.ROUND_HALF_UP),uPool.quoteQuantity=api.BigNumber(pool.quoteQuantity).plus(quoteAdjusted).toFixed(pool.precision,api.BigNumber.ROUND_HALF_UP),api.BigNumber(uPool.baseQuantity).gt(0)&&api.BigNumber(uPool.quoteQuantity).gt(0)&&(uPool.basePrice=api.BigNumber(uPool.quoteQuantity).dividedBy(uPool.baseQuantity).toFixed(pool.precision,api.BigNumber.ROUND_DOWN),uPool.quotePrice=api.BigNumber(uPool.baseQuantity).dividedBy(uPool.quoteQuantity).toFixed(pool.precision,api.BigNumber.ROUND_DOWN)),sharesAdjusted&&(uPool.totalShares=api.BigNumber(pool.totalShares).plus(sharesAdjusted)),swap&&(uPool.baseVolume=api.BigNumber(uPool.baseVolume).plus(Math.abs(baseAdjusted)).toFixed(pool.precision,api.BigNumber.ROUND_DOWN),uPool.quoteVolume=api.BigNumber(uPool.quoteVolume).plus(Math.abs(quoteAdjusted)).toFixed(pool.precision,api.BigNumber.ROUND_DOWN)),await api.db.update("pools",uPool)}actions.createSSC=async()=>{if(!1===await api.db.tableExists("pools")){await api.db.createTable("pools",["tokenPair"]),await api.db.createTable("liquidityPositions",["account","tokenPair"]),await api.db.createTable("params");const params={poolCreationFee:"1000"};await api.db.insert("params",params)}else{const params=await api.db.findOne("params",{});if(params.updateIndex)1===params.updateIndex&&(params.tradeFeeMul="0.9975",params.updateIndex=2,await api.db.update("params",params));else{const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`);let lpUpdate=await api.db.find("liquidityPositions",{timeFactor:{$exists:!1}});for(;lpUpdate.length>0;){for(let i=0;i<lpUpdate.length;i+=1){const lp=lpUpdate[i];lp.timeFactor=blockDate.getTime(),await api.db.update("liquidityPositions",lp)}lpUpdate=await api.db.find("liquidityPositions",{timeFactor:{$exists:!1}})}params.updateIndex=1,await api.db.update("params",params)}}},actions.updateParams=async payload=>{const{poolCreationFee:poolCreationFee}=payload;if(api.sender!==api.owner)return;const params=await api.db.findOne("params",{});if(poolCreationFee){if(!api.assert("string"==typeof poolCreationFee&&!api.BigNumber(poolCreationFee).isNaN()&&api.BigNumber(poolCreationFee).gte(0),"invalid poolCreationFee"))return;params.poolCreationFee=poolCreationFee}await api.db.update("params",params)},actions.createPool=async payload=>{const{tokenPair:tokenPair,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{poolCreationFee:poolCreationFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!api.BigNumber(poolCreationFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(poolCreationFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fee")&&await validateTokenPair(tokenPair)&&await validatePool(tokenPair)&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")){const[baseSymbol,quoteSymbol]=tokenPair.split(":"),baseToken=await api.db.findOneInTable("tokens","tokens",{symbol:baseSymbol}),quoteToken=await api.db.findOneInTable("tokens","tokens",{symbol:quoteSymbol}),newPool={tokenPair:tokenPair,baseQuantity:0,baseVolume:0,basePrice:0,quoteQuantity:0,quoteVolume:0,quotePrice:0,totalShares:0,precision:Math.max(baseToken.precision,quoteToken.precision),creator:api.sender};await api.db.insert("pools",newPool),api.sender!==api.owner&&api.BigNumber(poolCreationFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",quantity:poolCreationFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("createPool",{tokenPair:tokenPair})}},actions.createRewardPool=async payload=>{const{tokenPair:tokenPair,lotteryWinners:lotteryWinners,lotteryIntervalHours:lotteryIntervalHours,lotteryAmount:lotteryAmount,minedToken:minedToken,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOneInTable("mining","params",{}),{poolCreationFee:poolCreationFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedCreation=!(!api.BigNumber(poolCreationFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(poolCreationFee),poolPositions=await api.db.find("liquidityPositions",{tokenPair:tokenPair});if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fee")&&await validateTokenPair(tokenPair)&&api.assert(poolPositions&&poolPositions.length>0,"pool must have liquidity positions")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")){const rewardPoolId=`${minedToken}:EXT-${tokenPair.replace(":","")}`,res=await api.executeSmartContract("mining","createPool",{lotteryWinners:lotteryWinners,lotteryIntervalHours:lotteryIntervalHours,lotteryAmount:lotteryAmount,minedToken:minedToken,externalMiners:tokenPair});void 0===res.errors&&res.events&&void 0!==res.events.find(el=>"mining"===el.contract&&"createPool"===el.event)&&(await api.executeSmartContract("mining","setActive",{id:rewardPoolId,active:!0}),api.emit("createRewardPool",{tokenPair:tokenPair,rewardPoolId:rewardPoolId}))}},actions.updateRewardPool=async payload=>{const{tokenPair:tokenPair,lotteryWinners:lotteryWinners,lotteryIntervalHours:lotteryIntervalHours,lotteryAmount:lotteryAmount,minedToken:minedToken,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOneInTable("mining","params",{}),{poolUpdateFee:poolUpdateFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'"}),authorizedUpdate=!(!api.BigNumber(poolUpdateFee).lte(0)&&api.sender!==api.owner)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(poolUpdateFee),poolPositions=await api.db.find("liquidityPositions",{tokenPair:tokenPair});if(api.assert(authorizedUpdate,"you must have enough tokens to cover the update fee")&&await validateTokenPair(tokenPair)&&api.assert(poolPositions&&poolPositions.length>0,"pool must have liquidity positions")&&api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")){const rewardPoolId=`${minedToken}:EXT-${tokenPair.replace(":","")}`,res=await api.executeSmartContract("mining","updatePool",{id:rewardPoolId,lotteryWinners:lotteryWinners,lotteryIntervalHours:lotteryIntervalHours,lotteryAmount:lotteryAmount});void 0===res.errors&&res.events&&void 0!==res.events.find(el=>"mining"===el.contract&&"updatePool"===el.event)&&api.emit("updateRewardPool",{tokenPair:tokenPair,rewardPoolId:rewardPoolId})}},actions.setRewardPoolActive=async payload=>{const{tokenPair:tokenPair,minedToken:minedToken,active:active,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")||!await validateTokenPair(tokenPair))return;const rewardPoolId=`${minedToken}:EXT-${tokenPair.replace(":","")}`;void 0===(await api.executeSmartContract("mining","setActive",{id:rewardPoolId,active:active})).errors&&api.emit("setRewardPoolActive",{rewardPoolId:rewardPoolId,active:active})},actions.addLiquidity=async payload=>{const{tokenPair:tokenPair,baseQuantity:baseQuantity,quoteQuantity:quoteQuantity,maxPriceImpact:maxPriceImpact,maxDeviation:maxDeviation,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!(api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert("string"==typeof baseQuantity&&api.BigNumber(baseQuantity).gt(0),"invalid baseQuantity")&&api.assert("string"==typeof quoteQuantity&&api.BigNumber(quoteQuantity).gt(0),"invalid quoteQuantity")&&await validateTokenPair(tokenPair)))return;let addPriceImpact=api.BigNumber("0.01");if(maxPriceImpact){if(!api.assert("string"==typeof maxPriceImpact&&api.BigNumber(maxPriceImpact).gt(0)&&api.BigNumber(maxPriceImpact).dp()<=3,"maxPriceImpact must be greater than 0"))return;addPriceImpact=api.BigNumber(maxPriceImpact).dividedBy(100)}let addDeviation=api.BigNumber("0.01");if(maxDeviation){if(!api.assert("string"==typeof maxDeviation&&api.BigNumber(maxDeviation).isInteger()&&api.BigNumber(maxDeviation).gte(0),"maxDeviation must be an integer greater than or equal to 0"))return;addDeviation=api.BigNumber(maxDeviation).dividedBy(100)}const[baseSymbol,quoteSymbol]=tokenPair.split(":"),baseToken=await api.db.findOneInTable("tokens","tokens",{symbol:baseSymbol}),quoteToken=await api.db.findOneInTable("tokens","tokens",{symbol:quoteSymbol});if(!api.assert(api.BigNumber(baseQuantity).dp()<=baseToken.precision,"baseQuantity precision mismatch")||!api.assert(api.BigNumber(quoteQuantity).dp()<=quoteToken.precision,"quoteQuantity precision mismatch"))return;const pool=await api.db.findOne("pools",{tokenPair:tokenPair});if(api.assert(pool,"no existing pool for tokenPair")){if(api.BigNumber(pool.baseQuantity).eq(0)&&api.BigNumber(pool.quoteQuantity).eq(0)&&addDeviation.gt(0)&&!1===await validateOracle(pool,api.BigNumber(quoteQuantity).dividedBy(baseQuantity),addDeviation))return;let amountAdjusted;const baseMin=api.BigNumber(baseQuantity).times(api.BigNumber("1").minus(addPriceImpact)),quoteMin=api.BigNumber(quoteQuantity).times(api.BigNumber("1").minus(addPriceImpact));if(api.BigNumber(pool.baseQuantity).gt(0)&&api.BigNumber(pool.quoteQuantity).gt(0)){const quoteOptimal=getQuote(baseQuantity,pool.baseQuantity,pool.quoteQuantity).toFixed(quoteToken.precision,api.BigNumber.ROUND_HALF_UP);if(api.BigNumber(quoteOptimal).lte(quoteQuantity)){if(!api.assert(api.BigNumber(quoteOptimal).gte(quoteMin),"exceeded max price impact for adding liquidity"))return;amountAdjusted=[baseQuantity,quoteOptimal]}else{const baseOptimal=getQuote(quoteQuantity,pool.quoteQuantity,pool.baseQuantity).toFixed(baseToken.precision,api.BigNumber.ROUND_HALF_UP);if(api.BigNumber(baseOptimal).lte(baseQuantity)){if(!api.assert(api.BigNumber(baseOptimal).gte(baseMin),"exceeded max price impact for adding liquidity"))return;amountAdjusted=[baseOptimal,quoteQuantity]}}}else amountAdjusted=[baseQuantity,quoteQuantity];const senderBase=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:baseSymbol}),senderQuote=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:quoteSymbol}),senderFunded=senderBase&&senderQuote&&api.BigNumber(senderBase.balance).gte(amountAdjusted[0])&&api.BigNumber(senderQuote.balance).gte(amountAdjusted[1]);if(!api.assert(senderFunded,"insufficient token balance"))return;let newShares;if(newShares=api.BigNumber(pool.totalShares).eq(0)?api.BigNumber(amountAdjusted[0]).times(amountAdjusted[1]).sqrt():api.BigNumber.min(api.BigNumber(amountAdjusted[0]).times(pool.totalShares).dividedBy(pool.baseQuantity),api.BigNumber(amountAdjusted[1]).times(pool.totalShares).dividedBy(pool.quoteQuantity)),!api.assert(api.BigNumber(newShares).gt(0),"insufficient liquidity created"))return;const blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`),lp=await api.db.findOne("liquidityPositions",{account:api.sender,tokenPair:tokenPair});if(lp){const existingShares=lp.shares,finalShares=api.BigNumber(lp.shares).plus(newShares),timePassed=api.BigNumber(blockDate.getTime()).minus(lp.timeFactor).abs(),diffShares=api.BigNumber(finalShares).minus(existingShares).abs().dividedBy(api.BigNumber.max(finalShares,existingShares)),timeOffset=api.BigNumber(timePassed).times(diffShares);lp.shares=finalShares,lp.timeFactor=api.BigNumber.min(api.BigNumber(lp.timeFactor).plus(timeOffset).dp(0,api.BigNumber.ROUND_HALF_UP),blockDate.getTime()).toNumber(),await api.db.update("liquidityPositions",lp)}else{const newlp={account:api.sender,tokenPair:tokenPair,shares:newShares,timeFactor:blockDate.getTime()};await api.db.insert("liquidityPositions",newlp)}const baseRes=await api.executeSmartContract("tokens","transferToContract",{symbol:baseSymbol,quantity:amountAdjusted[0],to:"marketpools"}),quoteRes=await api.executeSmartContract("tokens","transferToContract",{symbol:quoteSymbol,quantity:amountAdjusted[1],to:"marketpools"});if(!api.assert(void 0===baseRes.errors&&void 0===quoteRes.errors,"deposit transfer errors"))return;await updatePoolStats(pool,amountAdjusted[0],amountAdjusted[1],newShares,!1),api.emit("addLiquidity",{baseSymbol:baseSymbol,quoteSymbol:quoteSymbol})}},actions.removeLiquidity=async payload=>{const{tokenPair:tokenPair,sharesOut:sharesOut,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")||!api.assert("string"==typeof sharesOut&&api.BigNumber(sharesOut).gt(0)&&api.BigNumber(sharesOut).lte(100)&&api.BigNumber(sharesOut).dp()<=3,"invalid sharesOut, must be > 0 <= 100")||!await validateTokenPair(tokenPair))return;const[baseSymbol,quoteSymbol]=tokenPair.split(":"),baseToken=await api.db.findOneInTable("tokens","tokens",{symbol:baseSymbol}),quoteToken=await api.db.findOneInTable("tokens","tokens",{symbol:quoteSymbol}),pool=await api.db.findOne("pools",{tokenPair:tokenPair});if(api.assert(pool,"no existing pool for tokenPair")){const lp=await api.db.findOne("liquidityPositions",{account:api.sender,tokenPair:tokenPair});if(api.assert(lp,"no existing liquidity position")){const sharesDelta=api.BigNumber(lp.shares).times(sharesOut).dividedBy(100),baseOut=api.BigNumber(sharesDelta).times(pool.baseQuantity).dividedBy(pool.totalShares).toFixed(baseToken.precision,api.BigNumber.ROUND_DOWN),quoteOut=api.BigNumber(sharesDelta).times(pool.quoteQuantity).dividedBy(pool.totalShares).toFixed(quoteToken.precision,api.BigNumber.ROUND_DOWN);if(!api.assert(api.BigNumber(baseOut).gt(0)&&api.BigNumber(quoteOut).gt(0)&&api.BigNumber(pool.baseQuantity).gte(baseOut)&&api.BigNumber(pool.quoteQuantity).gte(quoteOut),"insufficient liquidity"))return;lp.shares=api.BigNumber(lp.shares).minus(sharesDelta),api.BigNumber(lp.shares).eq(0)?await api.db.remove("liquidityPositions",lp):await api.db.update("liquidityPositions",lp);const baseRes=await api.transferTokens(api.sender,baseSymbol,baseOut,"user"),quoteRes=await api.transferTokens(api.sender,quoteSymbol,quoteOut,"user");if(!api.assert(void 0===baseRes.errors&&void 0===quoteRes.errors,"withdrawal transfer errors"))return;await updatePoolStats(pool,api.BigNumber(baseOut).negated(),api.BigNumber(quoteOut).negated(),api.BigNumber(sharesDelta).negated(),!1),api.emit("removeLiquidity",{baseSymbol:baseSymbol,quoteSymbol:quoteSymbol})}}},actions.swapTokens=async payload=>{const{tokenPair:tokenPair,tokenSymbol:tokenSymbol,tokenAmount:tokenAmount,tradeType:tradeType,minAmountOut:minAmountOut,maxAmountIn:maxAmountIn,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!(api.assert(!0===isSignedWithActiveKey,"you must use a transaction signed with your active key")&&api.assert("string"==typeof tokenSymbol,"invalid token")&&api.assert("string"==typeof tokenAmount&&api.BigNumber(tokenAmount).gt(0),"insufficient tokenAmount")&&api.assert("string"==typeof tradeType&&-1!==TradeType.indexOf(tradeType),"invalid tradeType")&&await validateTokenPair(tokenPair)))return;if(minAmountOut&&!api.assert("string"==typeof minAmountOut&&api.BigNumber(minAmountOut).gt(0),"insufficient minAmountOut"))return;if(maxAmountIn&&!api.assert("string"==typeof maxAmountIn&&api.BigNumber(maxAmountIn).gt(0),"insufficient maxAmountIn"))return;if(!api.assert(!(minAmountOut&&maxAmountIn),"specify minAmountOut or maxAmountIn but not both"))return;const[baseSymbol,quoteSymbol]=tokenPair.split(":"),pool=await api.db.findOne("pools",{tokenPair:tokenPair});if(!api.assert(pool,"no existing pool for tokenPair"))return;let liquidityIn,liquidityOut,symbolIn,symbolOut;("exactInput"===tradeType?tokenSymbol===baseSymbol:tokenSymbol!==baseSymbol)?(liquidityIn=pool.baseQuantity,liquidityOut=pool.quoteQuantity,symbolIn=baseSymbol,symbolOut=quoteSymbol):(liquidityIn=pool.quoteQuantity,liquidityOut=pool.baseQuantity,symbolIn=quoteSymbol,symbolOut=baseSymbol);const params=await api.db.findOne("params",{}),tokenIn=await api.db.findOneInTable("tokens","tokens",{symbol:symbolIn}),tokenOut=await api.db.findOneInTable("tokens","tokens",{symbol:symbolOut}),senderBase=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:symbolIn});let tokenPairDelta,tokenPairFee,tokenQuantity,senderBaseFunded=!1;if("exactInput"===tradeType){const tokenAmountAdjusted=api.BigNumber(getAmountOut(params,tokenAmount,liquidityIn,liquidityOut));if(!tokenAmountAdjusted.isFinite())return;if(senderBaseFunded=senderBase&&api.BigNumber(senderBase.balance).gte(tokenAmount),tokenPairDelta=tokenSymbol===baseSymbol?[tokenAmount,api.BigNumber(tokenAmountAdjusted).negated()]:[api.BigNumber(tokenAmountAdjusted).negated(),tokenAmount],tokenPairFee={symbol:symbolOut,amount:api.BigNumber(tokenAmountAdjusted).dividedBy(params.tradeFeeMul).minus(tokenAmountAdjusted).toFixed(tokenOut.precision,api.BigNumber.ROUND_HALF_UP)},tokenQuantity={in:tokenAmount,out:tokenAmountAdjusted},!api.assert(api.BigNumber(tokenQuantity.in).dp()<=tokenIn.precision,"symbolIn precision mismatch"))return}else if("exactOutput"===tradeType){const tokenAmountAdjusted=api.BigNumber(getAmountIn(params,tokenAmount,liquidityIn,liquidityOut));if(!tokenAmountAdjusted.isFinite())return;if(senderBaseFunded=senderBase&&api.BigNumber(senderBase.balance).gte(tokenAmountAdjusted.toFixed(tokenIn.precision,api.BigNumber.ROUND_HALF_UP)),tokenPairDelta=tokenSymbol===baseSymbol?[api.BigNumber(tokenAmount).negated(),tokenAmountAdjusted]:[tokenAmountAdjusted,api.BigNumber(tokenAmount).negated()],tokenPairFee={symbol:symbolIn,amount:api.BigNumber(tokenAmountAdjusted).dividedBy(params.tradeFeeMul).minus(tokenAmountAdjusted).toFixed(tokenIn.precision,api.BigNumber.ROUND_HALF_UP)},tokenQuantity={in:tokenAmountAdjusted,out:tokenAmount},!api.assert(api.BigNumber(tokenQuantity.out).dp()<=tokenOut.precision,"symbolOut precision mismatch"))return}if(!api.assert(senderBaseFunded,"insufficient input balance"))return;if(tokenQuantity.in=api.BigNumber(tokenQuantity.in).dp(tokenIn.precision,api.BigNumber.ROUND_CEIL),tokenQuantity.out=api.BigNumber(tokenQuantity.out).dp(tokenOut.precision,api.BigNumber.ROUND_DOWN),!api.assert(tokenQuantity.in.gt(0),"symbolIn precision mismatch")||!api.assert(tokenQuantity.out.gt(0),"symbolOut precision mismatch"))return;if(minAmountOut){if(!api.assert(api.BigNumber(minAmountOut).dp()<=tokenOut.precision,"minAmountOut precision mismatch"))return;tokenQuantity.minOut=api.BigNumber(minAmountOut)}if(maxAmountIn){if(!api.assert(api.BigNumber(maxAmountIn).dp()<=tokenIn.precision,"maxAmountIn precision mismatch"))return;tokenQuantity.maxIn=api.BigNumber(maxAmountIn)}if(void 0!==tokenQuantity.minOut&&!api.assert(api.BigNumber(tokenQuantity.out).gte(tokenQuantity.minOut),"exceeded max slippage for swap"))return;if(void 0!==tokenQuantity.maxIn&&!api.assert(api.BigNumber(tokenQuantity.in).lte(tokenQuantity.maxIn),"exceeded max slippage for swap"))return;const res=await api.executeSmartContract("tokens","transferToContract",{symbol:symbolIn,quantity:tokenQuantity.in.toFixed(),to:"marketpools"});void 0===res.errors&&res.events&&void 0!==res.events.find(el=>"tokens"===el.contract&&"transferToContract"===el.event&&el.data.from===api.sender&&"marketpools"===el.data.to&&api.BigNumber(el.data.quantity).eq(tokenQuantity.in))&&(await api.transferTokens(api.sender,symbolOut,tokenQuantity.out.toFixed(),"user"),await updatePoolStats(pool,tokenPairDelta[0],tokenPairDelta[1],!1,!0),api.emit("swapTokens",{symbolIn:symbolIn,symbolOut:symbolOut,fee:tokenPairFee}))};