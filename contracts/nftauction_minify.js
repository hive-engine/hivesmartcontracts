const UTILITY_TOKEN_SYMBOL="BEE",MAX_NUM_UNITS_OPERABLE=50,MAX_BID_INCREMENT_PERCENT=1e4,CONTRACT_NAME="nftauction";actions.createSSC=async()=>{if(!1===await api.db.tableExists("auctions")){await api.db.createTable("auctions",["auctionId","symbol","lastValidLead","expiryTimestamp"]),await api.db.createTable("params"),await api.db.createTable("marketParams",["symbol"]);const params={creationFee:"1",minBidIncrementPercent:500,cancelLockTimeMillis:3e5,expiryTimeMillis:864e5,maxExpiryTimeMillis:2592e6,auctionsPerBlock:1};await api.db.insert("params",params)}},actions.updateParams=async payload=>{if(api.assert(api.sender===api.owner,"not authorized")){const{creationFee:creationFee,minBidIncrementPercent:minBidIncrementPercent,cancelLockTimeMillis:cancelLockTimeMillis,expiryTimeMillis:expiryTimeMillis,maxExpiryTimeMillis:maxExpiryTimeMillis,auctionsPerBlock:auctionsPerBlock}=payload,params=await api.db.findOne("params",{});if(creationFee){if(!api.assert("string"==typeof creationFee&&api.BigNumber(creationFee).isFinite()&&api.BigNumber(creationFee).gte(0),"invalid creationFee"))return;params.creationFee=creationFee}if(minBidIncrementPercent){if(!api.assert(Number.isInteger(minBidIncrementPercent)&&minBidIncrementPercent>0&&minBidIncrementPercent<=1e4,"invalid minBidIncrementPercent"))return;params.minBidIncrementPercent=minBidIncrementPercent}if(cancelLockTimeMillis){if(!api.assert(Number.isInteger(cancelLockTimeMillis)&&cancelLockTimeMillis>0,"invalid cancelLockTimeMillis"))return;params.cancelLockTimeMillis=cancelLockTimeMillis}if(expiryTimeMillis){if(!api.assert(Number.isInteger(expiryTimeMillis)&&expiryTimeMillis>0,"invalid expiryTimeMillis"))return;params.expiryTimeMillis=expiryTimeMillis}if(maxExpiryTimeMillis){if(!api.assert(Number.isInteger(maxExpiryTimeMillis)&&maxExpiryTimeMillis>0,"invalid maxExpiryTimeMillis"))return;params.maxExpiryTimeMillis=maxExpiryTimeMillis}if(auctionsPerBlock){if(!api.assert(Number.isInteger(auctionsPerBlock)&&auctionsPerBlock>0,"invalid auctionsPerBlock"))return;params.auctionsPerBlock=auctionsPerBlock}await api.db.update("params",params)}};const countDecimals=value=>api.BigNumber(value).dp(),getTimestamp=value=>{try{return new Date(`${value}.00Z`).getTime()}catch(e){return!1}},transferIsSuccessful=(result,action,from,to,symbol,quantity)=>!(void 0!==result.errors||!result.events||void 0===result.events.find((el=>"tokens"===el.contract&&el.event===action&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol))),sendNfts=async(to,wrappedNfts)=>{await api.executeSmartContract("nft","transfer",{fromType:"contract",to:to,toType:"user",nfts:[wrappedNfts],isSignedWithActiveKey:!0})},returnBids=async(bids,priceSymbol)=>{for(let i=0;i<bids.length;i+=1){const{account:account,bid:bid}=bids[i];await api.transferTokens(account,priceSymbol,bid,"user")}},cancelAuction=async auction=>{const{auctionId:auctionId,symbol:symbol,seller:seller,nftIds:nftIds,priceSymbol:priceSymbol,bids:bids}=auction;await returnBids(bids,priceSymbol);const wrappedNfts={symbol:symbol,ids:nftIds};await sendNfts(seller,wrappedNfts),await api.db.remove("auctions",auction),api.emit("cancelAuction",{auctionId:auctionId})},settleAuction=async(auction,index=null)=>{const{auctionId:auctionId,symbol:symbol,seller:seller,nftIds:nftIds,priceSymbol:priceSymbol,bids:bids,currentLead:currentLead}=auction,timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime(),wrappedNfts={symbol:symbol,ids:nftIds};if(bids.length>0){const bidIndex=null===index?currentLead:index,leadBid=bids[bidIndex];bids.splice(bidIndex,1),await returnBids(bids,priceSymbol);const token=await api.db.findOneInTable("tokens","tokens",{symbol:priceSymbol}),price=api.BigNumber(leadBid.bid),feePercent=auction.feePercent/1e4;let fee=price.multipliedBy(feePercent).decimalPlaces(token.precision,api.BigNumber.ROUND_DOWN);const payment=price.minus(fee).decimalPlaces(token.precision,api.BigNumber.ROUND_DOWN),marketParams=await api.db.findOne("marketParams",{symbol:symbol});let agentFee=api.BigNumber(0);if(marketParams&&marketParams.officialMarket&&void 0!==marketParams.agentFeePercent&&marketParams.agentFeePercent>0&&fee.gt(0)){const agentFeePercent=marketParams.agentFeePercent/1e4;agentFee=fee.multipliedBy(agentFeePercent).decimalPlaces(token.precision,api.BigNumber.ROUND_DOWN),fee=fee.minus(agentFee).decimalPlaces(token.precision,api.BigNumber.ROUND_DOWN)}const officialMarketAccount=marketParams&&marketParams.officialMarket?marketParams.officialMarket:leadBid.marketAccount;let isMarketFeePaid=!1;fee.gt(0)&&(isMarketFeePaid=!0,fee=fee.toFixed(token.precision,api.BigNumber.ROUND_DOWN),await api.transferTokens(officialMarketAccount,priceSymbol,fee,"user"));let isAgentFeePaid=!1;agentFee.gt(0)&&(isAgentFeePaid=!0,agentFee=agentFee.toFixed(token.precision,api.BigNumber.ROUND_DOWN),await api.transferTokens(leadBid.marketAccount,priceSymbol,agentFee,"user")),payment.gt(0)&&await api.transferTokens(seller,priceSymbol,payment,"user"),await sendNfts(leadBid.account,wrappedNfts),await api.db.remove("auctions",auction);const ackPacket={auctionId:auctionId,symbol:symbol,seller:seller,nftIds:nftIds,bidder:leadBid.account,price:leadBid.bid,priceSymbol:priceSymbol,timestamp:timestamp};isMarketFeePaid&&(ackPacket.marketAccount=officialMarketAccount,ackPacket.fee=fee),isAgentFeePaid&&(ackPacket.agentAccount=leadBid.marketAccount,ackPacket.agentFee=agentFee),api.emit("settleAuction",ackPacket)}else await api.db.remove("auctions",auction),await sendNfts(seller,wrappedNfts),api.emit("expireAuction",{auctionId:auctionId,symbol:symbol,seller:seller,nftIds:nftIds,timestamp:timestamp})};actions.create=async payload=>{const{symbol:symbol,nfts:nfts,minBid:minBid,finalPrice:finalPrice,priceSymbol:priceSymbol,feePercent:feePercent,expiry:expiry,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(symbol&&"string"==typeof symbol,"invalid symbol"))return;if(!api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key"))return;const nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(api.assert(nft,"NFT symbol does not exist")&&api.assert(nfts&&"object"==typeof nfts&&Array.isArray(nfts)&&minBid&&"string"==typeof minBid&&api.BigNumber(minBid).isFinite()&&finalPrice&&"string"==typeof finalPrice&&api.BigNumber(finalPrice).isFinite()&&priceSymbol&&"string"==typeof priceSymbol&&"number"==typeof feePercent&&feePercent>=0&&feePercent<=1e4&&Number.isInteger(feePercent)&&expiry&&"string"==typeof expiry,"invalid params")&&api.assert(nfts.length<=50,"cannot process more than 50 NFT instances at once")){const marketParams=await api.db.findOne("marketParams",{symbol:symbol});if(marketParams&&void 0!==marketParams.minFeePercent&&!api.assert(feePercent>=marketParams.minFeePercent,`feePercent must be >= ${marketParams.minFeePercent}`))return;const token=await api.db.findOneInTable("tokens","tokens",{symbol:priceSymbol}),params=await api.db.findOne("params",{}),timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime(),expiryTimestamp=getTimestamp(expiry),maxExpiryTimestamp=api.BigNumber(timestamp).plus(params.maxExpiryTimeMillis).toNumber();if(api.assert(token,"priceSymbol does not exist")&&api.assert(api.BigNumber(minBid).gt(0)&&countDecimals(minBid)<=token.precision,"invalid minBid")&&api.assert(api.BigNumber(finalPrice).gt(0)&&countDecimals(finalPrice)<=token.precision,"invalid finalPrice")&&api.assert(expiryTimestamp&&expiryTimestamp>timestamp,"invalid expiry")&&api.assert(expiryTimestamp<=maxExpiryTimestamp,"expiry exceeds limit")){const utilityToken=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:"BEE"});if(api.assert(utilityToken&&utilityToken.balance&&api.BigNumber(utilityToken.balance).gte(params.creationFee),"you must have enough tokens to cover the creation fee")){const wrappedNfts={symbol:symbol,ids:nfts},nftTransfer=await api.executeSmartContract("nft","transfer",{fromType:"user",to:"nftauction",toType:"contract",nfts:[wrappedNfts],isSignedWithActiveKey:isSignedWithActiveKey});if(api.assert(nftTransfer.events,"failed to trasfer NFTs to the contract")){const nftIds=[];for(let i=0;i<nftTransfer.events.length;i+=1){const ev=nftTransfer.events[i];if(ev.contract&&ev.event&&ev.data&&"nft"===ev.contract&&"transfer"===ev.event&&ev.data.from===api.sender&&"u"===ev.data.fromType&&"nftauction"===ev.data.to&&"c"===ev.data.toType&&ev.data.symbol===symbol){const instanceId=ev.data.id;nftIds.push(instanceId)}}if(nftIds.length>0){const feeTransfer=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:"BEE",quantity:params.creationFee,isSignedWithActiveKey:isSignedWithActiveKey});if(transferIsSuccessful(feeTransfer,"transfer",api.sender,"null","BEE",params.creationFee)){const auction={auctionId:api.transactionId,symbol:symbol,seller:api.sender,nftIds:nftIds,priceSymbol:priceSymbol,minBid:minBid,finalPrice:finalPrice,feePercent:feePercent,expiryTimestamp:expiryTimestamp,bids:[],currentLead:null,lastLeadUpdate:null},res=await api.db.insert("auctions",auction);api.emit("create",{auctionId:res.auctionId})}else wrappedNfts.ids=nftIds,await api.executeSmartContract("nft","transfer",{fromType:"contract",to:api.sender,toType:"user",nfts:[wrappedNfts],isSignedWithActiveKey:isSignedWithActiveKey})}}}}}},actions.settle=async payload=>{const{auctionId:auctionId,account:account,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(auctionId&&"string"==typeof auctionId&&(!account||account&&"string"==typeof account&&api.isValidAccountName(account)),"invalid params")){const auction=await api.db.findOne("auctions",{auctionId:auctionId});if(api.assert(auction,"auction does not exist or has been expired")&&api.assert(auction.seller===api.sender,"you must be the owner of the auction")&&api.assert(auction.bids.length>0,"there are no bids in the auction")){let id=auction.currentLead;if(account&&(id=auction.bids.findIndex((el=>el.account===account)),!api.assert(auction.bids[id],"no bid from account found in the auction")))return;await settleAuction(auction,id)}}},actions.cancel=async payload=>{const{auctionId:auctionId,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(auctionId&&"string"==typeof auctionId,"invalid params")){const auction=await api.db.findOne("auctions",{auctionId:auctionId});api.assert(auction,"auction does not exist or has been expired")&&api.assert(auction.seller===api.sender,"you must be the owner of the auction")&&await cancelAuction(auction)}},actions.bid=async payload=>{const{auctionId:auctionId,bid:bid,marketAccount:marketAccount,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(auctionId&&"string"==typeof auctionId&&bid&&"string"==typeof bid&&api.BigNumber(bid).isFinite()&&marketAccount&&"string"==typeof marketAccount,"invalid params")){const auction=await api.db.findOne("auctions",{auctionId:auctionId});if(api.assert(auction,"auction does not exist or has been expired")){const{seller:seller,priceSymbol:priceSymbol,minBid:minBid,finalPrice:finalPrice,currentLead:currentLead,expiryTimestamp:expiryTimestamp}=auction,token=await api.db.findOneInTable("tokens","tokens",{symbol:priceSymbol}),timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();if(api.assert(api.sender!==seller,"auction seller can not bid")&&api.assert(api.BigNumber(bid).gt(0)&&countDecimals(bid)<=token.precision,"invalid bid")&&api.assert(api.BigNumber(bid).gte(minBid),`bid can not be less than ${minBid}`)&&api.assert(expiryTimestamp>=timestamp,"auction has been expired")&&api.assert(api.isValidAccountName(marketAccount),"invalid marketAccount")){let nbTokensToLock=api.BigNumber(bid).gt(finalPrice)?finalPrice:bid;const previousBidIndex=auction.bids.findIndex((el=>el.account===api.sender)),previousBid=auction.bids[previousBidIndex],newBid={account:api.sender,bid:nbTokensToLock,marketAccount:marketAccount,timestamp:timestamp};if(previousBid){if(!api.assert(api.BigNumber(nbTokensToLock).gt(previousBid.bid),"bid must be greater than your previous bid"))return;auction.bids[previousBidIndex]=newBid,nbTokensToLock=api.BigNumber(nbTokensToLock).minus(previousBid.bid).toFixed(token.precision)}else auction.bids.push(newBid);const priceToken=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:priceSymbol});if(api.assert(priceToken&&priceToken.balance&&api.BigNumber(priceToken.balance).gte(nbTokensToLock),"insufficient balance for this bid")){const tokenTransfer=await api.executeSmartContract("tokens","transferToContract",{to:"nftauction",symbol:priceSymbol,quantity:nbTokensToLock});if(transferIsSuccessful(tokenTransfer,"transferToContract",api.sender,"nftauction",priceSymbol,nbTokensToLock)){const newBidIndex=auction.bids.findIndex((el=>el.account===api.sender));if(api.BigNumber(newBid.bid).gte(finalPrice))return auction.currentLead=newBidIndex,void await settleAuction(auction);const params=await api.db.findOne("params",{});if(null!==currentLead){const leadBid=auction.bids[currentLead],minBidIncrementPct=params.minBidIncrementPercent/1e4,minBidIncrement=api.BigNumber(leadBid.bid).multipliedBy(minBidIncrementPct).toFixed(token.precision);api.BigNumber(newBid.bid).minus(leadBid.bid).gte(minBidIncrement)&&(auction.currentLead=newBidIndex,auction.lastLeadUpdate=timestamp)}else auction.currentLead=newBidIndex,auction.lastLeadUpdate=timestamp;if(await api.db.update("auctions",auction),previousBid){const ackPacket={auctionId:auctionId,account:newBid.account,oldBid:previousBid.bid,bid:newBid.bid,marketAccount:newBid.marketAccount,oldTimestamp:previousBid.timestamp,timestamp:newBid.timestamp};previousBid.marketAccount!==marketAccount&&(ackPacket.oldMarketAccount=previousBid.marketAccount),api.emit("updateBid",ackPacket)}else api.emit("bid",{auctionId:auctionId,...newBid})}}}}}},actions.cancelBid=async payload=>{const{auctionId:auctionId,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(auctionId&&"string"==typeof auctionId,"invalid params")){const auction=await api.db.findOne("auctions",{auctionId:auctionId});if(api.assert(auction,"auction does not exist or has been expired")){const{priceSymbol:priceSymbol,currentLead:currentLead,expiryTimestamp:expiryTimestamp,lastLeadUpdate:lastLeadUpdate}=auction,bidIndex=auction.bids.findIndex((el=>el.account===api.sender)),bid=auction.bids[bidIndex],timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();if(api.assert(bid,"you do not have a bid in this auction")&&api.assert(expiryTimestamp>=timestamp,"auction has been expired")){const params=await api.db.findOne("params",{}),timeRemaining=api.BigNumber(lastLeadUpdate).plus(params.expiryTimeMillis).minus(timestamp),timeRemainingExpire=api.BigNumber(expiryTimestamp).minus(timestamp);if(api.assert(timeRemaining.gt(params.cancelLockTimeMillis)&&timeRemainingExpire.gt(params.cancelLockTimeMillis),"can not cancel bid when auction is about to settle")){if(auction.bids.splice(bidIndex,1),currentLead===bidIndex){let largestBid="0",largestBidIndex=null;for(let i=0;i<auction.bids.length;i+=1){const{bid:quantity}=auction.bids[i];api.BigNumber(quantity).gt(largestBid)&&(largestBid=quantity,largestBidIndex=i)}auction.currentLead=largestBidIndex}else currentLead>bidIndex&&(auction.currentLead-=1);await api.transferTokens(api.sender,priceSymbol,bid.bid,"user"),await api.db.update("auctions",auction),api.emit("cancelBid",{auctionId:auctionId,...bid})}}}}},actions.updateAuctions=async()=>{if(!api.assert("null"===api.sender,"not authorized"))return;const params=await api.db.findOne("params",{}),timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime(),lastValidLead=timestamp-params.expiryTimeMillis,auctionsToSettle=await api.db.find("auctions",{$or:[{lastLeadUpdate:{$lte:lastValidLead}},{expiryTimestamp:{$lte:timestamp}}]},params.auctionsPerBlock,0,[{index:"_id",descending:!1}]);for(let i=0;i<auctionsToSettle.length;i+=1){const auction=auctionsToSettle[i];await settleAuction(auction)}},actions.setMarketParams=async payload=>{const{symbol:symbol,officialMarket:officialMarket,agentFeePercent:agentFeePercent,minFeePercent:minFeePercent,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(!api.assert(symbol&&"string"==typeof symbol,"invalid symbol"))return!1;if(void 0===officialMarket&&void 0===agentFeePercent&&void 0===minFeePercent)return!1;const nft=await api.db.findOneInTable("nft","nfts",{symbol:symbol});if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(nft,"nft symbol does not exist")&&api.assert((void 0===officialMarket||officialMarket&&"string"==typeof officialMarket&&api.isValidAccountName(officialMarket))&&(void 0===agentFeePercent||"number"==typeof agentFeePercent&&agentFeePercent>=0&&agentFeePercent<=1e4&&Number.isInteger(agentFeePercent))&&(void 0===minFeePercent||"number"==typeof minFeePercent&&minFeePercent>=0&&minFeePercent<=1e4&&Number.isInteger(minFeePercent)),"invalid params")&&api.assert(nft.issuer===api.sender,"must be the issuer")){let isFirstTimeSet=!1,params=await api.db.findOne("marketParams",{symbol:symbol});return params||(isFirstTimeSet=!0,params={symbol:symbol}),void 0!==officialMarket&&(params.officialMarket=officialMarket),void 0!==agentFeePercent&&(params.agentFeePercent=agentFeePercent),void 0!==minFeePercent&&(params.minFeePercent=minFeePercent),isFirstTimeSet?await api.db.insert("marketParams",params):await api.db.update("marketParams",params),!0}return!1};