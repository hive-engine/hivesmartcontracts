const stablePairArray = ['SWAP.HBD', 'SWAP.USDT', 'SWAP.DAI', 'SWAP.USDC']; const countDecimals = value => api.BigNumber(value).dp(); const verifyTokenCreation = async symbolFind => !!await api.db.findOneInTable('tokens', 'tokens', { symbol: symbolFind }); const verifyTokenBalance = async (account, amount, symbolFind) => { const findTokenBalance = await api.db.findOneInTable('tokens', 'balances', { account, symbol: symbolFind }); return !(!findTokenBalance || !api.BigNumber(findTokenBalance.balance).gte(amount)); }; const checkStablePosition = (tokenPair) => { const [firstToken, secondToken] = tokenPair.split(':'); return stablePairArray.includes(firstToken) ? 'base' : !!stablePairArray.includes(secondToken) && 'quote'; }; const findMarketPools = async (parentSymbol, toggle) => {
  const childSymbol = `${parentSymbol}.D`; let poolData; if (toggle === 'stable') { const stableResults = [`${parentSymbol}`, `${childSymbol}`].flatMap(pElement => stablePairArray.flatMap(sElement => [`${sElement}:${pElement}`, `${pElement}:${sElement}`])); const multiPoolData = await api.db.findInTable('marketpools', 'pools', { tokenPair: { $in: stableResults } }); poolData = multiPoolData.length > 0 ? [multiPoolData.reduce((max, item) => (item.baseQuantity + item.quoteQuantity > max.baseQuantity + max.quoteQuantity ? item : max), multiPoolData[0])] : []; } if (toggle === 'market') { const marketParentArray = [`${parentSymbol}:${childSymbol}`, `${childSymbol}:${parentSymbol}`]; poolData = await api.db.findInTable('marketpools', 'pools', { tokenPair: { $in: marketParentArray } }); } const validPools = poolData.map(pool => ({
    tokenPair: pool.tokenPair, basePrice: pool.basePrice || '0', quotePrice: pool.quotePrice || '0', baseQuantity: pool.baseQuantity || '0', quoteQuantity: pool.quoteQuantity || '0',
  })); return validPools.length > 0 ? validPools : null;
}; const calcParentPool = async (name, pool, tokenPriceUSD, precision) => {
  const [firstToken, secondToken] = pool.tokenPair.split(':'); let quoteOrBasePosition; let otherTokenPriceUSD; let halfPoolinUSD; let fullPoolinUSD; let parentTokenPrice; let returnObject = {}; return name.includes(firstToken) && (quoteOrBasePosition = 'base'), name.includes(secondToken) && (quoteOrBasePosition = 'quote'), quoteOrBasePosition && quoteOrBasePosition === 'base' ? (otherTokenPriceUSD = api.BigNumber(pool.quotePrice).multipliedBy(tokenPriceUSD).toFixed(precision, api.BigNumber.ROUND_DOWN), parentTokenPrice = name.includes('.D') ? api.BigNumber(tokenPriceUSD).toFixed(precision, api.BigNumber.ROUND_DOWN) : api.BigNumber(otherTokenPriceUSD).toFixed(precision, api.BigNumber.ROUND_DOWN), halfPoolinUSD = api.BigNumber(otherTokenPriceUSD).multipliedBy(pool.baseQuantity).toFixed(precision, api.BigNumber.ROUND_DOWN), fullPoolinUSD = api.BigNumber(halfPoolinUSD).multipliedBy(1.95).toFixed(precision, api.BigNumber.ROUND_DOWN), returnObject = {
    quoteToken: firstToken, quotePriceUSD: otherTokenPriceUSD, baseToken: secondToken, basePriceUSD: tokenPriceUSD, precision, poolValueUSD: fullPoolinUSD, parentPrice: parentTokenPrice,
  }) : quoteOrBasePosition && quoteOrBasePosition === 'quote' && (otherTokenPriceUSD = api.BigNumber(pool.basePrice).multipliedBy(tokenPriceUSD).toFixed(precision, api.BigNumber.ROUND_DOWN), parentTokenPrice = name.includes('.D') ? api.BigNumber(otherTokenPriceUSD).toFixed(precision, api.BigNumber.ROUND_DOWN) : api.BigNumber(tokenPriceUSD).toFixed(precision, api.BigNumber.ROUND_DOWN), halfPoolinUSD = api.BigNumber(otherTokenPriceUSD).multipliedBy(pool.quoteQuantity).toFixed(precision, api.BigNumber.ROUND_DOWN), fullPoolinUSD = api.BigNumber(halfPoolinUSD).multipliedBy(1.95).toFixed(precision, api.BigNumber.ROUND_DOWN), returnObject = {
    quoteToken: firstToken, quotePriceUSD: tokenPriceUSD, baseToken: secondToken, basePriceUSD: otherTokenPriceUSD, precision, poolValueUSD: fullPoolinUSD, parentPrice: parentTokenPrice,
  }), returnObject;
}; const isTokenTransferVerified = (result, from, to, symbol, quantity, eventStr) => !(void 0 !== result.errors || !result.events || void 0 === result.events.find(el => (el.contract === 'tokens' || el.contract === 'burndollar') && el.event === eventStr && el.data.from === from && el.data.to === to && api.BigNumber(el.data.quantity).eq(quantity) && el.data.symbol === symbol)); const burnParentTokens = async (amount, fee, burnSymbol, toAccount, beedParams, isSignedWithActiveKey) => {
  if (api.BigNumber(fee).gt(0)) {
    const res = await api.executeSmartContract('tokens', 'transfer', {
      to: toAccount, symbol: burnSymbol, quantity: fee, isSignedWithActiveKey,
    }); if (!isTokenTransferVerified(res, api.sender, toAccount, burnSymbol, fee, 'transfer')) return !1;
  } const res2 = await api.executeSmartContract('tokens', 'transfer', {
    to: 'null', symbol: burnSymbol, quantity: amount, isSignedWithActiveKey,
  }); const res3 = await api.executeSmartContract('tokens', 'transfer', {
    to: 'null', symbol: beedParams.burnToken, quantity: beedParams.burnUsageFee, isSignedWithActiveKey,
  }); return !!isTokenTransferVerified(res2, api.sender, 'null', burnSymbol, amount, 'transfer') && !!isTokenTransferVerified(res3, api.sender, 'null', beedParams.burnToken, beedParams.burnUsageFee, 'transfer');
}; actions.createSSC = async () => {
  if (!1 === await api.db.tableExists('params')) {
    await api.db.createTable('params'), await api.db.createTable('burnpair', ['symbol', 'parentSymbol']); const params = {
      issueDTokenFee: '1000', updateParamsFee: '100', burnUsageFee: '1', minAmountConvertible: '1', dTokenToIssuer: '1000', burnToken: 'BEED',
    }; await api.db.insert('params', params);
  }
}, actions.updateParams = async (payload) => {
  if (api.sender !== api.owner) return; const {
    issueDTokenFee, updateParamsFee, burnUsageFee, minAmountConvertible, dTokenToIssuer, burnToken,
  } = payload; const params = await api.db.findOne('params', {}); if (issueDTokenFee && typeof issueDTokenFee === 'string' && !api.BigNumber(issueDTokenFee).isNaN() && api.BigNumber(issueDTokenFee).gte(1) && (params.issueDTokenFee = issueDTokenFee), updateParamsFee && typeof updateParamsFee === 'string' && !api.BigNumber(updateParamsFee).isNaN() && api.BigNumber(updateParamsFee).gte(1) && (params.updateParamsFee = updateParamsFee), burnUsageFee && typeof burnUsageFee === 'string' && !api.BigNumber(burnUsageFee).isNaN() && api.BigNumber(burnUsageFee).gte(1) && (params.burnUsageFee = burnUsageFee), minAmountConvertible && typeof minAmountConvertible === 'string' && !minAmountConvertible.isNaN() && minAmountConvertible.gte(1) && (params.minAmountConvertible = minAmountConvertible), dTokenToIssuer && typeof dTokenToIssuer === 'string' && !api.BigNumber(dTokenToIssuer).isNaN() && api.BigNumber(dTokenToIssuer).gte(1) && (params.dTokenToIssuer = dTokenToIssuer), burnToken && typeof burnToken === 'string') { await api.db.findOneInTable('tokens', 'tokens', { symbol: burnToken }) && (params.burnToken = burnToken); } await api.db.update('params', params);
}, actions.createTokenD = async (payload) => {
  const {
    symbol, isSignedWithActiveKey, burnRouting, feePercentage,
  } = payload; const burnPairParams = {}; const params = await api.db.findOne('params', {}); const { issueDTokenFee } = params; const beedTokenBalance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: params.burnToken }); const authorizedCreation = beedTokenBalance && api.BigNumber(beedTokenBalance.balance).gte(issueDTokenFee); if (api.assert(!0 === isSignedWithActiveKey, 'you must use a custom_json signed with your active key') && api.assert(authorizedCreation, 'you must have enough BEED tokens cover the creation fees') && api.assert(symbol && typeof symbol === 'string' && symbol.length <= 8 && symbol.length > 0 && !symbol.includes('.D'), 'symbol must be string of length 8 or less to create a xxx.D token')) {
    const tokenParent = await api.db.findOneInTable('tokens', 'tokens', { symbol }); const finalRouting = void 0 === burnRouting ? 'null' : burnRouting; if (api.assert(tokenParent.issuer === api.sender, 'You must be the token issuer in order to issue D token') && api.assert(api.isValidAccountName(finalRouting), 'burn routing must be a valid Hive account name') && api.assert(feePercentage && typeof feePercentage === 'string' && !api.BigNumber(feePercentage).isNaN() && api.BigNumber(feePercentage).gte(0) && api.BigNumber(feePercentage).lte(1) && countDecimals(feePercentage) <= 4, 'fee percentage must be between 0 and 1 / 0% and 100%')) {
      let finalName = ''; let dSymbol = ''; dSymbol = `${symbol}.D`; const tokenDExists = await api.db.findOneInTable('tokens', 'tokens', { symbol: dSymbol }); if (api.assert(tokenDExists === null, 'D token must not already exist') && api.assert(tokenParent.precision > 0 && Number.isInteger(tokenParent.precision), 'invalid precision')) {
        finalName = `${symbol} stablecoin`; const newToken = {
          symbol: dSymbol, name: finalName, precision: tokenParent.precision, maxSupply: `${Number.MAX_SAFE_INTEGER}`,
        }; await api.executeSmartContract('tokens', 'create', newToken); const tokenCreated = await verifyTokenCreation(dSymbol); if (!api.assert(tokenCreated, 'Token creation failed')) return !1; burnPairParams.issuer = api.sender, burnPairParams.symbol = dSymbol, burnPairParams.precision = tokenParent.precision, burnPairParams.parentSymbol = symbol, burnPairParams.burnRouting = finalRouting, burnPairParams.feePercentage = feePercentage, await api.db.insert('burnpair', burnPairParams), await api.executeSmartContract('tokens', 'issue', { to: api.sender, symbol: dSymbol, quantity: params.dTokenToIssuer }), api.BigNumber(issueDTokenFee).gt(0) && await api.executeSmartContract('tokens', 'transfer', {
          to: 'null', symbol: params.burnToken, quantity: issueDTokenFee, isSignedWithActiveKey,
        }), api.emit('issued new token dollar stablecoin', { convertPercentage: feePercentage, feeRouting: burnPairParams.burnRouting, dSymbol });
      }
    }
  }
}, actions.updateBurnPair = async (payload) => {
  const {
    symbol, burnRouting, feePercentage, isSignedWithActiveKey,
  } = payload; const finalRouting = void 0 === burnRouting ? 'null' : burnRouting; if (api.assert(api.isValidAccountName(finalRouting), 'account for burn routing must exist') && api.assert(!0 === isSignedWithActiveKey, 'you must use a custom_json signed with your active key') && api.assert(symbol && typeof symbol === 'string', 'symbol must be string') && api.assert(finalRouting && typeof finalRouting === 'string', 'finalRouting must be string or null') && api.assert(feePercentage && typeof feePercentage === 'string' && !api.BigNumber(feePercentage).isNaN() && api.BigNumber(feePercentage).gte(0) && api.BigNumber(feePercentage).lte(1) && countDecimals(feePercentage) <= 4, 'fee percentage must be between 0 and 1 / 0% and 100%')) {
    const token = await api.db.findOne('burnpair', { symbol }); if (!api.assert(token != null, 'D token must exist')) return !1; if (token && api.assert(token.issuer === api.sender, 'must be the issuer')) {
      const params = await api.db.findOne('params', {}); const { updateParamsFee } = params; const beedTokenBalance = await api.db.findOneInTable('tokens', 'balances', { account: api.sender, symbol: params.burnToken }); const authorizedCreation = beedTokenBalance && api.BigNumber(beedTokenBalance.balance).gte(updateParamsFee); api.assert(authorizedCreation, 'you must have enough BEED tokens to cover the update properties fee') && (token.burnRouting = finalRouting, token.feePercentage = feePercentage, await api.db.update('burnpair', token), api.BigNumber(updateParamsFee).gt(0) && await api.executeSmartContract('tokens', 'transfer', {
        to: 'null', symbol: params.burnToken, quantity: updateParamsFee, isSignedWithActiveKey,
      }), api.emit('updated params', { symbol, burnRouting, feePercentage }));
    }
  }
}, actions.convert = async (payload) => {
  const { symbol, quantity, isSignedWithActiveKey } = payload; if (api.assert(!0 === isSignedWithActiveKey, 'you must use a custom_json signed with your active key') && api.assert(quantity && typeof quantity === 'string' && !api.BigNumber(quantity).isNaN(), 'invalid params quantity') && api.assert(symbol && typeof symbol === 'string' && symbol.length > 0 && symbol.length <= 10, 'symbol must be string')) {
    const contractParams = await api.db.findOne('params', {}); const parentPairParams = await api.db.findOne('burnpair', { parentSymbol: symbol }); const qtyAsBigNum = api.BigNumber(quantity); if (api.assert(parentPairParams, 'parent symbol must have a child .D token') && api.assert(countDecimals(quantity) <= parentPairParams.precision, 'symbol precision mismatch') && api.assert(qtyAsBigNum.gte(contractParams.minAmountConvertible), 'amount to convert must be >= 1')) {
      const hasEnoughUtilityToken = await verifyTokenBalance(api.sender, contractParams.burnUsageFee, contractParams.burnToken); const hasEnoughParentBalance = await verifyTokenBalance(api.sender, qtyAsBigNum, symbol); const hasEnoughStablePool = await findMarketPools(symbol, 'stable'); const hasEnoughMarketPool = await findMarketPools(symbol, 'market'); if (api.assert(hasEnoughParentBalance, 'not enough token balance') && api.assert(hasEnoughUtilityToken, 'not enough utility tokens') && api.assert(hasEnoughStablePool, 'token must be in pool with a stable coin') && api.assert(hasEnoughMarketPool, 'token must be in pool with xxx.d token')) {
        const quoteOrBase = checkStablePosition(hasEnoughStablePool[0].tokenPair); let calcResultParentPool; if (quoteOrBase && quoteOrBase === 'base') { const stablePrice = hasEnoughStablePool[0].basePrice; const stableQuant = hasEnoughStablePool[0].baseQuantity; const tokenNameBase = hasEnoughStablePool[0].tokenPair.split(':')[1]; const stableUSDValue = api.BigNumber(stablePrice).multipliedBy(stableQuant).toFixed(parentPairParams.precision, api.BigNumber.ROUND_DOWN); const finalValueQuote = api.BigNumber(stableUSDValue).multipliedBy(1.95).toFixed(parentPairParams.precision, api.BigNumber.ROUND_DOWN); if (!api.assert(finalValueQuote && finalValueQuote >= 400, 'stable token pool USD value must be at least 500')) return !1; calcResultParentPool = await calcParentPool(tokenNameBase, hasEnoughMarketPool[0], stablePrice, parentPairParams.precision); } else if (quoteOrBase && quoteOrBase === 'quote') { const stableTPrice = hasEnoughStablePool[0].quotePrice; const quoteQuant = hasEnoughStablePool[0].quoteQuantity; const tokenNameQuote = hasEnoughStablePool[0].tokenPair.split(':')[0]; const stableUSDValue = api.BigNumber(stableTPrice).multipliedBy(quoteQuant).toFixed(parentPairParams.precision, api.BigNumber.ROUND_DOWN); const finalValueQuote = api.BigNumber(stableUSDValue).multipliedBy(1.95).toFixed(parentPairParams.precision, api.BigNumber.ROUND_DOWN); if (!api.assert(finalValueQuote && finalValueQuote >= 400, 'stable token pool USD value must be at least 500')) return !1; calcResultParentPool = await calcParentPool(tokenNameQuote, hasEnoughMarketPool[0], stableTPrice, parentPairParams.precision); } if (api.assert(calcResultParentPool && calcResultParentPool.poolValueUSD >= 400, 'parent token and XXX.D token pool USD value must be at least 500')) {
          const feePercentage = api.BigNumber(parentPairParams.feePercentage); let fee = '0'; let finalQty = qtyAsBigNum; feePercentage.gt(0) && (fee = qtyAsBigNum.multipliedBy(feePercentage).toFixed(parentPairParams.precision, api.BigNumber.ROUND_UP), finalQty = qtyAsBigNum.minus(fee)); const xxxdToIssue = finalQty.multipliedBy(calcResultParentPool.parentPrice).toFixed(parentPairParams.precision, api.BigNumber.ROUND_DOWN); if (!api.assert(api.BigNumber(xxxdToIssue).gt(contractParams.minAmountConvertible), `resulting token issuance is too small; token price is ${calcResultParentPool.parentPrice}`)) return !1; const isBurnSuccess = await burnParentTokens(finalQty, fee, parentPairParams.parentSymbol, parentPairParams.burnRouting, contractParams, isSignedWithActiveKey); if (!api.assert(isBurnSuccess, 'error on token burn')) return !1; await api.executeSmartContract('tokens', 'issue', { to: api.sender, symbol: parentPairParams.symbol, quantity: xxxdToIssue }); const keyname = parentPairParams.parentSymbol; api.emit('Converted token to dollar token', {
            symbol: parentPairParams.symbol, fee, feeRouting: parentPairParams.burnRouting, parentSymbol: keyname, precision: parentPairParams.precision, childIssued: xxxdToIssue, parentPriceInUSD: calcResultParentPool.parentPrice,
          });
        }
      }
    }
  }
};
