const stablePairArray=["SWAP.HBD","SWAP.USDT","SWAP.DAI","SWAP.USDC"],countDecimals=value=>api.BigNumber(value).dp(),verifyTokenCreation=async symbolFind=>!!await api.db.findOneInTable("tokens","tokens",{symbol:symbolFind}),verifyTokenBalance=async(account,amount,symbolFind)=>{const findTokenBalance=await api.db.findOneInTable("tokens","balances",{account:account,symbol:symbolFind});return!(!findTokenBalance||!api.BigNumber(findTokenBalance.balance).gte(amount))},checkStablePosition=tokenPair=>{const[firstToken,secondToken]=tokenPair.split(":");return stablePairArray.includes(firstToken)?"base":!!stablePairArray.includes(secondToken)&&"quote"},findMarketPools=async(parentSymbol,toggle)=>{const childSymbol=`${parentSymbol}.D`;let poolData;if("stable"===toggle){const stableResults=[`${parentSymbol}`,`${childSymbol}`].flatMap((pElement=>stablePairArray.flatMap((sElement=>[`${sElement}:${pElement}`,`${pElement}:${sElement}`])))),multiPoolData=await api.db.findInTable("marketpools","pools",{tokenPair:{$in:stableResults}});poolData=multiPoolData.length>0?[multiPoolData.reduce(((max,item)=>item.baseQuantity+item.quoteQuantity>max.baseQuantity+max.quoteQuantity?item:max),multiPoolData[0])]:[]}if("market"===toggle){const marketParentArray=[`${parentSymbol}:${childSymbol}`,`${childSymbol}:${parentSymbol}`];poolData=await api.db.findInTable("marketpools","pools",{tokenPair:{$in:marketParentArray}})}const validPools=poolData.map((pool=>({tokenPair:pool.tokenPair,basePrice:pool.basePrice||"0",quotePrice:pool.quotePrice||"0",baseQuantity:pool.baseQuantity||"0",quoteQuantity:pool.quoteQuantity||"0"})));return validPools.length>0?validPools:null},calcParentPool=async(name,pool,tokenPriceUSD,precision)=>{const[firstToken,secondToken]=pool.tokenPair.split(":");let quoteOrBasePosition,otherTokenPriceUSD,halfPoolinUSD,fullPoolinUSD,parentTokenPrice,returnObject={};return name.includes(firstToken)&&(quoteOrBasePosition="base"),name.includes(secondToken)&&(quoteOrBasePosition="quote"),quoteOrBasePosition&&"base"===quoteOrBasePosition?(otherTokenPriceUSD=api.BigNumber(pool.quotePrice).multipliedBy(tokenPriceUSD).toFixed(precision,api.BigNumber.ROUND_DOWN),parentTokenPrice=name.includes(".D")?api.BigNumber(tokenPriceUSD).toFixed(precision,api.BigNumber.ROUND_DOWN):api.BigNumber(otherTokenPriceUSD).toFixed(precision,api.BigNumber.ROUND_DOWN),halfPoolinUSD=api.BigNumber(otherTokenPriceUSD).multipliedBy(pool.baseQuantity).toFixed(precision,api.BigNumber.ROUND_DOWN),fullPoolinUSD=api.BigNumber(halfPoolinUSD).multipliedBy(1.95).toFixed(precision,api.BigNumber.ROUND_DOWN),returnObject={quoteToken:firstToken,quotePriceUSD:otherTokenPriceUSD,baseToken:secondToken,basePriceUSD:tokenPriceUSD,precision:precision,poolValueUSD:fullPoolinUSD,parentPrice:parentTokenPrice}):quoteOrBasePosition&&"quote"===quoteOrBasePosition&&(otherTokenPriceUSD=api.BigNumber(pool.basePrice).multipliedBy(tokenPriceUSD).toFixed(precision,api.BigNumber.ROUND_DOWN),parentTokenPrice=name.includes(".D")?api.BigNumber(otherTokenPriceUSD).toFixed(precision,api.BigNumber.ROUND_DOWN):api.BigNumber(tokenPriceUSD).toFixed(precision,api.BigNumber.ROUND_DOWN),halfPoolinUSD=api.BigNumber(otherTokenPriceUSD).multipliedBy(pool.quoteQuantity).toFixed(precision,api.BigNumber.ROUND_DOWN),fullPoolinUSD=api.BigNumber(halfPoolinUSD).multipliedBy(1.95).toFixed(precision,api.BigNumber.ROUND_DOWN),returnObject={quoteToken:firstToken,quotePriceUSD:tokenPriceUSD,baseToken:secondToken,basePriceUSD:otherTokenPriceUSD,precision:precision,poolValueUSD:fullPoolinUSD,parentPrice:parentTokenPrice}),returnObject},isTokenTransferVerified=(result,from,to,symbol,quantity,eventStr)=>!(void 0!==result.errors||!result.events||void 0===result.events.find((el=>("tokens"===el.contract||"burndollar"===el.contract)&&el.event===eventStr&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol))),burnParentTokens=async(amount,fee,burnSymbol,toAccount,beedParams,isSignedWithActiveKey)=>{if(api.BigNumber(fee).gt(0)){const res=await api.executeSmartContract("tokens","transfer",{to:toAccount,symbol:burnSymbol,quantity:fee,isSignedWithActiveKey:isSignedWithActiveKey});if(!isTokenTransferVerified(res,api.sender,toAccount,burnSymbol,fee,"transfer"))return!1}const res2=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:burnSymbol,quantity:amount,isSignedWithActiveKey:isSignedWithActiveKey}),res3=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:beedParams.burnToken,quantity:beedParams.burnUsageFee,isSignedWithActiveKey:isSignedWithActiveKey});return!!isTokenTransferVerified(res2,api.sender,"null",burnSymbol,amount,"transfer")&&!!isTokenTransferVerified(res3,api.sender,"null",beedParams.burnToken,beedParams.burnUsageFee,"transfer")};actions.createSSC=async()=>{if(!1===await api.db.tableExists("params")){await api.db.createTable("params"),await api.db.createTable("burnpair",["symbol","parentSymbol"]);const params={issueDTokenFee:"1000",updateParamsFee:"100",burnUsageFee:"1",minAmountConvertible:"1",dTokenToIssuer:"1000",burnToken:"BEED"};await api.db.insert("params",params)}},actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{issueDTokenFee:issueDTokenFee,updateParamsFee:updateParamsFee,burnUsageFee:burnUsageFee,minAmountConvertible:minAmountConvertible,dTokenToIssuer:dTokenToIssuer,burnToken:burnToken}=payload,params=await api.db.findOne("params",{});if(issueDTokenFee&&"string"==typeof issueDTokenFee&&!api.BigNumber(issueDTokenFee).isNaN()&&api.BigNumber(issueDTokenFee).gte(1)&&(params.issueDTokenFee=issueDTokenFee),updateParamsFee&&"string"==typeof updateParamsFee&&!api.BigNumber(updateParamsFee).isNaN()&&api.BigNumber(updateParamsFee).gte(1)&&(params.updateParamsFee=updateParamsFee),burnUsageFee&&"string"==typeof burnUsageFee&&!api.BigNumber(burnUsageFee).isNaN()&&api.BigNumber(burnUsageFee).gte(1)&&(params.burnUsageFee=burnUsageFee),minAmountConvertible&&"string"==typeof minAmountConvertible&&!minAmountConvertible.isNaN()&&minAmountConvertible.gte(1)&&(params.minAmountConvertible=minAmountConvertible),dTokenToIssuer&&"string"==typeof dTokenToIssuer&&!api.BigNumber(dTokenToIssuer).isNaN()&&api.BigNumber(dTokenToIssuer).gte(1)&&(params.dTokenToIssuer=dTokenToIssuer),burnToken&&"string"==typeof burnToken){await api.db.findOneInTable("tokens","tokens",{symbol:burnToken})&&(params.burnToken=burnToken)}await api.db.update("params",params)},actions.createTokenD=async payload=>{const{symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey,burnRouting:burnRouting,feePercentage:feePercentage}=payload,burnPairParams={},params=await api.db.findOne("params",{}),{issueDTokenFee:issueDTokenFee}=params,beedTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:params.burnToken}),authorizedCreation=beedTokenBalance&&api.BigNumber(beedTokenBalance.balance).gte(issueDTokenFee);if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(authorizedCreation,"you must have enough BEED tokens cover the creation fees")&&api.assert(symbol&&"string"==typeof symbol&&symbol.length<=8&&symbol.length>0&&!symbol.includes(".D"),"symbol must be string of length 8 or less to create a xxx.D token")){const tokenParent=await api.db.findOneInTable("tokens","tokens",{symbol:symbol}),finalRouting=void 0===burnRouting?"null":burnRouting;if(api.assert(tokenParent.issuer===api.sender,"You must be the token issuer in order to issue D token")&&api.assert(api.isValidAccountName(finalRouting),"burn routing must be a valid Hive account name")&&api.assert(feePercentage&&"string"==typeof feePercentage&&!api.BigNumber(feePercentage).isNaN()&&api.BigNumber(feePercentage).gte(0)&&api.BigNumber(feePercentage).lte(1)&&countDecimals(feePercentage)<=4,"fee percentage must be between 0 and 1 / 0% and 100%")){let finalName="",dSymbol="";dSymbol=`${symbol}.D`;const tokenDExists=await api.db.findOneInTable("tokens","tokens",{symbol:dSymbol});if(api.assert(null===tokenDExists,"D token must not already exist")&&api.assert(tokenParent.precision>0&&Number.isInteger(tokenParent.precision),"invalid precision")){finalName=`${symbol} stablecoin`;const newToken={symbol:dSymbol,name:finalName,precision:tokenParent.precision,maxSupply:`${Number.MAX_SAFE_INTEGER}`};await api.executeSmartContract("tokens","create",newToken);const tokenCreated=await verifyTokenCreation(dSymbol);if(!api.assert(tokenCreated,"Token creation failed"))return!1;burnPairParams.issuer=api.sender,burnPairParams.symbol=dSymbol,burnPairParams.precision=tokenParent.precision,burnPairParams.parentSymbol=symbol,burnPairParams.burnRouting=finalRouting,burnPairParams.feePercentage=feePercentage,await api.db.insert("burnpair",burnPairParams),await api.executeSmartContract("tokens","issue",{to:api.sender,symbol:dSymbol,quantity:params.dTokenToIssuer}),api.BigNumber(issueDTokenFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:params.burnToken,quantity:issueDTokenFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("issued new token dollar stablecoin",{convertPercentage:feePercentage,feeRouting:burnPairParams.burnRouting,dSymbol:dSymbol})}}}},actions.updateBurnPair=async payload=>{const{symbol:symbol,burnRouting:burnRouting,feePercentage:feePercentage,isSignedWithActiveKey:isSignedWithActiveKey}=payload,finalRouting=void 0===burnRouting?"null":burnRouting;if(api.assert(api.isValidAccountName(finalRouting),"account for burn routing must exist")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol,"symbol must be string")&&api.assert(finalRouting&&"string"==typeof finalRouting,"finalRouting must be string or null")&&api.assert(feePercentage&&"string"==typeof feePercentage&&!api.BigNumber(feePercentage).isNaN()&&api.BigNumber(feePercentage).gte(0)&&api.BigNumber(feePercentage).lte(1)&&countDecimals(feePercentage)<=4,"fee percentage must be between 0 and 1 / 0% and 100%")){const token=await api.db.findOne("burnpair",{symbol:symbol});if(!api.assert(null!=token,"D token must exist"))return!1;if(token&&api.assert(token.issuer===api.sender,"must be the issuer")){const params=await api.db.findOne("params",{}),{updateParamsFee:updateParamsFee}=params,beedTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:params.burnToken}),authorizedCreation=beedTokenBalance&&api.BigNumber(beedTokenBalance.balance).gte(updateParamsFee);api.assert(authorizedCreation,"you must have enough BEED tokens to cover the update properties fee")&&(token.burnRouting=finalRouting,token.feePercentage=feePercentage,await api.db.update("burnpair",token),api.BigNumber(updateParamsFee).gt(0)&&await api.executeSmartContract("tokens","transfer",{to:"null",symbol:params.burnToken,quantity:updateParamsFee,isSignedWithActiveKey:isSignedWithActiveKey}),api.emit("updated params",{symbol:symbol,burnRouting:burnRouting,feePercentage:feePercentage}))}}},actions.convert=async payload=>{const{symbol:symbol,quantity:quantity,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN(),"invalid params quantity")&&api.assert(symbol&&"string"==typeof symbol&&symbol.length>0&&symbol.length<=10,"symbol must be string")){const contractParams=await api.db.findOne("params",{}),parentPairParams=await api.db.findOne("burnpair",{parentSymbol:symbol}),qtyAsBigNum=api.BigNumber(quantity);if(api.assert(parentPairParams,"parent symbol must have a child .D token")&&api.assert(countDecimals(quantity)<=parentPairParams.precision,"symbol precision mismatch")&&api.assert(qtyAsBigNum.gte(contractParams.minAmountConvertible),"amount to convert must be >= 1")){const hasEnoughUtilityToken=await verifyTokenBalance(api.sender,contractParams.burnUsageFee,contractParams.burnToken),hasEnoughParentBalance=await verifyTokenBalance(api.sender,qtyAsBigNum,symbol),hasEnoughStablePool=await findMarketPools(symbol,"stable"),hasEnoughMarketPool=await findMarketPools(symbol,"market");if(api.assert(hasEnoughParentBalance,"not enough token balance")&&api.assert(hasEnoughUtilityToken,"not enough utility tokens")&&api.assert(hasEnoughStablePool,"token must be in pool with a stable coin")&&api.assert(hasEnoughMarketPool,"token must be in pool with xxx.d token")){const quoteOrBase=checkStablePosition(hasEnoughStablePool[0].tokenPair);let calcResultParentPool;if(quoteOrBase&&"base"===quoteOrBase){const stablePrice=hasEnoughStablePool[0].basePrice,stableQuant=hasEnoughStablePool[0].baseQuantity,tokenNameBase=hasEnoughStablePool[0].tokenPair.split(":")[1],stableUSDValue=api.BigNumber(stablePrice).multipliedBy(stableQuant).toFixed(parentPairParams.precision,api.BigNumber.ROUND_DOWN),finalValueQuote=api.BigNumber(stableUSDValue).multipliedBy(1.95).toFixed(parentPairParams.precision,api.BigNumber.ROUND_DOWN);if(!api.assert(finalValueQuote&&finalValueQuote>=400,"stable token pool USD value must be at least 500"))return!1;calcResultParentPool=await calcParentPool(tokenNameBase,hasEnoughMarketPool[0],stablePrice,parentPairParams.precision)}else if(quoteOrBase&&"quote"===quoteOrBase){const stableTPrice=hasEnoughStablePool[0].quotePrice,quoteQuant=hasEnoughStablePool[0].quoteQuantity,tokenNameQuote=hasEnoughStablePool[0].tokenPair.split(":")[0],stableUSDValue=api.BigNumber(stableTPrice).multipliedBy(quoteQuant).toFixed(parentPairParams.precision,api.BigNumber.ROUND_DOWN),finalValueQuote=api.BigNumber(stableUSDValue).multipliedBy(1.95).toFixed(parentPairParams.precision,api.BigNumber.ROUND_DOWN);if(!api.assert(finalValueQuote&&finalValueQuote>=400,"stable token pool USD value must be at least 500"))return!1;calcResultParentPool=await calcParentPool(tokenNameQuote,hasEnoughMarketPool[0],stableTPrice,parentPairParams.precision)}if(api.assert(calcResultParentPool&&calcResultParentPool.poolValueUSD>=400,"parent token and XXX.D token pool USD value must be at least 500")){const feePercentage=api.BigNumber(parentPairParams.feePercentage);let fee="0",finalQty=qtyAsBigNum;feePercentage.gt(0)&&(fee=qtyAsBigNum.multipliedBy(feePercentage).toFixed(parentPairParams.precision,api.BigNumber.ROUND_UP),finalQty=qtyAsBigNum.minus(fee));const xxxdToIssue=finalQty.multipliedBy(calcResultParentPool.parentPrice).toFixed(parentPairParams.precision,api.BigNumber.ROUND_DOWN);if(!api.assert(api.BigNumber(xxxdToIssue).gt(contractParams.minAmountConvertible),`resulting token issuance is too small; token price is ${calcResultParentPool.parentPrice}`))return!1;const isBurnSuccess=await burnParentTokens(finalQty,fee,parentPairParams.parentSymbol,parentPairParams.burnRouting,contractParams,isSignedWithActiveKey);if(!api.assert(isBurnSuccess,"error on token burn"))return!1;await api.executeSmartContract("tokens","issue",{to:api.sender,symbol:parentPairParams.symbol,quantity:xxxdToIssue});const keyname=parentPairParams.parentSymbol;api.emit("Converted token to dollar token",{symbol:parentPairParams.symbol,fee:fee,feeRouting:parentPairParams.burnRouting,parentSymbol:keyname,precision:parentPairParams.precision,childIssued:xxxdToIssue,parentPriceInUSD:calcResultParentPool.parentPrice})}}}}};