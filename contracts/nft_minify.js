const CONTRACT_NAME="nft",UTILITY_TOKEN_SYMBOL="'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",MAX_NUM_AUTHORIZED_ISSUERS=10,MAX_NUM_LOCKED_TOKEN_TYPES=10,MAX_SYMBOL_LENGTH=10,MAX_DATA_PROPERTY_LENGTH=100,MAX_NUM_NFTS_ISSUABLE=10,MAX_NUM_NFTS_EDITABLE=50,MAX_NUM_NFTS_OPERABLE=50,MAX_NUM_CONTAINER_NFTS_OPERABLE=1,RESERVED_SYMBOLS={CELL:"beggars",QUST:"simplegame",TESTERA:"aggroed",SQRL:"stuffbyspencer",CRAFT:"immanuel94",CGULL:"cgull",NFT:"cadawg",RARE:"beggars",LIC:"lictoken",MEMBER:"membertoken",COFFEE:"c0ff33a",ROCK:"beggars",MONSTERS:"simplegame",SETS:"lootkit.games",PHOTOFT:"wwwiebe",BEER:"detlev",SPIR:"spinvest",IFG:"lion200",GUILDS:"simplegame",FCARD:"lion200",PXL:"pixelnft",COW:"stuffbyspencer",LOOOT:"stuffbyspencer",SPORTSMOM:"sportstester",SWT:"satren"};actions.createSSC=async()=>{if(!1===await api.db.tableExists("nfts")){await api.db.createTable("nfts",["symbol"]),await api.db.createTable("params"),await api.db.createTable("pendingUndelegations",["symbol","completeTimestamp"]);const params={nftCreationFee:"100",nftIssuanceFee:{"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'":"0.001",PAL:"0.001"},dataPropertyCreationFee:"100",enableDelegationFee:"1000"};await api.db.insert("params",params)}},actions.updateParams=async payload=>{if(api.sender!==api.owner)return;const{nftCreationFee:nftCreationFee,nftIssuanceFee:nftIssuanceFee,dataPropertyCreationFee:dataPropertyCreationFee,enableDelegationFee:enableDelegationFee}=payload,params=await api.db.findOne("params",{});nftCreationFee&&"string"==typeof nftCreationFee&&!api.BigNumber(nftCreationFee).isNaN()&&api.BigNumber(nftCreationFee).gte(0)&&(params.nftCreationFee=nftCreationFee),nftIssuanceFee&&"object"==typeof nftIssuanceFee&&(params.nftIssuanceFee=nftIssuanceFee),dataPropertyCreationFee&&"string"==typeof dataPropertyCreationFee&&!api.BigNumber(dataPropertyCreationFee).isNaN()&&api.BigNumber(dataPropertyCreationFee).gte(0)&&(params.dataPropertyCreationFee=dataPropertyCreationFee),enableDelegationFee&&"string"==typeof enableDelegationFee&&!api.BigNumber(enableDelegationFee).isNaN()&&api.BigNumber(enableDelegationFee).gte(0)&&(params.enableDelegationFee=enableDelegationFee),await api.db.update("params",params)};const isTokenTransferVerified=(result,from,to,symbol,quantity,eventStr)=>!(void 0!==result.errors||!result.events||void 0===result.events.find(el=>"tokens"===el.contract&&el.event===eventStr&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol)),calculateBalance=(balance,quantity,precision,add)=>add?api.BigNumber(balance).plus(quantity).toFixed(precision):api.BigNumber(balance).minus(quantity).toFixed(precision),countDecimals=value=>api.BigNumber(value).dp(),containsDuplicates=arr=>new Set(arr).size!==arr.length,isValidHiveAccountLength=account=>account.length>=3&&account.length<=16,isValidContractLength=contract=>contract.length>=3&&contract.length<=50,isValidAccountsArray=arr=>{let validContents=!0;return arr.forEach(account=>{"string"==typeof account&&isValidHiveAccountLength(account)||(validContents=!1)}),validContents},isValidContractsArray=arr=>{let validContents=!0;return arr.forEach(contract=>{"string"==typeof contract&&isValidContractLength(contract)||(validContents=!1)}),validContents},isValidDataProperties=(from,fromType,nft,properties)=>{const propertyCount=Object.keys(properties).length,nftPropertyCount=Object.keys(nft.properties).length;if(!api.assert(propertyCount<=nftPropertyCount,"cannot set more data properties than NFT has"))return!1;for(const[name,data]of Object.entries(properties)){let validContents=!1;if(api.assert(name&&"string"==typeof name&&api.validator.isAlphanumeric(name)&&name.length>0&&name.length<=25,"invalid data property name: letters & numbers only, max length of 25")&&api.assert(name in nft.properties,"data property must exist")){const propertySchema=nft.properties[name];api.assert(null!=data&&(typeof data===propertySchema.type||"number"===propertySchema.type&&"string"==typeof data&&!api.BigNumber(data).isNaN()),`data property type mismatch: expected ${propertySchema.type} but got ${typeof data} for property ${name}`)&&api.assert("string"!=typeof data||data.length<=100,"string property max length is 100 characters")&&api.assert("contract"===fromType&&propertySchema.authorizedEditingContracts.includes(from)||"user"===fromType&&propertySchema.authorizedEditingAccounts.includes(from),"not allowed to set data properties")&&(validContents=!0,"number"===propertySchema.type&&"string"==typeof data&&(properties[name]=api.BigNumber(data).toNumber()))}if(!validContents)return!1}return!0},isValidDataPropertiesArray=(from,fromType,nft,arr)=>{try{for(let i=0;i<arr.length;i+=1){let validContents=!1;const{id:id,properties:properties}=arr[i];if(api.assert(id&&"string"==typeof id&&!api.BigNumber(id).isNaN()&&api.BigNumber(id).gt(0)&&properties&&"object"==typeof properties,"invalid data properties")&&isValidDataProperties(from,fromType,nft,properties)&&(validContents=!0),!validContents)return!1}}catch(e){return!1}return!0},isValidNftIdArray=arr=>{try{let instanceCount=0;for(let i=0;i<arr.length;i+=1){let validContents=!1;const{symbol:symbol,ids:ids}=arr[i];if(api.assert(symbol&&"string"==typeof symbol&&api.validator.isAlpha(symbol)&&api.validator.isUppercase(symbol)&&symbol.length>0&&symbol.length<=10&&ids&&"object"==typeof ids&&Array.isArray(ids),"invalid nft list")&&(instanceCount+=ids.length,api.assert(instanceCount<=50,"cannot operate on more than 50 NFT instances at once"))){for(let j=0;j<ids.length;j+=1){const id=ids[j];if(!api.assert(id&&"string"==typeof id&&!api.BigNumber(id).isNaN()&&api.BigNumber(id).gt(0),"invalid nft list"))return!1}validContents=!0}if(!validContents)return!1}}catch(e){return!1}return!0},isValidTokenBasket=async(basket,balanceTableName,accountName,feeSymbol,feeQuantity)=>{try{if(Object.keys(basket).length>10)return!1;for(const[symbol,quantity]of Object.entries(basket)){let validContents=!1;if("string"==typeof symbol&&api.validator.isAlpha(symbol)&&api.validator.isUppercase(symbol)&&symbol.length>0&&symbol.length<=10){const token=await api.db.findOneInTable("tokens","tokens",{symbol:symbol});if(token&&quantity&&"string"==typeof quantity&&!api.BigNumber(quantity).isNaN()&&api.BigNumber(quantity).gt(0)&&countDecimals(quantity)<=token.precision){const finalQuantity=symbol===feeSymbol?calculateBalance(quantity,feeQuantity,token.precision,!0):quantity,basketTokenBalance=await api.db.findOneInTable("tokens",balanceTableName,{account:accountName,symbol:symbol});basketTokenBalance&&api.BigNumber(basketTokenBalance.balance).gte(finalQuantity)&&(validContents=!0)}}if(!validContents)return!1}}catch(e){return!1}return!0},transferAndVerifyNfts=async(from,fromType,to,toType,nfts,isSignedWithActiveKey,callingContractInfo)=>{const results={success:[],fail:[]},finalFromType="user"===fromType?"u":"c",finalToType="user"===toType?"u":"c";await actions.transfer({fromType:fromType,to:to,toType:toType,nfts:nfts,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo});const logs=api.logs(),tokenMap={},countedMap={};if(logs.events)for(let i=0;i<logs.events.length;i+=1){const ev=logs.events[i];if(ev.contract&&ev.event&&ev.data&&"nft"===ev.contract&&"transfer"===ev.event&&ev.data.from===from&&ev.data.fromType===finalFromType&&ev.data.to===to&&ev.data.toType===finalToType){tokenMap[ev.data.symbol+"-"+ev.data.id]=1}}for(let index=0;index<nfts.length;index+=1){const{symbol:symbol,ids:ids}=nfts[index],success=[],fail=[];for(let j=0;j<ids.length;j+=1){const inputKey=symbol+"-"+ids[j];inputKey in countedMap||(inputKey in tokenMap?success.push(ids[j].toString()):fail.push(ids[j].toString()),countedMap[inputKey]=1)}success.length>0&&results.success.push({symbol:symbol,ids:success}),fail.length>0&&results.fail.push({symbol:symbol,ids:fail})}return results};actions.updateUrl=async payload=>{const{url:url,symbol:symbol}=payload;if(api.assert(symbol&&"string"==typeof symbol&&url&&"string"==typeof url,"invalid params")&&api.assert(url.length<=255,"invalid url: max length of 255")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(nft.issuer===api.sender,"must be the issuer"))try{const metadata=JSON.parse(nft.metadata);api.assert(metadata&&metadata.url,"an error occured when trying to update the url")&&(metadata.url=url,nft.metadata=JSON.stringify(metadata),await api.db.update("nfts",nft))}catch(e){}}},actions.updateMetadata=async payload=>{const{metadata:metadata,symbol:symbol}=payload;if(api.assert(symbol&&"string"==typeof symbol&&metadata&&"object"==typeof metadata,"invalid params")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(nft.issuer===api.sender,"must be the issuer"))try{const finalMetadata=JSON.stringify(metadata);api.assert(finalMetadata.length<=1e3,"invalid metadata: max length of 1000")&&(nft.metadata=finalMetadata,await api.db.update("nfts",nft))}catch(e){}}},actions.updateName=async payload=>{const{name:name,symbol:symbol}=payload;if(api.assert(symbol&&"string"==typeof symbol&&name&&"string"==typeof name,"invalid params")&&api.assert(api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=50,"invalid name: letters, numbers, whitespaces only, max length of 50")){const nft=await api.db.findOne("nfts",{symbol:symbol});nft&&api.assert(nft.issuer===api.sender,"must be the issuer")&&(nft.name=name,await api.db.update("nfts",nft))}},actions.updateOrgName=async payload=>{const{orgName:orgName,symbol:symbol}=payload;if(api.assert(symbol&&"string"==typeof symbol&&orgName&&"string"==typeof orgName,"invalid params")&&api.assert(api.validator.isAlphanumeric(api.validator.blacklist(orgName," "))&&orgName.length>0&&orgName.length<=50,"invalid org name: letters, numbers, whitespaces only, max length of 50")){const nft=await api.db.findOne("nfts",{symbol:symbol});nft&&api.assert(nft.issuer===api.sender,"must be the issuer")&&(nft.orgName=orgName,await api.db.update("nfts",nft))}},actions.updateProductName=async payload=>{const{productName:productName,symbol:symbol}=payload;if(api.assert(symbol&&"string"==typeof symbol&&productName&&"string"==typeof productName,"invalid params")&&api.assert(api.validator.isAlphanumeric(api.validator.blacklist(productName," "))&&productName.length>0&&productName.length<=50,"invalid product name: letters, numbers, whitespaces only, max length of 50")){const nft=await api.db.findOne("nfts",{symbol:symbol});nft&&api.assert(nft.issuer===api.sender,"must be the issuer")&&(nft.productName=productName,await api.db.update("nfts",nft))}},actions.addAuthorizedIssuingAccounts=async payload=>{const{accounts:accounts,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&accounts&&"object"==typeof accounts&&Array.isArray(accounts),"invalid params")&&api.assert(accounts.length<=10,"cannot have more than 10 authorized issuing accounts")){const validContents=isValidAccountsArray(accounts);if(api.assert(validContents,"invalid account list")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft){const sanitizedList=[];if(accounts.forEach(account=>{const finalAccount=account.trim().toLowerCase();let isDuplicate=!1;for(let i=0;i<nft.authorizedIssuingAccounts.length;i+=1)if(finalAccount===nft.authorizedIssuingAccounts[i]){isDuplicate=!0;break}isDuplicate||sanitizedList.push(finalAccount)}),api.assert(nft.issuer===api.sender,"must be the issuer")&&api.assert(!containsDuplicates(sanitizedList),"cannot add the same account twice")&&api.assert(nft.authorizedIssuingAccounts.length+sanitizedList.length<=10,"cannot have more than 10 authorized issuing accounts")){const finalAccountList=nft.authorizedIssuingAccounts.concat(sanitizedList);nft.authorizedIssuingAccounts=finalAccountList,await api.db.update("nfts",nft)}}}}},actions.addAuthorizedIssuingContracts=async payload=>{const{contracts:contracts,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&contracts&&"object"==typeof contracts&&Array.isArray(contracts),"invalid params")&&api.assert(contracts.length<=10,"cannot have more than 10 authorized issuing contracts")){const validContents=isValidContractsArray(contracts);if(api.assert(validContents,"invalid contract list")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft){const sanitizedList=[];if(contracts.forEach(contract=>{const finalContract=contract.trim();let isDuplicate=!1;for(let i=0;i<nft.authorizedIssuingContracts.length;i+=1)if(finalContract===nft.authorizedIssuingContracts[i]){isDuplicate=!0;break}isDuplicate||sanitizedList.push(finalContract)}),api.assert(nft.issuer===api.sender,"must be the issuer")&&api.assert(!containsDuplicates(sanitizedList),"cannot add the same contract twice")&&api.assert(nft.authorizedIssuingContracts.length+sanitizedList.length<=10,"cannot have more than 10 authorized issuing contracts")){const finalContractList=nft.authorizedIssuingContracts.concat(sanitizedList);nft.authorizedIssuingContracts=finalContractList,await api.db.update("nfts",nft)}}}}},actions.removeAuthorizedIssuingAccounts=async payload=>{const{accounts:accounts,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&accounts&&"object"==typeof accounts&&Array.isArray(accounts),"invalid params")&&api.assert(accounts.length<=10,"cannot remove more than 10 authorized issuing accounts")){const validContents=isValidAccountsArray(accounts);if(api.assert(validContents,"invalid account list")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(nft.issuer===api.sender,"must be the issuer")){const finalAccountList=nft.authorizedIssuingAccounts.filter(currentValue=>{for(let i=0;i<accounts.length;i+=1){if(currentValue===accounts[i].trim().toLowerCase())return!1}return!0});nft.authorizedIssuingAccounts=finalAccountList,await api.db.update("nfts",nft)}}}},actions.removeAuthorizedIssuingContracts=async payload=>{const{contracts:contracts,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&contracts&&"object"==typeof contracts&&Array.isArray(contracts),"invalid params")&&api.assert(contracts.length<=10,"cannot remove more than 10 authorized issuing contracts")){const validContents=isValidContractsArray(contracts);if(api.assert(validContents,"invalid contract list")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(nft.issuer===api.sender,"must be the issuer")){const finalContractList=nft.authorizedIssuingContracts.filter(currentValue=>{for(let i=0;i<contracts.length;i+=1){if(currentValue===contracts[i].trim())return!1}return!0});nft.authorizedIssuingContracts=finalContractList,await api.db.update("nfts",nft)}}}},actions.transferOwnership=async payload=>{const{symbol:symbol,to:to,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&to&&"string"==typeof to,"invalid params")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(nft.issuer===api.sender,"must be the issuer")){const finalTo=to.trim().toLowerCase();api.assert(isValidHiveAccountLength(finalTo),"invalid to")&&(nft.issuer=finalTo,await api.db.update("nfts",nft),api.emit("transferOwnership",{from:api.sender,to:finalTo,symbol:symbol}))}}},actions.enableDelegation=async payload=>{const{symbol:symbol,undelegationCooldown:undelegationCooldown,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{enableDelegationFee:enableDelegationFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:UTILITY_TOKEN_SYMBOL}),authorized=!!api.BigNumber(enableDelegationFee).lte(0)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(enableDelegationFee);if(api.assert(authorized,"you must have enough tokens to cover fees")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol,"invalid symbol")&&api.assert(undelegationCooldown&&Number.isInteger(undelegationCooldown)&&undelegationCooldown>0&&undelegationCooldown<=18250,"undelegationCooldown must be an integer between 1 and 18250")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(api.assert(null!==nft,"symbol does not exist")&&api.assert(nft.issuer===api.sender,"must be the issuer")&&api.assert(void 0===nft.delegationEnabled||!1===nft.delegationEnabled,"delegation already enabled")){if(api.BigNumber(enableDelegationFee).gt(0)){const res=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:UTILITY_TOKEN_SYMBOL,quantity:enableDelegationFee,isSignedWithActiveKey:isSignedWithActiveKey});if(!isTokenTransferVerified(res,api.sender,"null",UTILITY_TOKEN_SYMBOL,enableDelegationFee,"transfer"))return!1}return nft.delegationEnabled=!0,nft.undelegationCooldown=undelegationCooldown,await api.db.update("nfts",nft),!0}}return!1},actions.updatePropertyDefinition=async payload=>{const{symbol:symbol,name:name,newName:newName,type:type,isReadOnly:isReadOnly,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&name&&"string"==typeof name,"invalid params")&&api.assert(api.validator.isAlphanumeric(name)&&name.length>0&&name.length<=25,"invalid name: letters & numbers only, max length of 25")&&api.assert(void 0===newName||"string"==typeof newName&&api.validator.isAlphanumeric(newName)&&newName.length>0&&newName.length<=25,"invalid new name: letters & numbers only, max length of 25")&&api.assert(void 0===type||"string"==typeof type&&("number"===type||"string"===type||"boolean"===type),"invalid type: must be number, string, or boolean")&&api.assert(void 0===isReadOnly||"boolean"==typeof isReadOnly,"invalid isReadOnly: must be true or false")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(0===nft.supply,"cannot change data property definition; tokens already issued")&&api.assert(name in nft.properties,"property must exist")&&api.assert(nft.issuer===api.sender,"must be the issuer")){if(void 0!==newName){if(void 0!==nft.groupBy&&nft.groupBy.length>0&&!api.assert(!nft.groupBy.includes(name),"cannot change data property name; property is part of groupBy"))return!1;if(!api.assert(newName!==name,"new name must be different from old name")||!api.assert(!(newName in nft.properties),"there is already a data property with the given new name"))return!1}let shouldUpdate=!1;const originalType=nft.properties[name].type,originalIsReadOnly=nft.properties[name].isReadOnly;return void 0!==type&&type!==originalType&&(nft.properties[name].type=type,shouldUpdate=!0),void 0!==isReadOnly&&isReadOnly!==originalIsReadOnly&&(nft.properties[name].isReadOnly=isReadOnly,shouldUpdate=!0),void 0!==newName&&newName!==name&&(nft.properties[newName]=nft.properties[name],delete nft.properties[name],shouldUpdate=!0),shouldUpdate&&(await api.db.update("nfts",nft),api.emit("updatePropertyDefinition",{symbol:symbol,originalName:name,originalType:originalType,originalIsReadOnly:originalIsReadOnly,newName:newName,newType:type,newIsReadOnly:isReadOnly})),!0}}return!1},actions.addProperty=async payload=>{const{symbol:symbol,name:name,type:type,isReadOnly:isReadOnly,authorizedEditingAccounts:authorizedEditingAccounts,authorizedEditingContracts:authorizedEditingContracts,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{dataPropertyCreationFee:dataPropertyCreationFee}=params;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&name&&"string"==typeof name&&(void 0===isReadOnly||"boolean"==typeof isReadOnly)&&(void 0===authorizedEditingAccounts||authorizedEditingAccounts&&"object"==typeof authorizedEditingAccounts&&Array.isArray(authorizedEditingAccounts))&&(void 0===authorizedEditingContracts||authorizedEditingContracts&&"object"==typeof authorizedEditingContracts&&Array.isArray(authorizedEditingContracts))&&type&&"string"==typeof type,"invalid params")&&api.assert(api.validator.isAlphanumeric(name)&&name.length>0&&name.length<=25,"invalid name: letters & numbers only, max length of 25")&&api.assert("number"===type||"string"===type||"boolean"===type,"invalid type: must be number, string, or boolean")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(!(name in nft.properties),"cannot add the same property twice")&&api.assert(nft.issuer===api.sender,"must be the issuer")){if(Object.keys(nft.properties).length>=3){const utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:UTILITY_TOKEN_SYMBOL}),authorizedCreation=!!api.BigNumber(dataPropertyCreationFee).lte(0)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(dataPropertyCreationFee);if(!api.assert(authorizedCreation,"you must have enough tokens to cover the creation fees"))return!1;if(api.BigNumber(dataPropertyCreationFee).gt(0)){const res=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:UTILITY_TOKEN_SYMBOL,quantity:dataPropertyCreationFee,isSignedWithActiveKey:isSignedWithActiveKey});if(!isTokenTransferVerified(res,api.sender,"null",UTILITY_TOKEN_SYMBOL,dataPropertyCreationFee,"transfer"))return!1}}const newProperty={type:type,isReadOnly:void 0!==isReadOnly&&isReadOnly,authorizedEditingAccounts:void 0===authorizedEditingAccounts?[api.sender]:[],authorizedEditingContracts:[]};return nft.properties[name]=newProperty,await api.db.update("nfts",nft),(authorizedEditingAccounts||authorizedEditingContracts)&&await actions.setPropertyPermissions({symbol:symbol,name:name,accounts:authorizedEditingAccounts,contracts:authorizedEditingContracts,isSignedWithActiveKey:isSignedWithActiveKey}),!0}}return!1},actions.setPropertyPermissions=async payload=>{const{symbol:symbol,name:name,accounts:accounts,contracts:contracts,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&name&&"string"==typeof name&&(void 0===accounts||accounts&&"object"==typeof accounts&&Array.isArray(accounts))&&(void 0===contracts||contracts&&"object"==typeof contracts&&Array.isArray(contracts)),"invalid params")&&api.assert(api.validator.isAlphanumeric(name)&&name.length>0&&name.length<=25,"invalid name: letters & numbers only, max length of 25")&&api.assert(void 0===accounts||accounts.length<=10,"cannot have more than 10 authorized accounts")&&api.assert(void 0===contracts||contracts.length<=10,"cannot have more than 10 authorized contracts")&&api.assert(void 0===accounts||isValidAccountsArray(accounts),"invalid account list")&&api.assert(void 0===contracts||isValidContractsArray(contracts),"invalid contract list")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(name in nft.properties,"property must exist")&&api.assert(nft.issuer===api.sender,"must be the issuer")){let sanitizedAccountList=[],sanitizedContractList=[];if(accounts&&(sanitizedAccountList=accounts.map(account=>account.trim().toLowerCase())),contracts&&(sanitizedContractList=contracts.map(contract=>contract.trim())),api.assert(void 0===accounts||!containsDuplicates(sanitizedAccountList),"cannot add the same account twice")&&api.assert(void 0===contracts||!containsDuplicates(sanitizedContractList),"cannot add the same contract twice")){let shouldUpdate=!1;accounts&&(nft.properties[name].authorizedEditingAccounts=sanitizedAccountList,shouldUpdate=!0),contracts&&(nft.properties[name].authorizedEditingContracts=sanitizedContractList,shouldUpdate=!0),shouldUpdate&&await api.db.update("nfts",nft)}}}},actions.setGroupBy=async payload=>{const{symbol:symbol,properties:properties,isSignedWithActiveKey:isSignedWithActiveKey}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&properties&&"object"==typeof properties&&Array.isArray(properties),"invalid params")){const nft=await api.db.findOne("nfts",{symbol:symbol});if(nft){const nftPropertyCount=Object.keys(nft.properties).length;if(api.assert(nft.issuer===api.sender,"must be the issuer")&&api.assert(void 0===nft.groupBy||0===nft.groupBy.length,"list is already set")&&api.assert(properties.length<=nftPropertyCount,"cannot set more data properties than NFT has")&&api.assert(!containsDuplicates(properties),"list cannot contain duplicates")){for(let i=0;i<properties.length;i+=1){const name=properties[i];if(!api.assert(name&&"string"==typeof name&&name in nft.properties,"data property must exist"))return!1}return nft.groupBy=properties,await api.db.update("nfts",nft),!0}}}return!1},actions.setProperties=async payload=>{const{symbol:symbol,fromType:fromType,nfts:nfts,callingContractInfo:callingContractInfo}=payload,finalFromType=void 0===fromType?"user":fromType;if(api.assert(nfts&&"object"==typeof nfts&&Array.isArray(nfts)&&finalFromType&&"string"==typeof finalFromType&&["user","contract"].includes(finalFromType)&&symbol&&"string"==typeof symbol&&(callingContractInfo||void 0===callingContractInfo&&"user"===finalFromType),"invalid params")&&api.assert(nfts.length<=50,"cannot set properties on more than 50 NFT instances at once")){const finalFrom="user"===finalFromType?api.sender:callingContractInfo.name,nft=await api.db.findOne("nfts",{symbol:symbol});if(api.assert(null!==nft,"symbol does not exist")){if(!isValidDataPropertiesArray(finalFrom,finalFromType,nft,nfts))return!1;const instanceTableName=symbol+"instances";for(let i=0;i<nfts.length;i+=1){const{id:id,properties:properties}=nfts[i];if(0===Object.keys(properties).length)continue;const nftInstance=await api.db.findOne(instanceTableName,{_id:api.BigNumber(id).toNumber()});if(api.assert(null!==nftInstance,"nft instance does not exist")){let shouldUpdate=!1;for(const[name,data]of Object.entries(properties)){let oldProperty=null;nft.properties[name].isReadOnly?api.assert(!(name in nftInstance.properties),"cannot edit read-only properties")&&(nftInstance.properties[name]=data,shouldUpdate=!0):(oldProperty=nftInstance.properties[name],nftInstance.properties[name]=data,shouldUpdate=!0),shouldUpdate&&oldProperty!==data&&await api.executeSmartContract("mining","handleNftSetProperty",{symbol:symbol,nft:nftInstance,propertyName:name,oldValue:oldProperty})}shouldUpdate&&await api.db.update(instanceTableName,nftInstance)}}return!0}}return!1},actions.burn=async payload=>{const{fromType:fromType,nfts:nfts,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload,finalFromType=void 0===fromType?"user":fromType;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(finalFromType&&"string"==typeof finalFromType&&["user","contract"].includes(finalFromType)&&(callingContractInfo||void 0===callingContractInfo&&"user"===finalFromType)&&nfts&&"object"==typeof nfts&&Array.isArray(nfts),"invalid params")&&isValidNftIdArray(nfts)){const finalFrom="user"===finalFromType?api.sender:callingContractInfo.name;let containerCount=0,tokenCount=0,isFirstInstanceContainer=!1;for(let i=0;i<nfts.length;i+=1){const{symbol:symbol,ids:ids}=nfts[i],nft=await api.db.findOne("nfts",{symbol:symbol});if(nft){const instanceTableName=symbol+"instances";for(let j=0;j<ids.length;j+=1){const id=ids[j],nftInstance=await api.db.findOne(instanceTableName,{_id:api.BigNumber(id).toNumber()});if(nftInstance){let isBurnAuthorized=!0;if(nftInstance.lockedNfts&&nftInstance.lockedNfts.length>0?(0===tokenCount&&(isFirstInstanceContainer=!0),containerCount+=1,(containerCount>1||!isFirstInstanceContainer)&&(isBurnAuthorized=!1)):isFirstInstanceContainer&&(isBurnAuthorized=!1),tokenCount+=1,nftInstance.account===finalFrom&&("u"===nftInstance.ownedBy&&"user"===finalFromType||"c"===nftInstance.ownedBy&&"contract"===finalFromType)&&void 0===nftInstance.delegatedTo&&isBurnAuthorized){const finalLockTokens={};let isTransferSuccess=!0;for(const[locksymbol,quantity]of Object.entries(nftInstance.lockedTokens)){const res=await api.transferTokens(finalFrom,locksymbol,quantity,finalFromType);isTokenTransferVerified(res,"nft",finalFrom,locksymbol,quantity,"transferFromContract")||(finalLockTokens[locksymbol]=quantity,isTransferSuccess=!1)}api.assert(isTransferSuccess,`unable to release locked tokens in: ${symbol}, id ${id}`);const origLockNfts=nftInstance.lockedNfts&&nftInstance.lockedNfts.length>0?nftInstance.lockedNfts:[];if(isTransferSuccess&&nftInstance.lockedNfts&&nftInstance.lockedNfts.length>0){const res=await transferAndVerifyNfts("nft","contract",finalFrom,finalFromType,nftInstance.lockedNfts,isSignedWithActiveKey,{name:"nft"});nftInstance.lockedNfts=res.fail,nftInstance.lockedNfts.length>0&&(isTransferSuccess=!1),api.assert(isTransferSuccess,`unable to release locked NFT instances in: ${symbol}, id ${id}`)}const origOwnedBy=nftInstance.ownedBy,origLockTokens=nftInstance.lockedTokens;nftInstance.lockedTokens=finalLockTokens,isTransferSuccess&&(nftInstance.previousAccount=nftInstance.account,nftInstance.previousOwnedBy=nftInstance.ownedBy,nftInstance.account="null",nftInstance.ownedBy="u",nft.circulatingSupply-=1),await api.db.update(instanceTableName,nftInstance),isTransferSuccess&&api.emit("burn",{account:finalFrom,ownedBy:origOwnedBy,unlockedTokens:origLockTokens,unlockedNfts:origLockNfts,symbol:symbol,id:id})}}}await api.db.update("nfts",nft)}}}},actions.transfer=async payload=>{const{fromType:fromType,to:to,toType:toType,nfts:nfts,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload,types=["user","contract"],finalToType=void 0===toType?"user":toType,finalFromType=void 0===fromType?"user":fromType;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(finalFromType&&"string"==typeof finalFromType&&types.includes(finalFromType)&&to&&"string"==typeof to&&finalToType&&"string"==typeof finalToType&&types.includes(finalToType)&&(callingContractInfo||void 0===callingContractInfo&&"user"===finalFromType)&&nfts&&"object"==typeof nfts&&Array.isArray(nfts),"invalid params")&&isValidNftIdArray(nfts)){const finalTo="user"===finalToType?to.trim().toLowerCase():to.trim(),toValid="user"===finalToType?isValidHiveAccountLength(finalTo):isValidContractLength(finalTo),finalFrom="user"===finalFromType?api.sender:callingContractInfo.name;if(api.assert(toValid,"invalid to")&&api.assert(!(finalToType===finalFromType&&finalTo===finalFrom),"cannot transfer to self")&&api.assert(!("user"===finalToType&&"null"===finalTo),"cannot transfer to null; use burn action instead"))for(let i=0;i<nfts.length;i+=1){const{symbol:symbol,ids:ids}=nfts[i];if(await api.db.findOne("nfts",{symbol:symbol})){const instanceTableName=symbol+"instances";for(let j=0;j<ids.length;j+=1){const id=ids[j],nftInstance=await api.db.findOne(instanceTableName,{_id:api.BigNumber(id).toNumber()});if(nftInstance&&nftInstance.account===finalFrom&&("u"===nftInstance.ownedBy&&"user"===finalFromType||"c"===nftInstance.ownedBy&&"contract"===finalFromType)&&void 0===nftInstance.delegatedTo&&!nftInstance.soulBound){const origOwnedBy=nftInstance.ownedBy,newOwnedBy="user"===finalToType?"u":"c";nftInstance.previousAccount=nftInstance.account,nftInstance.previousOwnedBy=nftInstance.ownedBy,nftInstance.account=finalTo,nftInstance.ownedBy=newOwnedBy,await api.db.update(instanceTableName,nftInstance),api.emit("transfer",{from:finalFrom,fromType:origOwnedBy,to:finalTo,toType:newOwnedBy,symbol:symbol,id:id})}}}}}},actions.delegate=async payload=>{const{fromType:fromType,to:to,toType:toType,nfts:nfts,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload,types=["user","contract"],finalToType=void 0===toType?"user":toType,finalFromType=void 0===fromType?"user":fromType;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(finalFromType&&"string"==typeof finalFromType&&types.includes(finalFromType)&&to&&"string"==typeof to&&finalToType&&"string"==typeof finalToType&&types.includes(finalToType)&&(callingContractInfo||void 0===callingContractInfo&&"user"===finalFromType)&&nfts&&"object"==typeof nfts&&Array.isArray(nfts),"invalid params")&&isValidNftIdArray(nfts)){const finalTo="user"===finalToType?to.trim().toLowerCase():to.trim(),toValid="user"===finalToType?isValidHiveAccountLength(finalTo):isValidContractLength(finalTo),finalFrom="user"===finalFromType?api.sender:callingContractInfo.name;if(api.assert(toValid,"invalid to")&&api.assert(!(finalToType===finalFromType&&finalTo===finalFrom),"cannot delegate to self")&&api.assert(!("user"===finalToType&&"null"===finalTo),"cannot delegate to null"))for(let i=0;i<nfts.length;i+=1){const{symbol:symbol,ids:ids}=nfts[i],nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(!0===nft.delegationEnabled,`delegation not enabled for ${symbol}`)){const instanceTableName=symbol+"instances";for(let j=0;j<ids.length;j+=1){const id=ids[j],nftInstance=await api.db.findOne(instanceTableName,{_id:api.BigNumber(id).toNumber()});if(nftInstance&&nftInstance.account===finalFrom&&("u"===nftInstance.ownedBy&&"user"===finalFromType||"c"===nftInstance.ownedBy&&"contract"===finalFromType)&&void 0===nftInstance.delegatedTo&&!nftInstance.soulBound){const newOwnedBy="user"===finalToType?"u":"c",newDelegation={account:finalTo,ownedBy:newOwnedBy};nftInstance.delegatedTo=newDelegation,await api.db.update(instanceTableName,nftInstance),api.emit("delegate",{from:finalFrom,fromType:nftInstance.ownedBy,to:finalTo,toType:newOwnedBy,symbol:symbol,id:id}),await api.executeSmartContract("mining","handleNftDelegationChange",{symbol:symbol,nft:nftInstance,add:!0})}}}}}},actions.undelegate=async payload=>{const{fromType:fromType,nfts:nfts,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload,finalFromType=void 0===fromType?"user":fromType;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(finalFromType&&"string"==typeof finalFromType&&["user","contract"].includes(finalFromType)&&(callingContractInfo||void 0===callingContractInfo&&"user"===finalFromType)&&nfts&&"object"==typeof nfts&&Array.isArray(nfts),"invalid params")&&isValidNftIdArray(nfts)){const finalFrom="user"===finalFromType?api.sender:callingContractInfo.name,blockDate=new Date(`${api.hiveBlockTimestamp}.000Z`);for(let i=0;i<nfts.length;i+=1){const{symbol:symbol,ids:ids}=nfts[i],nft=await api.db.findOne("nfts",{symbol:symbol});if(nft&&api.assert(!0===nft.delegationEnabled,`delegation not enabled for ${symbol}`)){const cooldownPeriodMillisec=24*nft.undelegationCooldown*3600*1e3,completeTimestamp=blockDate.getTime()+cooldownPeriodMillisec,instanceTableName=symbol+"instances",undelegation={symbol:symbol,ids:[],completeTimestamp:completeTimestamp};for(let j=0;j<ids.length;j+=1){const id=ids[j],nftInstance=await api.db.findOne(instanceTableName,{_id:api.BigNumber(id).toNumber()});nftInstance&&nftInstance.account===finalFrom&&("u"===nftInstance.ownedBy&&"user"===finalFromType||"c"===nftInstance.ownedBy&&"contract"===finalFromType)&&nftInstance.delegatedTo&&void 0===nftInstance.delegatedTo.undelegateAt&&(nftInstance.delegatedTo.undelegateAt=completeTimestamp,undelegation.ids.push(nftInstance._id),await api.db.update(instanceTableName,nftInstance),api.emit("undelegateStart",{from:nftInstance.delegatedTo.account,fromType:nftInstance.delegatedTo.ownedBy,symbol:symbol,id:id}),await api.executeSmartContract("mining","handleNftDelegationChange",{symbol:symbol,nft:nftInstance,add:!1}))}undelegation.ids.length>0&&await api.db.insert("pendingUndelegations",undelegation)}}}};const processUndelegation=async undelegation=>{const{symbol:symbol,ids:ids}=undelegation,instanceTableName=symbol+"instances",instances=await api.db.find(instanceTableName,{_id:{$in:ids}},50,0,[{index:"_id",descending:!1}]);for(let i=0;i<instances.length;i+=1)delete instances[i].delegatedTo,await api.db.update(instanceTableName,instances[i],{delegatedTo:""});await api.db.remove("pendingUndelegations",undelegation),api.emit("undelegateDone",{symbol:symbol,ids:ids})};actions.checkPendingUndelegations=async()=>{if(api.assert("null"===api.sender,"not authorized")){const timestamp=new Date(`${api.hiveBlockTimestamp}.000Z`).getTime();let pendingUndelegations=await api.db.find("pendingUndelegations",{completeTimestamp:{$lte:timestamp}}),nbPendingUndelegations=pendingUndelegations.length;for(;nbPendingUndelegations>0;){for(let index=0;index<nbPendingUndelegations;index+=1){const pendingUndelegation=pendingUndelegations[index];await processUndelegation(pendingUndelegation)}pendingUndelegations=await api.db.find("pendingUndelegations",{completeTimestamp:{$lte:timestamp}}),nbPendingUndelegations=pendingUndelegations.length}}},actions.create=async payload=>{const{name:name,orgName:orgName,productName:productName,symbol:symbol,url:url,maxSupply:maxSupply,authorizedIssuingAccounts:authorizedIssuingAccounts,authorizedIssuingContracts:authorizedIssuingContracts,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{nftCreationFee:nftCreationFee}=params,utilityTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:UTILITY_TOKEN_SYMBOL}),authorizedCreation=!!api.BigNumber(nftCreationFee).lte(0)||utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(nftCreationFee);if(api.assert(authorizedCreation,"you must have enough tokens to cover the creation fees")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(name&&"string"==typeof name&&symbol&&"string"==typeof symbol&&(void 0===url||url&&"string"==typeof url)&&(void 0===orgName||orgName&&"string"==typeof orgName)&&(void 0===productName||productName&&"string"==typeof productName)&&(void 0===authorizedIssuingAccounts||authorizedIssuingAccounts&&"object"==typeof authorizedIssuingAccounts&&Array.isArray(authorizedIssuingAccounts))&&(void 0===authorizedIssuingContracts||authorizedIssuingContracts&&"object"==typeof authorizedIssuingContracts&&Array.isArray(authorizedIssuingContracts))&&(void 0===maxSupply||maxSupply&&"string"==typeof maxSupply&&!api.BigNumber(maxSupply).isNaN()),"invalid params")&&api.assert(api.validator.isAlpha(symbol)&&api.validator.isUppercase(symbol)&&symbol.length>0&&symbol.length<=10,"invalid symbol: uppercase letters only, max length of 10")&&api.assert(void 0===RESERVED_SYMBOLS[symbol]||api.sender===RESERVED_SYMBOLS[symbol],"cannot use this symbol")&&api.assert(api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=50,"invalid name: letters, numbers, whitespaces only, max length of 50")&&api.assert(void 0===orgName||api.validator.isAlphanumeric(api.validator.blacklist(orgName," "))&&orgName.length>0&&orgName.length<=50,"invalid org name: letters, numbers, whitespaces only, max length of 50")&&api.assert(void 0===productName||api.validator.isAlphanumeric(api.validator.blacklist(productName," "))&&productName.length>0&&productName.length<=50,"invalid product name: letters, numbers, whitespaces only, max length of 50")&&api.assert(void 0===url||url.length<=255,"invalid url: max length of 255")&&api.assert(void 0===maxSupply||api.BigNumber(maxSupply).gt(0),"maxSupply must be positive")&&api.assert(void 0===maxSupply||api.BigNumber(maxSupply).lte(Number.MAX_SAFE_INTEGER),`maxSupply must be lower than ${Number.MAX_SAFE_INTEGER}`)){const nft=await api.db.findOne("nfts",{symbol:symbol});if(api.assert(null===nft,"symbol already exists")){if(api.BigNumber(nftCreationFee).gt(0)){const res=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:UTILITY_TOKEN_SYMBOL,quantity:nftCreationFee,isSignedWithActiveKey:isSignedWithActiveKey});if(!isTokenTransferVerified(res,api.sender,"null",UTILITY_TOKEN_SYMBOL,nftCreationFee,"transfer"))return!1}const finalMaxSupply=void 0===maxSupply?0:api.BigNumber(maxSupply).integerValue(api.BigNumber.ROUND_DOWN).toNumber(),finalOrgName=void 0===orgName?"":orgName,finalProductName=void 0===productName?"":productName;let metadata={url:void 0===url?"":url};metadata=JSON.stringify(metadata);const initialAccountList=void 0===authorizedIssuingAccounts?[api.sender]:[],newNft={issuer:api.sender,symbol:symbol,name:name,orgName:finalOrgName,productName:finalProductName,metadata:metadata,maxSupply:finalMaxSupply,supply:0,circulatingSupply:0,delegationEnabled:!1,undelegationCooldown:0,authorizedIssuingAccounts:initialAccountList,authorizedIssuingContracts:[],properties:{},groupBy:[]},instanceTableName=symbol+"instances";return!1===await api.db.tableExists(instanceTableName)&&await api.db.createTable(instanceTableName,["account","ownedBy"]),await api.db.insert("nfts",newNft),void 0!==authorizedIssuingAccounts&&await actions.addAuthorizedIssuingAccounts({accounts:authorizedIssuingAccounts,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}),void 0!==authorizedIssuingContracts&&await actions.addAuthorizedIssuingContracts({contracts:authorizedIssuingContracts,symbol:symbol,isSignedWithActiveKey:isSignedWithActiveKey}),!0}}return!1},actions.issue=async payload=>{const{symbol:symbol,fromType:fromType,to:to,toType:toType,feeSymbol:feeSymbol,lockTokens:lockTokens,lockNfts:lockNfts,soulBound:soulBound,properties:properties,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload,types=["user","contract"],finalToType=void 0===toType?"user":toType,finalFromType=void 0===fromType?"user":fromType,params=await api.db.findOne("params",{}),{nftIssuanceFee:nftIssuanceFee}=params;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(symbol&&"string"==typeof symbol&&finalFromType&&"string"==typeof finalFromType&&types.includes(finalFromType)&&(callingContractInfo||void 0===callingContractInfo&&"user"===finalFromType)&&to&&"string"==typeof to&&finalToType&&"string"==typeof finalToType&&types.includes(finalToType)&&feeSymbol&&"string"==typeof feeSymbol&&feeSymbol in nftIssuanceFee&&(void 0===properties||properties&&"object"==typeof properties)&&(void 0===lockTokens||lockTokens&&"object"==typeof lockTokens)&&(void 0===lockNfts||lockNfts&&"object"==typeof lockNfts&&Array.isArray(lockNfts))&&(void 0===soulBound||"boolean"==typeof soulBound),"invalid params")&&(void 0===lockNfts||isValidNftIdArray(lockNfts))){const finalTo="user"===finalToType?to.trim().toLowerCase():to.trim(),toValid="user"===finalToType?isValidHiveAccountLength(finalTo):isValidContractLength(finalTo),finalFrom="user"===finalFromType?api.sender:callingContractInfo.name,balanceTableName="user"===finalFromType?"balances":"contractsBalances";if(api.assert(toValid,"invalid to")){const nft=await api.db.findOne("nfts",{symbol:symbol}),feeToken=await api.db.findOneInTable("tokens","tokens",{symbol:feeSymbol});if(api.assert(null!==nft,"symbol does not exist")&&api.assert(null!==feeToken,"fee symbol does not exist")){const instanceTableName=symbol+"instances";if(api.assert("contract"===finalFromType&&nft.authorizedIssuingContracts.includes(finalFrom)||"user"===finalFromType&&nft.authorizedIssuingAccounts.includes(finalFrom),"not allowed to issue tokens")&&api.assert(0===nft.maxSupply||nft.supply<nft.maxSupply,"max supply limit reached")){const propertyCount=Object.keys(nft.properties).length,propertyFee=api.BigNumber(nftIssuanceFee[feeSymbol]).multipliedBy(propertyCount),issuanceFee=calculateBalance(nftIssuanceFee[feeSymbol],propertyFee,feeToken.precision,!0),feeTokenBalance=await api.db.findOneInTable("tokens",balanceTableName,{account:finalFrom,symbol:feeSymbol}),authorizedCreation=!!api.BigNumber(issuanceFee).lte(0)||feeTokenBalance&&api.BigNumber(feeTokenBalance.balance).gte(issuanceFee);if(lockTokens){const isLockValid=await isValidTokenBasket(lockTokens,balanceTableName,finalFrom,feeSymbol,issuanceFee);if(!api.assert(isLockValid,"invalid basket of tokens to lock (cannot lock more than 10 token types; issuing account must have enough balance)"))return!1}let finalProperties={};if(void 0!==properties){try{if(!isValidDataProperties(finalFrom,finalFromType,nft,properties))return!1}catch(e){return!1}finalProperties=properties}if(api.assert(authorizedCreation,"you must have enough tokens to cover the issuance fees")){if(api.BigNumber(issuanceFee).gt(0))if("contract"===finalFromType){const res=await api.transferTokensFromCallingContract("null",feeSymbol,issuanceFee,"user");if(!api.assert(isTokenTransferVerified(res,finalFrom,"null",feeSymbol,issuanceFee,"transferFromContract"),"unable to transfer issuance fee"))return!1}else{const res=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:feeSymbol,quantity:issuanceFee,isSignedWithActiveKey:isSignedWithActiveKey});if(!api.assert(isTokenTransferVerified(res,finalFrom,"null",feeSymbol,issuanceFee,"transfer"),"unable to transfer issuance fee"))return!1}const finalLockTokens={};if(lockTokens)for(const[locksymbol,quantity]of Object.entries(lockTokens))if("contract"===finalFromType){const res=await api.transferTokensFromCallingContract("nft",locksymbol,quantity,"contract");isTokenTransferVerified(res,finalFrom,"nft",locksymbol,quantity,"transferFromContract")&&(finalLockTokens[locksymbol]=quantity)}else{const res=await api.executeSmartContract("tokens","transferToContract",{to:"nft",symbol:locksymbol,quantity:quantity,isSignedWithActiveKey:isSignedWithActiveKey});isTokenTransferVerified(res,finalFrom,"nft",locksymbol,quantity,"transferToContract")&&(finalLockTokens[locksymbol]=quantity)}let finalLockNfts=[];if(lockNfts&&lockNfts.length>0){finalLockNfts=(await transferAndVerifyNfts(finalFrom,finalFromType,"nft","contract",lockNfts,isSignedWithActiveKey,callingContractInfo)).success}const ownedBy="user"===finalToType?"u":"c";let newInstance={};newInstance=finalLockNfts.length>0?{account:finalTo,soulBound:!!soulBound,ownedBy:ownedBy,lockedTokens:finalLockTokens,lockedNfts:finalLockNfts,properties:finalProperties}:{account:finalTo,soulBound:!!soulBound,ownedBy:ownedBy,lockedTokens:finalLockTokens,properties:finalProperties};const result=await api.db.insert(instanceTableName,newInstance);return nft.supply+=1,"null"===finalTo&&"contract"!==finalToType||(nft.circulatingSupply+=1),await api.db.update("nfts",nft),api.emit("issue",{from:finalFrom,fromType:finalFromType,to:finalTo,toType:finalToType,symbol:symbol,lockedTokens:finalLockTokens,lockedNfts:finalLockNfts,soulBound:!!soulBound,properties:finalProperties,id:result._id}),!0}}}}}return!1},actions.issueMultiple=async payload=>{const{instances:instances,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo}=payload;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(instances&&"object"==typeof instances&&Array.isArray(instances),"invalid params")&&api.assert(instances.length<=10,"cannot issue more than 10 NFT instances at once")){let containerCount=0;if(instances.forEach(instance=>{instance&&instance.lockNfts&&(containerCount+=1)}),api.assert(containerCount<=1,"cannot issue more than 1 container NFT instances at once")&&api.assert(0===containerCount||containerCount===instances.length,"cannot issue a mix of container and non-container NFT instances simultaneously"))for(let i=0;i<instances.length;i+=1)if(instances[i]){const{symbol:symbol,fromType:fromType,to:to,toType:toType,feeSymbol:feeSymbol,lockTokens:lockTokens,soulBound:soulBound,lockNfts:lockNfts,properties:properties}=instances[i];await actions.issue({symbol:symbol,fromType:fromType,to:to,toType:toType,feeSymbol:feeSymbol,lockTokens:lockTokens,soulBound:soulBound,lockNfts:lockNfts,properties:properties,isSignedWithActiveKey:isSignedWithActiveKey,callingContractInfo:callingContractInfo})}}};