const CONTRACT_NAME="crittermanager",CRITTER_CREATOR="cryptomancer",UTILITY_TOKEN_SYMBOL="'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'",CRITTERS_PER_PACK=5;actions.createSSC=async()=>{if(!1===await api.db.tableExists("params")){await api.db.createTable("params");const params={editionMapping:{"'${CONSTANTS.UTILITY_TOKEN_SYMBOL}$'":1,ALPHA:2,BETA:3}};await api.db.insert("params",params)}};const isTokenTransferVerified=(result,from,to,symbol,quantity,eventStr)=>!(void 0!==result.errors||!result.events||void 0===result.events.find((el=>"tokens"===el.contract&&el.event===eventStr&&el.data.from===from&&el.data.to===to&&api.BigNumber(el.data.quantity).eq(quantity)&&el.data.symbol===symbol)));actions.updateParams=async payload=>{if("cryptomancer"!==api.sender)return;const{editionMapping:editionMapping}=payload,params=await api.db.findOne("params",{});editionMapping&&"object"==typeof editionMapping&&(params.editionMapping=editionMapping),await api.db.update("params",params)},actions.createNft=async payload=>{if("cryptomancer"!==api.sender)return;const{isSignedWithActiveKey:isSignedWithActiveKey}=payload,nft=await api.db.findOneInTable("nft","nfts",{symbol:"CRITTER"});api.assert(null===nft,"CRITTER already exists")&&api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&(await api.executeSmartContract("nft","create",{name:"Mischievous Crypto Critters",symbol:"CRITTER",authorizedIssuingAccounts:[],authorizedIssuingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:"CRITTER",name:"edition",type:"number",isReadOnly:!0,authorizedEditingAccounts:[],authorizedEditingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:"CRITTER",name:"type",type:"number",isReadOnly:!0,authorizedEditingAccounts:[],authorizedEditingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:"CRITTER",name:"rarity",type:"number",isReadOnly:!0,authorizedEditingAccounts:[],authorizedEditingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:"CRITTER",name:"isGoldFoil",type:"boolean",isReadOnly:!0,authorizedEditingAccounts:[],authorizedEditingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:"CRITTER",name:"name",type:"string",authorizedEditingAccounts:[],authorizedEditingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:"CRITTER",name:"xp",type:"number",authorizedEditingAccounts:[],authorizedEditingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}),await api.executeSmartContract("nft","addProperty",{symbol:"CRITTER",name:"hp",type:"number",authorizedEditingAccounts:[],authorizedEditingContracts:[CONTRACT_NAME],isSignedWithActiveKey:isSignedWithActiveKey}))},actions.updateName=async payload=>{const{id:id,name:name}=payload;if(api.assert(id&&"string"==typeof id&&!api.BigNumber(id).isNaN()&&api.BigNumber(id).gt(0)&&name&&"string"==typeof name,"invalid params")&&api.assert(api.validator.isAlphanumeric(api.validator.blacklist(name," "))&&name.length>0&&name.length<=25,"invalid name: letters, numbers, whitespaces only, max length of 25")){const instance=await api.db.findOneInTable("nft","CRITTERinstances",{_id:api.BigNumber(id).toNumber()});instance&&api.assert(instance.account===api.sender&&"u"===instance.ownedBy,"must be the token holder")&&await api.executeSmartContract("nft","setProperties",{symbol:"CRITTER",fromType:"contract",nfts:[{id:id,properties:{name:name}}]})}};const generateRandomCritter=(edition,to)=>{const type=Math.floor(10*api.random())+1;let rarity=0,rarityRoll=Math.floor(1e3*api.random())+1;rarityRoll>995?rarity=3:rarityRoll>900?rarity=2:rarityRoll>700&&(rarity=1);let isGoldFoil=!1;rarityRoll=Math.floor(100*api.random())+1,rarityRoll>95&&(isGoldFoil=!0);return{symbol:"CRITTER",fromType:"contract",to:to,feeSymbol:UTILITY_TOKEN_SYMBOL,properties:{edition:edition,type:type,rarity:rarity,isGoldFoil:isGoldFoil,name:"",xp:0,hp:100}}};actions.hatch=async payload=>{const{packSymbol:packSymbol,packs:packs,isSignedWithActiveKey:isSignedWithActiveKey}=payload,params=await api.db.findOne("params",{}),{editionMapping:editionMapping}=params;if(api.assert(!0===isSignedWithActiveKey,"you must use a custom_json signed with your active key")&&api.assert(packSymbol&&"string"==typeof packSymbol&&packSymbol in editionMapping,"invalid pack symbol")&&api.assert(packs&&"number"==typeof packs&&packs>=1&&packs<=10&&Number.isInteger(packs),"packs must be an integer between 1 and 10")){const paymentTokenBalance=await api.db.findOneInTable("tokens","balances",{account:api.sender,symbol:packSymbol}),authorized=paymentTokenBalance&&api.BigNumber(paymentTokenBalance.balance).gte(packs);if(api.assert(authorized,"you must have enough pack tokens")){const crittersToHatch=5*packs,nftParams=await api.db.findOneInTable("nft","params",{}),{nftIssuanceFee:nftIssuanceFee}=nftParams,totalIssuanceFee=api.BigNumber(nftIssuanceFee[UTILITY_TOKEN_SYMBOL]).multipliedBy(8).multipliedBy(crittersToHatch),utilityTokenBalance=await api.db.findOneInTable("tokens","contractsBalances",{account:CONTRACT_NAME,symbol:UTILITY_TOKEN_SYMBOL}),canAffordIssuance=utilityTokenBalance&&api.BigNumber(utilityTokenBalance.balance).gte(totalIssuanceFee);if(api.assert(canAffordIssuance,"contract cannot afford issuance")){const res=await api.executeSmartContract("tokens","transfer",{to:"null",symbol:packSymbol,quantity:packs.toString(),isSignedWithActiveKey:isSignedWithActiveKey});if(!api.assert(isTokenTransferVerified(res,api.sender,"null",packSymbol,packs.toString(),"transfer"),"unable to transfer pack tokens"))return!1;for(let i=0;i<packs;i+=1){const instances=[];for(let j=0;j<5;j+=1)instances.push(generateRandomCritter(editionMapping[packSymbol],api.sender));await api.executeSmartContract("nft","issueMultiple",{instances:instances,isSignedWithActiveKey:isSignedWithActiveKey})}return!0}}}return!1};